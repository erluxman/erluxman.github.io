{"componentChunkName":"component---src-templates-blog-post-js","path":"/fr/how-does-setstate-know-what-to-do/","result":{"data":{"site":{"siteMetadata":{"title":"Overreacted","author":"Dan Abramov"}},"markdownRemark":{"id":"c3747735-9296-56b0-804d-b3c7eae61659","html":"<p>Quand vous appelez <code class=\"language-text\">setState</code> dans un composant, que croyez-vous qu’il se passe ?</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> ReactDOM <span class=\"token keyword\">from</span> <span class=\"token string\">'react-dom'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Button</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> clicked<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleClick <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">handleClick</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">handleClick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> clicked<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>clicked<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Merci</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleClick<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"></span>\n<span class=\"token plain-text\">        Cliquez-moi !</span>\n<span class=\"token plain-text\">      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Button</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">,</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'container'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Bien sûr, React refait le rendu du composant avec l’état <code class=\"language-text\">{ clicked: true }</code> et met à jour le DOM pour correspondre à l’élément <code class=\"language-text\">&lt;h1&gt;Merci&lt;/h1&gt;</code> retourné.</p>\n<p>Ça semble simple.  Mais attendez, est-ce <em>React</em> qui fait ça ? Ou <em>React DOM</em> ?</p>\n<p>La mise à jour du DOM semble faire partie des responsabilités de React DOM.  Mais nous appelons <code class=\"language-text\">this.setState()</code>, et non une API de React DOM.  Et notre classe de base <code class=\"language-text\">React.Component</code> est définie dans React lui-même.</p>\n<p>Alors comment <code class=\"language-text\">setState()</code>, au sein de <code class=\"language-text\">React.Component</code>, peut-elle mettre à jour le DOM ?</p>\n<p><strong>Avertissement : tout comme <a href=\"/why-do-react-elements-have-typeof-property/\">la plupart</a> des <a href=\"/how-does-react-tell-a-class-from-a-function/\">autres</a> <a href=\"/why-do-we-write-super-props/\">articles</a> de ce blog, vous n’avez pas vraiment <em>besoin</em> de savoir tout ça pour être efficace avec React. Cet article est plus pour les personnes qui aiment voir ce qu’il y a derrière le rideau.  C’est complètement optionnel !</strong></p>\n<hr>\n<p>On pourrait penser que la classe <code class=\"language-text\">React.Component</code> contient la logique de mise à jour du DOM.</p>\n<p>Mais si tel était le cas, comment <code class=\"language-text\">this.setState()</code> pourrait-elle fonctionner dans d’autres environnements ?  Par exemple, les composants dans les applications React Native étendent aussi <code class=\"language-text\">React.Component</code>.  Ils appellent <code class=\"language-text\">this.setState()</code> tout comme nous ci-dessus, et pourtant React Native utilise les vues natives d’Android et iOS plutôt que le DOM.</p>\n<p>Vous connaissez peut-être aussi React Test Renderer ou le Shallow Renderer.  Ces deux stratégies de test vous permettent de faire le rendu de composants normaux et d’appeler <code class=\"language-text\">this.setState()</code> dans leur code. Mais aucune des deux ne fonctionne avec le DOM.</p>\n<p>Si vous avez déjà utilisé des moteurs de rendu (<em>renderers</em>) comme <a href=\"https://github.com/facebook/react/tree/master/packages/react-art\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React ART</a>, vous pourriez aussi penser qu’il doit être possible d’utiliser plus d’un moteur de rendu dans la page. (Par exemple, les composants ART fonctionnent à l’intérieur d’une arborescence DOM.)  Du coup l’idée d’un drapeau ou d’une variable globale semble injouable.</p>\n<p>Il semble que d’une façon ou d’une autre, <strong><code class=\"language-text\">React.Component</code> délègue la gestion des mises à jour d’état à du code spécifique à la plate-forme.</strong>  Mais pour pouvoir comprendre comment ça se passe, il nous faut d’abord creuser un peu la façon dont les paquets sont séparés, et la raison de ce découpage.</p>\n<hr>\n<p>Une idée reçue tenace soutient que le « moteur » de React vit dans le module <code class=\"language-text\">react</code>.  Il n’en est rien.</p>\n<p>En fait, depuis la <a href=\"https://reactjs.org/blog/2015/07/03/react-v0.14-beta-1.html#two-packages\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">découpe de modules dans React 0.14</a>, le module <code class=\"language-text\">react</code> n’expose volontairement que les APIs pour <em>définir</em> les composants.  La majeure partie de l’<em>implémentation</em> de React vit dans les « moteurs de rendu » (<em>renderers</em>).</p>\n<p><code class=\"language-text\">react-dom</code>, <code class=\"language-text\">react-dom/server</code>, <code class=\"language-text\">react-native</code>, <code class=\"language-text\">react-test-renderer</code>, <code class=\"language-text\">react-art</code> sont autant d’exemples de moteurs (et vous pouvez <a href=\"https://github.com/facebook/react/blob/master/packages/react-reconciler/README.md#practical-examples\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">créer le vôtre</a>).</p>\n<p>C’est pourquoi le module <code class=\"language-text\">react</code> reste utile quelle que soit la plate-forme cible.  Tous ses exports, tels que <code class=\"language-text\">React.Component</code>, <code class=\"language-text\">React.createElement</code>, les utilitaires <code class=\"language-text\">React.Children</code> et (à terme) les <a href=\"https://reactjs.org/docs/hooks-intro.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Hooks</a>, sont indépendants de la plate-forme cible.  Que vous utilisiez React DOM, React DOM Server ou React Native, vos composants les importeraient et les utiliseraient de la même façon.</p>\n<p>À l’opposé, les modules de moteurs expose des APIs spécifiques à la plate-forme, telles que <code class=\"language-text\">ReactDOM.render()</code>, qui vous permet de « monter » votre arborescence d’éléments React au sein d’un nœud du DOM.  Chaque moteur fournit une API de ce genre.  Dans l’idéal, la majorité des <em>composants</em> ne devrait pas avoir à importer quoi que ce soit du moteur.  Ce qui les rend plus universels.</p>\n<p><strong>Ce que la plupart des gens conçoivent comme le « moteur » de React réside dans chaque moteur de rendu individuel.</strong>  De nombreux moteurs incorporent une copie du même code—on l’appelle le <a href=\"https://github.com/facebook/react/tree/master/packages/react-reconciler\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">« réconciliateur »</a>. Une <a href=\"https://reactjs.org/blog/2017/12/15/improving-the-repository-infrastructure.html#migrating-to-google-closure-compiler\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">étape de build</a> fusionne le code du réconciliateur avec celui du moteur pour produire un bundle unique hautement optimisé afin d’améliorer les performances.  (Copier du code n’est généralement pas top pour la taille du bundle, mais la vaste majorité des utilisateurs de React n’ont besoin que d’un moteur à la fois, tel que <code class=\"language-text\">react-dom</code>.)</p>\n<p>Le point à retenir ici, c’est que le module <code class=\"language-text\">react</code> vous permet seulement d’<em>utiliser</em> des fonctionnalités de React, mais ne sait absolument pas <em>comment</em> elles sont implémentées.  Ce sont les modules de moteurs (<code class=\"language-text\">react-dom</code>, <code class=\"language-text\">react-native</code>, etc.) qui fournissent l’implémentation des fonctionnalités de React et la logique spécifique à la plate-forme.  Une partie de ce code est partagée (le « réconciliateur »), mais c’est un détail d’implémentation des différents moteurs.</p>\n<hr>\n<p>À présent nous savons pourquoi on a besoin de mettre à jour aussi bien les modules <code class=\"language-text\">react</code> que <code class=\"language-text\">react-dom</code> pour bénéficier des nouvelles fonctionnalités.  Par exemple, quand React 16.3 a ajouté l’API de Contextes, <code class=\"language-text\">React.createContext()</code> était exposée sur le module React.</p>\n<p>Mais <code class=\"language-text\">React.createContext()</code> <em>n’implémente</em> pas vraiment la fonctionnalité de contexte. L’implémentation va différer par exemple entre React DOM et React DOM Server. Du coup, <code class=\"language-text\">createContext()</code> ne renvoie que quelques objets nus :</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Un peu simplifié</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">createContext</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">defaultValue</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> context <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    _currentValue<span class=\"token operator\">:</span> defaultValue<span class=\"token punctuation\">,</span>\n    Provider<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n    Consumer<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  context<span class=\"token punctuation\">.</span>Provider <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    $$<span class=\"token keyword\">typeof</span><span class=\"token operator\">:</span> Symbol<span class=\"token punctuation\">.</span><span class=\"token function\">for</span><span class=\"token punctuation\">(</span><span class=\"token string\">'react.provider'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    _context<span class=\"token operator\">:</span> context\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  context<span class=\"token punctuation\">.</span>Consumer <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    $$<span class=\"token keyword\">typeof</span><span class=\"token operator\">:</span> Symbol<span class=\"token punctuation\">.</span><span class=\"token function\">for</span><span class=\"token punctuation\">(</span><span class=\"token string\">'react.context'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    _context<span class=\"token operator\">:</span> context<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> context<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Quand vous utilisez <code class=\"language-text\">&lt;MyContext.Provider&gt;</code> ou <code class=\"language-text\">&lt;MyContext.Consumer&gt;</code> dans votre code, c’est le <em>moteur</em> qui décide comment les traiter.  React DOM assurera le suivi des valeurs d’une certaine façon, mais React DOM Server pourrait très bien bosser différemment.</p>\n<p><strong>Ainsi si vous mettez à jour <code class=\"language-text\">react</code> en 16.3+ mais négligez la mise à jour correspondante de <code class=\"language-text\">react-dom</code>, vous utiliseriez un moteur qui n’est pas encore au fait des types spéciaux <code class=\"language-text\">Provider</code> et <code class=\"language-text\">Consumer</code>.</strong>  C’est pourquoi une version plus ancienne de <code class=\"language-text\">react-dom</code> <a href=\"https://stackoverflow.com/a/49677020/458193\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">échouerait en déclarant ces types comme invalides</a>.</p>\n<p>La même mise en garde existe pour React Native.  Toutefois, contrairement à React DOM, une version de React n’entraîne pas obligatoirement la version associée de React Native.  Les deux ont des cycles de versions indépendants.  Le code du moteur mis à jour est <a href=\"https://github.com/facebook/react-native/commits/master/Libraries/Renderer/oss\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">synchronisé séparément</a> au sein du dépôt React Native, à quelques semaines d’intervalle.  C’est pourquoi les fonctionnalités de React deviennent disponibles dans React Native à un rythme distinct de celui de React DOM.</p>\n<hr>\n<p>Bon, donc on sait maintenant que le module <code class=\"language-text\">react</code> ne contient rien de bien intéressant, et que l’implémentation vit dans les moteurs comme <code class=\"language-text\">react-dom</code>, <code class=\"language-text\">react-native</code> et ainsi de suite.  Mais ça ne répond toujours pas à notre question.  Comment <code class=\"language-text\">setState()</code>, au sein de <code class=\"language-text\">React.Component</code>, « parle-t-il » au bon moteur ?</p>\n<p><strong>Il s’avère que chaque moteur définit un champ spécial sur la classe créée.</strong> Ce champ est appelée <code class=\"language-text\">updater</code>.  Ce n’est pas quelque chose que <em>vous</em> définiriez—c’est plutôt un champ défini par React DOM, React DOM Server ou React Native juste après avoir instancié votre classe :</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Dans React DOM</span>\n<span class=\"token keyword\">const</span> inst <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">YourComponent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ninst<span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n<span class=\"gatsby-highlight-code-line\">inst<span class=\"token punctuation\">.</span>updater <span class=\"token operator\">=</span> ReactDOMUpdater<span class=\"token punctuation\">;</span></span>\n<span class=\"token comment\">// Dans React DOM Server</span>\n<span class=\"token keyword\">const</span> inst <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">YourComponent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ninst<span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n<span class=\"gatsby-highlight-code-line\">inst<span class=\"token punctuation\">.</span>updater <span class=\"token operator\">=</span> ReactDOMServerUpdater<span class=\"token punctuation\">;</span></span>\n<span class=\"token comment\">// Dans React Native</span>\n<span class=\"token keyword\">const</span> inst <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">YourComponent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ninst<span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n<span class=\"gatsby-highlight-code-line\">inst<span class=\"token punctuation\">.</span>updater <span class=\"token operator\">=</span> ReactNativeUpdater<span class=\"token punctuation\">;</span></span></code></pre></div>\n<p>Si on regarde <a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react/src/ReactBaseClasses.js#L58-L67\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">l’implémentation de <code class=\"language-text\">setState</code> dans <code class=\"language-text\">React.Component</code></a>, elle se contente de déléguer le boulot au moteur qui a instancié le composant :</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Un peu simplifié</span>\n<span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">partialState<span class=\"token punctuation\">,</span> callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Utilise le champ `updater` pour parler au moteur !</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>updater<span class=\"token punctuation\">.</span><span class=\"token function\">enqueueSetState</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> partialState<span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>React DOM Server <a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-dom/src/server/ReactPartialRenderer.js#L442-L448\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">pourrait vouloir</a>\nignorer une mise à jour de l’état et vous avertir, tandis que React DOM et React Native laisseraient leurs copies du réconciliateur <a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-reconciler/src/ReactFiberClassComponent.js#L190-L207\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">gérer la mise à jour</a>.</p>\n<p>Et voilà comment <code class=\"language-text\">this.setState()</code> peut mettre à jour le DOM même s’il est défini dans le module noyau React.  Il récupère le <code class=\"language-text\">this.updater</code> qui a été défini par React DOM, et laisse ce dernier planifier et exécuter la mise à jour.</p>\n<hr>\n<p>Maintenant qu’on sait ce qu’il en est pour les classes, qu’est-ce que ça donne avec les Hooks ?</p>\n<p>Quand les gens commencent à lire la <a href=\"https://reactjs.org/docs/hooks-intro.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">proposition d’API pour les Hooks</a>, ils se demandent souvent : comment <code class=\"language-text\">useState</code> « sait-il quoi faire » ? Ils supposent apparemment que c’est plus « magique » que la classe <code class=\"language-text\">React.Component</code> et <code class=\"language-text\">this.setState()</code>.</p>\n<p>Mais comme nous venons de le voir, l’implémentation de <code class=\"language-text\">setState()</code> dans cette classe de base a toujours été une illusion.  Elle ne fait rien d’autre que transférer l’appeler au moteur courant. Et le Hook <code class=\"language-text\">useState</code> <a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react/src/ReactHooks.js#L55-L56\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">fait exactement la même chose</a>.</p>\n<p><strong>Au lieu du champ <code class=\"language-text\">updater</code>, les Hooks utilisent un objet « envoyeur ».</strong> Quand vous appelez <code class=\"language-text\">React.useState()</code>, <code class=\"language-text\">React.useEffect()</code>, ou n’importe quel autre Hook prédéfini, ces appels sont transférés à l’envoyeur courant.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Dans React (un peu simplifié)</span>\n<span class=\"token keyword\">const</span> React <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// La véritable propriété est en fait enfouie plus profondément,</span>\n  <span class=\"token comment\">// essayez donc de la trouver !</span>\n  __currentDispatcher<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n\n  <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">initialState</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> React<span class=\"token punctuation\">.</span>__currentDispatcher<span class=\"token punctuation\">.</span><span class=\"token function\">useState</span><span class=\"token punctuation\">(</span>initialState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">initialState</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> React<span class=\"token punctuation\">.</span>__currentDispatcher<span class=\"token punctuation\">.</span><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span>initialState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Et les différents moteurs définissent l’envoyeur avant d’assurer le rendu du composant :</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Dans React DOM</span>\n<span class=\"token keyword\">const</span> prevDispatcher <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span>__currentDispatcher<span class=\"token punctuation\">;</span>\n<span class=\"gatsby-highlight-code-line\">React<span class=\"token punctuation\">.</span>__currentDispatcher <span class=\"token operator\">=</span> ReactDOMDispatcher<span class=\"token punctuation\">;</span></span><span class=\"token keyword\">let</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n  result <span class=\"token operator\">=</span> <span class=\"token function\">YourComponent</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token comment\">// Restaurer l’envoyeur</span></span><span class=\"gatsby-highlight-code-line\">  React<span class=\"token punctuation\">.</span>__currentDispatcher <span class=\"token operator\">=</span> prevDispatcher<span class=\"token punctuation\">;</span></span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>Par exemple, l’implémentation pour React DOM Server est <a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-dom/src/server/ReactPartialRendererHooks.js#L340-L354\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ici</a>, et l’implémentation au sein du réconciliateur partagé par React DOM et React Native est <a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-reconciler/src/ReactFiberHooks.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">là</a>.</p>\n<p>C’est pour cela qu’un moteur comme <code class=\"language-text\">react-dom</code> a besoin d’accéder au même module <code class=\"language-text\">react</code> que celui d’où viennent les Hooks. Sinon, votre composant ne « verra » pas l’envoyeur !  Ça pourrait ne pas marcher si vous avez <a href=\"https://github.com/facebook/react/issues/13991\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">plusieurs copies de React</a> dans une même arborescence de composants. Ceci étant dit, ces situations ont toujours entraîné des bugs obscurs, de sorte que les Hooks vous forcent à régler votre problème de duplication avant qu’il ne vous coûte cher.</p>\n<p>Par ailleurs, même si ce n’est pas recommandé, vous pouvez techniquement remplacer l’envoyeur vous-même pour des cas d’usage autour d’un outillage avancé. (J’ai menti sur le nom <code class=\"language-text\">__currentDispatcher</code>, mais vous pouvez trouver le véritable emplacement dans le dépôt de React.)  Par exemple, les React DevTools utiliseront <a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-debug-tools/src/ReactDebugHooks.js#L203-L214\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">un envoyeur sur-mesure</a> pour introspecter l’arborescence des Hooks en capturant les piles d’appels JavaScript.  <em>N’essayez pas ça chez vous.</em></p>\n<p>Ça signifie aussi que les Hooks ne sont pas intrinsèquement liés à React.  Si à l’avenir davantage de bibliothèques veulent réutiliser ces mêmes Hooks prédéfinis, en théorie l’envoyeur pourrait être extrait dans son propre module et exposé en tant qu’API à part entière, avec un nom sans doute moins « effrayant ».  En pratique, on préfère éviter les abstractions prématurées et attendre qu’un véritable besoin émerge.</p>\n<p>Tant le champ <code class=\"language-text\">updater</code> que l’objet <code class=\"language-text\">__currentDispatcher</code> sont des manifestations d’un principe général de programmation appelée <em>l’injection de dépendances</em>.  Dans les deux cas, les moteurs « injectent » l’implémentation de fonctionnalités telles que <code class=\"language-text\">setState</code> dans le module React générique, afin que vos composants restent plus déclaratifs.</p>\n<p>Vous n’avez pas à vous soucier de tout ça pour utiliser React.  On préfère que les utilisateurs de React passent davantage de temps à réfléchir à leur code applicatif qu’à des notions abstraites comme l’injection de dépendances.  Mais si vous vous êtes déjà demandé comment <code class=\"language-text\">this.setState()</code> ou <code class=\"language-text\">useState()</code> savent quoi faire, j’espère que cet article vous a aidés.</p>","timeToRead":10,"frontmatter":{"title":"Comment setState sait-il quoi faire ?","date":"December 09, 2018","spoiler":"L’injection de dépendances c’est bien si vous n’avez pas besoin d’y penser.","cta":null},"fields":{"slug":"/fr/how-does-setstate-know-what-to-do/","langKey":"fr"}}},"pageContext":{"slug":"/fr/how-does-setstate-know-what-to-do/","translations":["es","fr","ja","ko","pt-br","tr","zh-hans"],"translatedLinks":["/why-do-react-elements-have-typeof-property/","/how-does-react-tell-a-class-from-a-function/","/why-do-we-write-super-props/"]}}}
{"componentChunkName":"component---src-templates-blog-post-js","path":"/fr/why-do-we-write-super-props/","result":{"data":{"site":{"siteMetadata":{"title":"Overreacted","author":"Dan Abramov"}},"markdownRemark":{"id":"f09bb14e-9ab1-5e79-bdac-5a0e798f43ef","html":"<p>Il paraÃ®t que les <a href=\"https://reactjs.org/docs/hooks-intro.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Hooks</a> sont le nouveau truc cool. Ironiquement, je souhaite commencer ce blog en parlant dâ€™aspects amusants sur les composants Ã©crits <em>sous forme de classes</em>. IncroyableÂ !</p>\n<p><strong>Ces petits piÃ¨ges ne sont <em>pas</em> importants pour une utilisation productive de React. Mais vous les trouverez peut-Ãªtre amusants si vous aimez fouiller pour comprendre comment les choses marchent.</strong></p>\n<p>Voici le premier.</p>\n<hr>\n<p>Jâ€™ai Ã©crit <code class=\"language-text\">super(props)</code> bien plus souvent que je ne veux bien lâ€™admettreÂ :</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Bien sÃ»r, la <a href=\"https://github.com/tc39/proposal-class-fields\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">proposition Class Fields</a> nous permet de laisser tomber le formalismeÂ :</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Une syntaxe similaire Ã©tait <a href=\"https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#es7-property-initializers\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">prÃ©vue</a> quand React 0.13 a commencÃ© Ã  prendre en charge les classes en 2015. DÃ©finir un <code class=\"language-text\">constructor</code> et appeler <code class=\"language-text\">super(props)</code> a toujours Ã©tÃ© considÃ©rÃ© comme une solution temporaire en attendant que les initialiseurs de champs nous fournissent une alternative plus ergonomique.</p>\n<p>Mais revenons Ã  cet exemple qui se limite aux syntaxes ES2015Â :</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Pourquoi appelle-t-on <code class=\"language-text\">super</code>Â ? Peut-on <em>ne pas</em> lâ€™appelerÂ ? Si on doit lâ€™appeler, que se passe-t-il si on ne passe pas <code class=\"language-text\">props</code>Â ? Yâ€™a-t-il dâ€™autres argumentsÂ ?</strong> Allons vÃ©rifier tout Ã§a.</p>\n<hr>\n<p>En JavaScript, <code class=\"language-text\">super</code> fait rÃ©fÃ©rence au constructeur de la classe parente. (Dans notre exemple, Ã§a pointe sur lâ€™implÃ©mentation de <code class=\"language-text\">React.Component</code>.)</p>\n<p>Point important, vous ne pouvez utiliser <code class=\"language-text\">this</code> dans un constructeur <em>quâ€™aprÃ¨s</em> avoir appelÃ© le constructeur parent (si vous avez fait un <code class=\"language-text\">extends</code> spÃ©cifique). JavaScript ne vous laissera pas le faire trop tÃ´tÂ :</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ğŸ”´ On ne peut pas utiliser `this` Ã  ce stade</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// âœ… Mais maintenant câ€™est bon !</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Il y a une bonne raison pour laquelle JavaScript vous force Ã  exÃ©cuter le constructeur parent avant de vous laisser toucher Ã  <code class=\"language-text\">this</code>. Imaginez cette hiÃ©rarchie de classesÂ :</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">PolitePerson</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">greetColleagues</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ğŸ”´ Ã‡a câ€™est interdit, lisez la raison dessous</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">greetColleagues</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Salut les gens !'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Imaginez que lâ€™utilisation de <code class=\"language-text\">this</code> avant lâ€™appel Ã  <code class=\"language-text\">super</code> <em>soit permis</em>. Un mois plus tard, nous changerons peut-Ãªtre <code class=\"language-text\">greetColleagues</code> pour inclure le nom de la personne dans le messageÂ :</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">  <span class=\"token function\">greetColleagues</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Salut les gens !'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Je mâ€™appelle '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">+</span> <span class=\"token string\">', enchantÃ©e !'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>Mais nous avons perdu de vue que <code class=\"language-text\">this.greetColleagues()</code> est appelÃ©e avant que notre appel Ã  <code class=\"language-text\">super()</code> ait une chance dâ€™initialiser <code class=\"language-text\">this.name</code>. Du coup <code class=\"language-text\">this.name</code> nâ€™est mÃªme pas encore dÃ©finiÂ ! Comme vous pouvez le voir, il peut Ãªtre dÃ©licat de bien comprendre le fonctionnement de ce genre de code.</p>\n<p>Pour Ã©viter ce genre de piÃ¨ges, <strong>JavaScript exige que si vous utilisez <code class=\"language-text\">this</code> dans un constructeur, vous <em>devez</em> appeler <code class=\"language-text\">super</code> dâ€™abord.</strong> Que la classe parente puisse faire son boulotÂ ! Et cette limitation sâ€™applique Ã©galement aux composants React dÃ©finis par des classesÂ :</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// âœ… On peut utiliser `this` dÃ©sormais</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>Ce qui nous laisse avec une autre questionÂ : pourquoi passer <code class=\"language-text\">props</code>Â ?</p>\n<hr>\n<p>Vous pensez peut-Ãªtre que refiler <code class=\"language-text\">props</code> Ã  <code class=\"language-text\">super</code> est nÃ©cessaire afin que le constructeur <code class=\"language-text\">React.Component</code> dâ€™origine puisse initialiser <code class=\"language-text\">this.props</code>Â ?</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Dans React</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Et ce nâ€™est pas trÃ¨s Ã©loignÃ© de la vÃ©ritÃ©â€”en fait, câ€™est <a href=\"https://github.com/facebook/react/blob/1d25aa5787d4e19704c049c3cfa985d3b5190e0d/packages/react/src/ReactBaseClasses.js#L22\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ce que Ã§a fait</a>.</p>\n<p>Et pourtant, mÃªme si vous appelez <code class=\"language-text\">super()</code> sans passer <code class=\"language-text\">props</code> en argument, vous arriveriez toujours Ã  accÃ©der Ã  <code class=\"language-text\">this.props</code> dans le <code class=\"language-text\">render</code> et dâ€™autres mÃ©thodes. (Si vous ne me croyez pas, essayez par vous-mÃªmeÂ !)</p>\n<p>Mais <em>comment Ã§a marche</em>Â ? Eh bien, il se trouve que <strong>React affecte aussi <code class=\"language-text\">props</code> sur lâ€™instance juste aprÃ¨s avoir appelÃ© <em>votre</em> constructeur.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Dans React</span>\n<span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">YourComponent</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ninstance<span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Donc mÃªme si vous oubliez de passer <code class=\"language-text\">props</code> Ã  <code class=\"language-text\">super()</code>, React les dÃ©finirait tout de mÃªme par la suite. Il y a une raison Ã  Ã§a.</p>\n<p>Quand React a commencÃ© Ã  prendre en charge les classes, il ne sâ€™est pas limitÃ© aux classes ES6. Lâ€™objectif Ã©tait de prendre en charge la plus large gamme dâ€™abstractions de classes possible. On nâ€™Ã©tait <a href=\"https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#other-languages\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">pas sÃ»rs</a> des potentiels de succÃ¨s de ClojureScript, CoffeeScript, ES6, Fable, Scala.js, TypeScript, ou dâ€™autres solutions pour dÃ©finir des composants. RÃ©sultat, React Ã©vitait volontairement dâ€™avoir une opinion trop tranchÃ©e sur la nÃ©cessitÃ© dâ€™appeler <code class=\"language-text\">super()</code>â€”mÃªme si câ€™est le cas dans les classes ES6.</p>\n<p>Alors, devriez-vous juste Ã©crire <code class=\"language-text\">super()</code> au lieu de <code class=\"language-text\">super(props)</code>Â ?</p>\n<p><strong>Probablement pas, car Ã§a pourrait causer de la confusion.</strong> Bien sÃ»r, React dÃ©finira par la suite <code class=\"language-text\">this.props</code>, <em>aprÃ¨s</em> que votre constructeur aura Ã©tÃ© exÃ©cutÃ©. Mais <code class=\"language-text\">this.props</code> nâ€™en serait pas moins <code class=\"language-text\">undefined</code> <em>entre</em> lâ€™appel Ã  <code class=\"language-text\">super</code> et la fin de votre constructeurÂ :</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Dans React</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Dans votre code</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Button</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ğŸ˜¬ On a oubliÃ© de passer les props</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// âœ… {}</span>\n<span class=\"gatsby-highlight-code-line\">    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ğŸ˜¬ undefined</span></span>  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>DÃ©boguer ce type de situation peut mÃªme Ãªtre encore plus difficile si le souci survient au sein dâ€™une mÃ©thode appelÃ©e <em>depuis</em> le constructeur. <strong>Et voilÃ  pourquoi je recommande de toujours appeler <code class=\"language-text\">super(props)</code>, mÃªme si ce nâ€™est pas strictement nÃ©cessaireÂ :</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Button</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// âœ… On a passÃ© les props</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// âœ… {}</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// âœ… {}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Ã‡a garantit que <code class=\"language-text\">this.props</code> est dÃ©fini mÃªme avant la fin du constructeur.</p>\n<hr>\n<p>Si vous utilisez React depuis longtemps, un dernier point vous chatouille peut-Ãªtre.</p>\n<p>Vous avez peut-Ãªtre remarquÃ© que lorsque vous utilisez lâ€™API de Contextes dans des classes (aussi bien lâ€™ancienne basÃ©e sur <code class=\"language-text\">contextTypes</code> que la plus rÃ©cente, basÃ©e sur <code class=\"language-text\">contextType</code>, apparue dans React 16.6), <code class=\"language-text\">context</code> est passÃ© en second argument au constructeur.</p>\n<p>Alors pourquoi nâ€™Ã©crit-on pas plutÃ´t <code class=\"language-text\">super(props, context)</code>Â ? On pourrait, mais le contexte est utilisÃ© moins souvent, de sorte quâ€™on trÃ©buche moins lÃ -dessus.</p>\n<p><strong>Avec la proposition Class Fields, ce type de piÃ¨ge disparaÃ®t de toutes faÃ§ons presque entiÃ¨rement.</strong> Sans constructeur explicite, tous les arguments sont transmis automatiquement. Câ€™est ce qui permet Ã  une expression comme <code class=\"language-text\">state = {}</code> de rÃ©fÃ©rencer <code class=\"language-text\">this.props</code> ou <code class=\"language-text\">this.context</code> si nÃ©cessaire.</p>\n<p>Avec les Hooks, on nâ€™a mÃªme pas besoin de <code class=\"language-text\">super</code> ou <code class=\"language-text\">this</code>. Mais câ€™est un sujet pour un autre jour.</p>","timeToRead":6,"frontmatter":{"title":"Pourquoi Ã©crit-on super(props)Â ?","date":"November 30, 2018","spoiler":"Il y a une surprise Ã  la fin.","cta":null},"fields":{"slug":"/fr/why-do-we-write-super-props/","langKey":"fr"}}},"pageContext":{"slug":"/fr/why-do-we-write-super-props/","translations":["cs","de","es","fr","fa","it","ja","hu","my","nl","nb","sk","pl","sr","pt-br","vi","tr","th","uk","zh-hans","zh-hant"],"translatedLinks":[]}}}
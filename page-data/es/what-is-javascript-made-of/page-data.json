{"componentChunkName":"component---src-templates-blog-post-js","path":"/es/what-is-javascript-made-of/","result":{"data":{"site":{"siteMetadata":{"title":"Overreacted","author":"Dan Abramov"}},"markdownRemark":{"id":"63dc21a6-c270-51c6-a511-cbcc2c36c4f7","html":"<p>Durante mis primeros años programando en JavaScript, me sentía como si fuese un fraude. Aunque era capaz de crear páginas web usando frameworks, había algo que se me escapaba. No tenía una base sólida de JavaScript y por ese motivo, temía ir a entrevistas de trabajo.</p>\n<p>Con el paso de los años, desarrollé un mapa mental con los fundamentos básicos de JavaScript y esto me dio confianza. Y ahora, quiero compartir una versión <strong>comprimida</strong> de todo ello. Está estructurado como un glosario, con cada tema resumido en unas pocas frases.</p>\n<p>A medida que vayas leyendo, intenta puntuar tus conocimientos en relación a cómo de <em>seguro</em> te sientes acerca de cada tema. ¡No te juzgaré si no tienes conocimientos en todos ellos! Al final del post, hay algo que podría ayudarte si este es tu caso.</p>\n<hr>\n<ul>\n<li>\n<p><strong>Valor</strong>: El concepto de valor es un poco abstracto. Es un “algo”. Un valor en JavaScript es lo mismo que un número a las matemáticas, o un punto en geometría. Cuando un programa se está ejecutando, su mundo está lleno de valores. Números como <code class=\"language-text\">1</code>, <code class=\"language-text\">2</code> y <code class=\"language-text\">420</code> son valores, igual que lo son otras cosas, como esta frase: <code class=\"language-text\">&quot;Las vacas hacen mu&quot;</code>. Aunque no <em>todo</em> es un valor, un número es un valor, pero una estructura de control <code class=\"language-text\">if</code> no lo es. A continuación, veremos algunos tipos de valores.</p>\n<ul>\n<li><strong>Tipos de valor</strong>: Existen varios “tipos” diferentes de valores. Por ejemplo, <em>números</em> como <code class=\"language-text\">420</code>, <em>cadenas de caracteres</em> como <code class=\"language-text\">&quot;Las vacas hacen mu&quot;</code>, <em>objetos</em> y algunos otros tipos más. Se puede ver el tipo de un valor poniendo <code class=\"language-text\">typeof</code> antes del valor. Por ejemplo, <code class=\"language-text\">console.log(typeof 2)</code> devuelve <code class=\"language-text\">&quot;number&quot;</code>.</li>\n<li><strong>Valores primitivos</strong>: Algunos tipos de valores son “primitivos”. Se incluyen en esta categoría números, cadenas de caracteres y algunos otros tipos más. Una cosa peculiar de los valores primitivos es que no se pueden crear más tipos ni cambiarlos de ninguna manera. Por ejemplo, cada vez que escribes <code class=\"language-text\">2</code>, obtienes el <em>mismo</em> valor <code class=\"language-text\">2</code>. No puedes “crear” otro <code class=\"language-text\">2</code> en el programa, o hacer que el <em>valor</em> <code class=\"language-text\">2</code> se “convierta” en <code class=\"language-text\">3</code>. Esto también es cierto para las cadenas de caracteres.</li>\n<li><strong><code class=\"language-text\">null</code> y <code class=\"language-text\">undefined</code></strong>: Estos dos, son tipos especiales de valores. Son especiales porque hay muchas cosas que no se pueden hacer con ellos — aunque a menudo causan errores. Por lo general, <code class=\"language-text\">null</code> representa la ausencia intencional de un valor, y <code class=\"language-text\">undefined</code> representa la ausencia involuntaria de un valor. Sin embargo, cuándo usarlos queda a disposición del programador. Existen porque a veces es mejor que una operación falle que proceder con la ausencia de un valor.</li>\n</ul>\n</li>\n<li>\n<p><strong>Igualdad</strong>: al igual que “valor”, igualdad es un concepto fundamental en JavaScript. Decimos que dos valores son iguales cuando son… en realidad, yo nunca diría esto. Si dos valores son iguales, significa que <em>son</em> el mismo valor. ¡No dos valores diferentes, sino uno! Por ejemplo, <code class=\"language-text\">&quot;Las vacas hacen mu&quot; === &quot;Las vacas hacen mu&quot;</code> y <code class=\"language-text\">2 === 2</code> porque <code class=\"language-text\">2</code> <em>es</em> <code class=\"language-text\">2</code>. Ten en cuenta que usamos <em>tres</em> signos de igual para representar este concepto de igualdad en JavaScript.</p>\n<ul>\n<li><strong>Igualdad estricta</strong>: Igual que el ejemplo anterior.</li>\n<li><strong>Igualdad referencial</strong>: Igual que el ejemplo anterior.</li>\n<li><strong>Igualdad estándar</strong>: ¡Este es diferente! La igualdad estándar es cuando usamos <em>dos</em> signos de igual (<code class=\"language-text\">==</code>). Las cosas pueden ser consideradas <em>más o menos iguales</em> incluso si se refieren a valores <em>diferentes</em> que se parecen (por ejemplo, <code class=\"language-text\">2</code> y <code class=\"language-text\">&quot;2&quot;</code>). Se agregó a JavaScript desde el principio por conveniencia y desde entonces ha causado una confusión infinita. Este concepto no es fundamental, pero es una fuente común de errores. Puedes aprender cómo funciona en un día lluvioso, pero muchas personas intentan evitarlo.</li>\n</ul>\n</li>\n<li><strong>Literal</strong>: Un literal es cuando nos referimos a un valor que escribimos <em>literalmente</em> en nuestro código. Por ejemplo, <code class=\"language-text\">2</code> es un <em>literal de número</em>, y <code class=\"language-text\">&quot;Banana&quot;</code> es un <em>literal de cadena</em>.</li>\n<li>\n<p><strong>Variable</strong>: una variable permite referirse a un valor utilizando un nombre. Por ejemplo, <code class=\"language-text\">let mensaje = &quot;Las vacas hacen mu&quot;</code>. Ahora podrías utilizar <code class=\"language-text\">mensaje</code> en lugar de repetir la misma frase cada vez que quieras usarla en el código. Más tarde, podrías cambiar <code class=\"language-text\">mensaje</code> para que apunte a otro valor, como <code class=\"language-text\">mensaje = &quot;Soy una morsa&quot;</code>. Ten en cuenta que esto no cambia <em>el valor en sí</em>, sino solo donde apunta el <code class=\"language-text\">mensaje</code>, como si estuvieran “conectados”. Antes apuntaba a <code class=\"language-text\">&quot;Las vacas hacen mu&quot;</code>, y ahora apunta a <code class=\"language-text\">&quot;Soy una morsa&quot;</code>.</p>\n<ul>\n<li><strong>Alcance</strong>: apestaría si solo pudiera haber una variable ‘mensaje’ en todo el programa. En cambio, cuando definimos una variable, esta está disponible en una <em>parte</em> del programa. Esa parte se llama “alcance”. Existen reglas sobre cómo funciona el alcance, pero generalmente puedes buscar las llaves <code class=\"language-text\">{</code> y <code class=\"language-text\">}</code> más cercanas alrededor de donde una variable ha sido definida. Ese “bloque” de código es su alcance.</li>\n<li><strong>Asignación</strong>: cuando escribimos <code class=\"language-text\">mensaje = &quot;Soy una morsa&quot;</code>, cambiamos la variable <code class=\"language-text\">mensaje</code> para que apunte al valor <code class=\"language-text\">&quot;Soy una morsa&quot;</code>. Esto se denomina asignación, escritura o configuración de la variable.</li>\n<li><strong><code class=\"language-text\">let</code> vs<code class=\"language-text\">const</code> vs <code class=\"language-text\">var</code></strong>: Por lo general, querrás usar <code class=\"language-text\">let</code>. Si deseas prohibir la asignación a una variable, puedes usar <code class=\"language-text\">const</code>. (A veces algunas bases de código o tus compañeros de trabajo pueden ser un poco puntillosos y obligan a usar ‘const’ cuando solo hay una asignación). Evita ‘var’ si puedes porque sus reglas de Scope son confusas.</li>\n</ul>\n</li>\n<li>\n<p><strong>Object</strong>: Un objeto es un tipo especial de valor en JavaScript. Lo bueno de los objetos es que pueden tener conexiones con otros valores. Por ejemplo, el objeto <code class=\"language-text\">{sabor: &quot;vainilla&quot;}</code> contiene la propiedad <code class=\"language-text\">sabor</code> que apunta al valor <code class=\"language-text\">&quot;vainilla&quot;</code>. Piensa en un objeto como en un valor que es “tuyo” y tiene “conexiones desde él”.</p>\n<ul>\n<li><strong>Propiedad</strong>: Una propiedad es como una conexión desde un objeto apuntando a un valor. Puede que esto te recuerde a una variable: tiene un nombre (como <code class=\"language-text\">sabor</code>) y apunta a un valor (como <code class=\"language-text\">&quot;vainilla&quot;</code>). Pero al contrario que una variable, una propiedad “vive” <em>en</em> en el propio objeto en lugar de en algún lugar del código (alcance). Una propiedad se considera parte de un objeto — pero el valor al que apunta no es parte de ese objeto.</li>\n<li><strong>Objeto Literal</strong>: Un Objeto Literal es una manera de crear un valor en un objeto <em>literalmente</em> escribiéndolo en el código, como <code class=\"language-text\">{}</code> o <code class=\"language-text\">{sabor: &quot;vainilla&quot;}</code>. Dentro de <code class=\"language-text\">{}</code>, podemos tener múltiples pares <code class=\"language-text\">propiedad: valor</code> separados por comas. Esto nos permite indicar hacia donde “conecta” la propiedad desde nuestro objeto.</li>\n<li><strong>Identidad del Objecto</strong>: ya mencionamos que <code class=\"language-text\">2</code> es <em>igual</em> que <code class=\"language-text\">2</code> (en otras palabras, <code class=\"language-text\">2 === 2</code>) porque cuando escribimos <code class=\"language-text\">2</code>, estamos “llamando” al mismo valor. ¡Pero cuando escribimos <code class=\"language-text\">{}</code>, siempre recibiremos un valor <em>diferente</em>! Entonces <code class=\"language-text\">{}</code> <em>no es igual</em> a otro <code class=\"language-text\">{}</code>. Intenta esto en la consola: <code class=\"language-text\">{} === {}</code> (el resultado es false). Cuando el ordenador se encuentra <code class=\"language-text\">2</code> en tu código, siempre nos devuelve el mismo valor <code class=\"language-text\">2</code>. Sin embargo, los objetos literales son diferentes: cuando el ordenador se encuentra <code class=\"language-text\">{}</code>, <em>crea un nuevo objeto, el cual es siempre un valor nuevo</em>. Entonces, ¿qué es la identidad del objeto? Es simplemente otro término para igualdad, o igualdad de valores. Cuando decimos “<code class=\"language-text\">a</code> y <code class=\"language-text\">b</code> tienen la misma identidad”, queremos decir que “<code class=\"language-text\">a</code> y <code class=\"language-text\">b</code> apuntan al <em>mismo</em> valor” (<code class=\"language-text\">a === b</code>). Cuando decimos “<code class=\"language-text\">a</code> y <code class=\"language-text\">b</code> tienen diferentes identidades”, queremos decir “<code class=\"language-text\">a</code> y <code class=\"language-text\">b</code> apuntan a valores <em>diferentes</em>” (<code class=\"language-text\">a !== b</code>).</li>\n<li><strong>Notación por punto</strong>: Cuando queremos leer o asignar una propiedad a un objeto, podemos usar la notación por punto (<code class=\"language-text\">.</code>). Por ejemplo, si la variable <code class=\"language-text\">helado</code> apunta a un objeto en el que la propiedad <code class=\"language-text\">sabor</code> apunta a <code class=\"language-text\">&quot;chocolate&quot;</code>, escribir <code class=\"language-text\">helado.sabor</code> te devolvera <code class=\"language-text\">&quot;chocolate&quot;</code>.</li>\n<li><strong>Notación por corchetes</strong>: A veces no sabemos el nombre de la propiedad que queremos acceder. Por ejemplo, puede que unas veces queramos leer <code class=\"language-text\">helado.sabor</code> y otras <code class=\"language-text\">helado.gusto</code>. La notación por corchetes (<code class=\"language-text\">[]</code>) nos permite leer una propiedad cuando <em>su propio nombre</em> es una variable. Por ejemplo, digamos que <code class=\"language-text\">let miPropiedad = &#39;sabor&#39;</code>. Luego <code class=\"language-text\">helado[miPropiedad]</code> nos devolverá <code class=\"language-text\">&quot;chocolate&quot;</code>. Curiosamente, también podemos usarlo cuando creamos objetos: <code class=\"language-text\">{ [miPropiedad]: &quot;vainilla&quot; }</code>.</li>\n<li><strong>Mutación</strong>: Decimos que un objeto a sido <em>mutado</em> cuando alguien cambia para que apunte a un valor diferente. Por ejemplo, si declaramos <code class=\"language-text\">let helado = {sabor: &quot;vainilla&quot;}</code>, podemos después <em>mutarlo</em> con <code class=\"language-text\">helado.sabor = &quot;chocolate&quot;</code>. Observa que incluso cuando usamos <code class=\"language-text\">const</code> para declarar <code class=\"language-text\">helado</code>, todavía podremos mutar <code class=\"language-text\">helado.sabor</code>. Esto es porque <code class=\"language-text\">const</code> solo previene asignaciones a la variable <code class=\"language-text\">helado</code>, mientras que lo que nosotros hemos mutado es la <em>propiedad</em> (<code class=\"language-text\">sabor</code>) del objeto al que apunta. Algunas personas renuncian a usar ‘const’ por completo porque les resulta demasiado confuso.</li>\n<li><strong>Array</strong>: Un array es un objeto que representa una lista de “cosas”. Cuando creamos un <em>literal de array</em> como <code class=\"language-text\">[&quot;banana&quot;, &quot;chocolate&quot;, &quot;vainilla&quot;]</code>, esencialmente estamos creando un objeto cuya propiedad llamada <code class=\"language-text\">0</code> apunta al valor <code class=\"language-text\">&quot;banana&quot;</code>, la propiedad llamada <code class=\"language-text\">1</code> apunta al valor <code class=\"language-text\">&quot;chocolate&quot;</code>, y la propiedad llamada <code class=\"language-text\">2</code> apunta al valor <code class=\"language-text\">&quot;vainilla&quot;</code>. Sería un rollo escribir <code class=\"language-text\">{0: ..., 1: ..., 2: ...}</code> y por esto mismo es por lo que los arrays son muy útiles.\nHay varias maneras de trabajar con arrays que vienen incorporadas a JavaScript por defecto, como <code class=\"language-text\">map</code>, <code class=\"language-text\">filter</code>, y <code class=\"language-text\">reduce</code>. No desesperes si <code class=\"language-text\">reduce</code> parece muy confuso — es confuso para cualquiera.</li>\n<li><strong>Prototipo</strong>: ¿Qué pasa si intentamos acceder a una propiedad que no existe? Por ejemplo, <code class=\"language-text\">helado.gusto</code> (cuando la propiedad en realidad se llama <code class=\"language-text\">sabor</code>). La respuesta es que recibiremos el valor especial <code class=\"language-text\">undefined</code>. Una respuesta más detallada sería que la mayoría de los objetos en JavaScript tienen un “prototipo”. Puedes pensar en el prototipo como si fuese una propiedad “escondida” en cada objeto que determina “donde continuar buscando”. Así que si no existe la propiedad <code class=\"language-text\">gusto</code> en <code class=\"language-text\">helado</code>, JavaScript buscará la propiedad <code class=\"language-text\">gusto</code> en el prototipo del objeto, después en el prototipo de <em>este</em> objeto, y así sucesivamente, y solo retornará <code class=\"language-text\">undefined</code> si llega hasta el final de la “cadena de prototipos” sin encontrar <code class=\"language-text\">.gusto</code>. Es poco común interactuar con este mecanismo directamente, pero explica por qué el objeto <code class=\"language-text\">helado</code> tiene el método <code class=\"language-text\">toString</code> aunque nunca lo hayamos definido nosotros mismos — es porque viene del prototipo.</li>\n</ul>\n</li>\n<li>\n<p><strong>Funciones</strong>: Una función es un valor especial que tiene un objetivo concreto: representa <em>un fragmento de código</em> del programa. Las funciones son muy útiles para no tener que escribir el mismo código repetidas veces. “Llamar” a una función como <code class=\"language-text\">saludo()</code> le dice al ordenador que ejecute el código que contiene la función y que luego vuelva al mismo punto donde se encontraba antes. Hay muchas maneras de crear una función en JavaScript, con pequeñas diferencias en lo que puede hacer cada una.</p>\n<ul>\n<li><strong>Argumentos (o Parámetros)</strong>: Los argumentos nos permiten pasar información a la función en el momento en que la llamamos: <code class=\"language-text\">saludo(&quot;Amelie&quot;)</code>. Dentro de la función, los parámetros actúan como variables. Se les llama “argumentos” o “parámetros” dependiendo de donde nos encontremos (si es donde definimos la función o donde la llamamos). Sin embargo, esta distinción es muy puntillosa, y en la práctica estos términos se usan indistintamente.</li>\n<li><strong>Expresiones de función</strong>: Previamente, hemos declarado una variable con un valor <em>cadena de caracteres o string</em>, como <code class=\"language-text\">let mensaje = &quot;Soy una morsa&quot;</code>. También podemos asignar a una variable una <em>función</em>, como <code class=\"language-text\">let saludo = function() { }</code>. Lo que hay después del signo <code class=\"language-text\">=</code> es llamado <em>Expresiones de función</em>. Nos devuelve un valor especial (una función) que representa el código que contiene, de esta manera podemos llamar a ese código cuando queramos.</li>\n<li><strong>Declaración de función</strong>: Es muy cansado escribir algo como <code class=\"language-text\">let saludo = function() { }</code> cada vez que lo necesitemos, por eso podemos usar en su lugar: <code class=\"language-text\">function saludo() { }</code>. Esto se llama <em>declaración de función</em>. En lugar de especificar una variable a la izquierda, ponemos el nombre después de la palabra <code class=\"language-text\">function</code>. Estos estilos de declarar una función son casi siempre intercambiables.</li>\n<li><strong>Alzamiento de funciones o Hoisting</strong>: Normalmente, una variable solo puede ser usada después de declararla con <code class=\"language-text\">let</code> o <code class=\"language-text\">const</code>. Esto puede ser molesto cuando se trata de funciones porque puede que estas se llamen unas a otras, y es difícil rastrear qué función es utilizada por otras y cuales necesitan declararse primero. Por comodidad, cuando (¡y solo cuando!) usemos la sintaxis de <em>declaración de función</em>, el orden de las declaraciones no importa porque se “alzan”. Esta es una forma elegante de decir que conceptualmente, todas las funciones se trasladan automáticamente a la parte superior del alcance. Así que cuando llamamos a las funciones todas han sido ya declaradas.</li>\n<li><strong><code class=\"language-text\">this</code></strong>: Este es probablemente el concepto más incomprendido en JavaScript, <code class=\"language-text\">this</code> es como un argumento especial en una función. No hace falta pasárselo a la función nosotros mismos, JavaScript lo pasa por nosotros, dependiendo de <em>como ejecutemos</em> la función. Por ejemplo, ejecutarla usando la notación por punto <code class=\"language-text\">.</code> — como en <code class=\"language-text\">helado.comer()</code> — nos darán un valor <code class=\"language-text\">this</code> especial para lo que haya delante del punto <code class=\"language-text\">.</code> (en el ejemplo, <code class=\"language-text\">helado</code>). El valor de <code class=\"language-text\">this</code> dentro de la función depende de como la función es <em>llamada</em>, no de donde es definida. Métodos como <code class=\"language-text\">.bind</code>, <code class=\"language-text\">.call</code>, y <code class=\"language-text\">.apply</code> nos ayudan a tener mas control sobre el valor de <code class=\"language-text\">this</code>.</li>\n<li><strong>Funciones flecha</strong>: Las funciones flecha son similares a las expresiones de función. Se declaran así: <code class=\"language-text\">let saludo = () =&gt; { }</code>. Son muy concisas y normalmente van en una sola línea. Las funciones flecha son <em>más limitadas</em> que las funciones regulares — por ejemplo, no tienen la variable <code class=\"language-text\">this</code>. Cuando escribes <code class=\"language-text\">this</code> dentro de una función flecha, esta usa el <code class=\"language-text\">this</code> de la función regular mas cercana que contenga esta función. Esto es similar a lo que pasa si se utiliza un argumento o una variable que solo existe en una función anterior. Básicamente, esto significa que la gente usa funciones flecha cuando quieren “ver” el mismo <code class=\"language-text\">this</code> dentro de ellas como en el código que las rodea.</li>\n<li><strong>Enlazado de funciones</strong>: Normalmente, <em>enlazar</em> una función <code class=\"language-text\">f</code> a un <code class=\"language-text\">this</code> especifico y a sus argumentos significa crear una <em>nueva</em> función que llame a <code class=\"language-text\">f</code> con esos valores predefinidos. JavaScript tiene un método incorporado por defecto llamado <code class=\"language-text\">.bind</code>, pero también se puede hacer “a mano”. Enlazar era un método común de hacer que varias funciones “viesen” el mismo <code class=\"language-text\">this</code> que las funciones exteriores. Pero ahora esto se hace con funciones flecha, por lo que ya no se “enlazan” funciones con tanta frecuencia.</li>\n<li><strong>Pila de llamadas</strong>: Llamar a una función es como entrar a una habitación. Cada vez que llamamos a una función, las variables dentro de ella se inicializan nuevamente. Entonces, cada llamada a la función es como <em>construir</em> una nueva “habitación” con su código y entrar en ella. Las variables de nuestra función “viven” en esa habitación. Cuando volvemos de la función, esa “habitación” desaparece con todas sus variables. Podemos visualizar estas habitaciones como una pila vertical de habitaciones: una <em>pila de llamadas</em>. Cuando salimos de una función, volvemos a la función “debajo” de la pila de llamadas.</li>\n<li><strong>Recursión</strong>: Recursión significa que una función se llama a si misma desde su interior. Esto es útil cuando quieres repetir <em>otra vez</em> lo que acabas de hacer pero con argumentos diferentes. Por ejemplo, si estás escribiendo un buscador que rastree la web, la función <code class=\"language-text\">encuentraLinks(url)</code> podría primero recolectar todos los links de una pagina, y luego <em>llamarse a si misma</em> por cada <em>link</em> hasta que visite todas las paginas de esa web. El problema con recursión es que es fácil escribir una función que termine en un loop infinito porque se llama a sí misma continuamente. Si esto ocurre, JavaScript terminara la ejecución de la función con un error de “stack overflow o desbordamiento de pila de llamadas”. Se llama así porque hemos hecho muchas llamadas a la misma función en la pila de llamadas, literalmente, desbordándola.</li>\n<li><strong>Funciones de orden superior o High-order function</strong>: Una función de orden superior es una función que trabaja con otras funciones usándolas como argumentos o devolviéndolas como resultado de su ejecución. Esto puede parecer raro al principio, pero debemos recordar que las funciones son valores que se pueden usar por todo nuestro código — como hacemos con números, cadenas de caracteres y objetos. Este estilo no debe ser sobreutilizado, pero es muy expresivo si se usa con moderación.</li>\n<li><strong>Callback</strong>: Realmente Callback no es un término de JavaScript. Es más como un patrón. Es cuando pasamos una función como argumento de otra, esperando que la función que recibe la otra función como argumento la <em>ejecute después</em>. De esa manera esperamos un callback o <em>llamado posterior</em>. Por ejemplo, <code class=\"language-text\">setTimeout</code> recibe una función como <em>callback</em> y… la llama después de que pase un tiempo. No hay nada especial sobre las funciones <em>callback</em>. Son funciones normales, así que cuando decimos “callback” en realidad nos referimos a las expectativas que tenemos.</li>\n<li><strong>Clausura</strong>: Normalmente, cuando una función termina, todas sus variables “desaparecen”. Esto ocurre porque ya no se necesitan. ¿Pero qué pasa si declaras una función <em>dentro</em> de otra función? Entonces la función de dentro podría ser ejecutada más tarde y podría necesitar acceder/leer las variables de <em>fuera</em>, las de la función contenedora. ¡En la práctica, esto es muy útil! Pero para que esto funcione, las variables de la función contenedora necesitan “quedarse por ahí” en algún sitio. Así que en estos casos, JavaScript se encarga de “mantener esas variables vivas” en lugar de “olvidarse” de ellas como haría normalmente. Esto se llama “clausura”. Aunque las clausuras son normalmente un concepto bastante incomprendido de las características de JavaScript, probablemente las has utilizado muchas veces sin darte cuenta!</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>JavaScript está hecho de estos conceptos, y muchos más. En mi caso sentía mucha ansiedad en relación a mis conocimientos sobre JavaScript hasta que me formé un mapa mental fuerte sobre todo esto, así pues, me gustaría ayudar a las nuevas generaciones de programadores a superar estas dificultades mas fácilmente.</p>\n<p>Si quieres unirte a mí para sumergirnos mas profundamente en todos estos conceptos, tengo algo que podría interesarte. <strong><a href=\"https://justjavascript.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Just JavaScript</a> es mi mapa mental de como JavaScript funciona, y contará con las ilustraciones de la increíble <a href=\"https://illustrated.dev/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Maggie Appleton</a></strong>. Al contrario que este post, va a un ritmo más lento para que pueda ser seguido con más detalle.</p>\n<p><em>Just JavaScript</em> esta dando sus primeros pasos y solo esta disponible por email sin una edición muy cuidada. Si esto te parece interesante, puedes <a href=\"https://justjavascript.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">darte de alta</a> para recibir los borradores por email. Sería de mucha ayuda si me pudieses dar tu opinión. Muchas gracias!</p>","timeToRead":14,"frontmatter":{"title":"¿De qué está hecho JavaScript?","date":"December 20, 2019","spoiler":"Una mirada detallada a JavaScript.","cta":null},"fields":{"slug":"/es/what-is-javascript-made-of/","langKey":"es"}}},"pageContext":{"slug":"/es/what-is-javascript-made-of/","translations":["es","pt-br"],"translatedLinks":[]}}}
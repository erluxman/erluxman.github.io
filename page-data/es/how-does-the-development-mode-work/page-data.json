{"componentChunkName":"component---src-templates-blog-post-js","path":"/es/how-does-the-development-mode-work/","result":{"data":{"site":{"siteMetadata":{"title":"Overreacted","author":"Dan Abramov"}},"markdownRemark":{"id":"fd7cf908-6fd2-5724-83f4-e0ed6b18b2b9","html":"<p>Si tu base de código JavaScript es al menos moderadamente compleja, <strong>probablemente tienes una forma de compilar en <em>bundles</em> código diferente en desarrollo y producción</strong>.</p>\n<p>Compilar en <em>bundles</em> y ejecutar código diferente en desarrollo y producción es poderoso. En modo de desarrollo, React incluye muchas advertencias que te ayudan a encontrar problemas antes de que lleven a bugs. Sin embargo, el código necesario para detectar tales problemas con frecuencia aumentan el tamaño del <em>bundle</em> y ralentiza la aplicación.</p>\n<p>La ralentización es aceptable en desarrollo. De hecho, ejecutar el código más lentamente en desarrollo <em>puede hasta ser beneficioso</em> porque compensa parcialmente la discrepancia entre máquinas rápidas de desarrollo y los dispositivos promedio de los consumidores.</p>\n<p>En producción no queremos pagar ese costo. Por lo tanto, omitimos estas verificaciones. ¿Cómo funciona eso? Veamos.</p>\n<hr>\n<p>La forma exacta para ejecutar código en desarrollo depende de tu <em>build pipeline</em> de JavaScript (y de si tienes una). En Facebook es algo así:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>__DEV__<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">hacerAlgoEnDesarrollo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">hacerAlgoEnProd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Aquí, <code class=\"language-text\">__DEV__</code> no es una variable real. Es una constante que se sustituye cuando los módulos son compilados para el navegador. El resultado se ve así:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// En desarrollo:</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">hacerAlgoEnDesarrollo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 👈</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">hacerAlgoEnProd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// En producción:</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">hacerAlgoEnDesarrollo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">hacerAlgoEnProd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 👈</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>En producción, también ejecutarías un <em>minificador</em> (por ejemplo, <a href=\"https://github.com/terser-js/terser\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">terser</a>) en el código. La mayoría de los <em>minificadores</em> de JavaScript hacen una forma limitada de <a href=\"https://es.wikipedia.org/wiki/Eliminaci%C3%B3n_de_c%C3%B3digo_muerto\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">eliminación de código muerto</a>, como quitar las ramas <code class=\"language-text\">if (false)</code>. Entonces en producción sólo verías:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// En producción (luego de minificar):</span>\n<span class=\"token function\">hacerAlgoEnProd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><em>(Ten en cuenta que hay límites significativos en qué tan efectiva es la eliminación de código muerto con herramientas comunes de JavaScript, pero eso es un tema aparte.)</em></p>\n<p>Aunque puede que no estés usando la constante mágica <code class=\"language-text\">__DEV__</code>, si usas algún <em>bundler</em> de JavaScript popular como webpack, puede que haya otra convención que puedas seguir. Por ejemplo, es común expresar el mismo patrón de esta forma:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">NODE_ENV</span> <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">hacerAlgoEnDesarrollo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">hacerAlgoEnProd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Ese es exactamente el patrón usado por librerías como <a href=\"https://es.reactjs.org/docs/optimizing-performance.html#use-the-production-build\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React</a> y <a href=\"https://vuejs.org/v2/guide/deployment.html#Turn-on-Production-Mode\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Vue</a> cuando los importas de npm usando un <em>bundler</em></strong> (Las compilaciones de etiquetas <code class=\"language-text\">&lt;script&gt;</code> de un solo archivo ofrecen versiones de desarrollo y producción como archivos <code class=\"language-text\">.js</code> y <code class=\"language-text\">.min.js</code> separados.)</p>\n<p>Esta convención en particular viene de Node.js. En Node.js, hay una variable global <code class=\"language-text\">process</code> que expone las variables de entorno de tu sistema como propiedades en el objeto <a href=\"https://nodejs.org/dist/latest-v8.x/docs/api/process.html#process_process_env\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">process.env</code></a>. Sin embargo, cuando ves este patrón en una base de código de <em>front-end</em>, no hay ninguna variable real <code class=\"language-text\">process</code> involucrada. 🤯</p>\n<p>En su lugar, toda la expresión <code class=\"language-text\">process.env.NODE_ENV</code> se sustituye por un string literal en el momento de compilación, igual que nuestra variable mágica <code class=\"language-text\">__DEV__</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// En desarrollo</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'development'</span> <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// true</span>\n  <span class=\"token function\">hacerAlgoEnDesarrollo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 👈</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">hacerAlgoEnProd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// En producción:</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'production'</span> <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// false</span>\n  <span class=\"token function\">hacerAlgoEnDesarrollo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">hacerAlgoEnProd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 👈</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Dado que toda la expresión es constante (<code class=\"language-text\">&#39;production&#39; !== &#39;production&#39;</code> siempre será <code class=\"language-text\">false</code>), un <em>minificador</em> también puede quitar la otra rama.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// En producción (luego de minificar):</span>\n<span class=\"token function\">hacerAlgoEnProd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Travesura lograda.</p>\n<hr>\n<p>Ten en cuenta que esto <strong>no funcionaría</strong> con expresiones más complejas:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> mode <span class=\"token operator\">=</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mode <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 🔴 no se garantiza que se elimine</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Las herramientas de análisis estático de JavaScript no son muy inteligentes debido a la naturaleza dinámica del lenguaje. Cuando ven variables como <code class=\"language-text\">mode</code> en lugar de expresiones estáticas como <code class=\"language-text\">false</code> o <code class=\"language-text\">&#39;production&#39; !== &#39;production&#39;</code>, generalmente se rinden.</p>\n<p>De igual forma, la eliminación de código muerto en JavaScript generalmente no funciona bien fuera de los límites del módulo cuando usas la sentencia de nivel superior <code class=\"language-text\">import</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 🔴 no se garantiza que se elimine</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span>algunaFuncion<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'some-module'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">algunaFuncion</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Por eso necesitas escribir código de forma muy mecánica tal que haga la condición <em>definitivamente estática</em> y asegure que <em>todo el código</em> que quieres eliminar se encuentre dentro.</p>\n<hr>\n<p>Para que todo esto funcione, tu <em>bundler</em> necesita reemplazar <code class=\"language-text\">process.env.NODE_ENV</code> y necesita saber en qué modo <em>quieres</em> compilar el proyecto.</p>\n<p>Hace unos años, solía ser común olvidarse configurar el entorno. Con frecuencia veías proyectos en modo de desarrollo desplegados en producción.</p>\n<p>Eso es malo porque hace que el sitio web cargue y funcione más lentamente.</p>\n<p>En los últimos dos años, la situación mejoró significativamente. Por ejemplo, webpack añadió una simple opción <code class=\"language-text\">mode</code> en lugar de tener que configurar manualmente el reemplazo de <code class=\"language-text\">process.env.NODE_ENV</code>. Ahora React DevTools también muestra un ícono rojo en sitios en modo de desarrollo, haciendo más fácil identificar e incluso <a href=\"https://mobile.twitter.com/BestBuySupport/status/1027195363713736704\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">reportar</a>.</p>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ca1c0db064f73cc5c8e21ad605eaba26/0a47e/devmode.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 33.108108108108105%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAABYlAAAWJQFJUiTwAAABGUlEQVQY04WQ3W6DMAyF8/4vtStWSEmAQlm7aZUmIPy1lIRAoFCYA+p1jyLn2FbkL0bTOz1fAgvp0PfX6v73+RGdv1C7qus6pZSUErxstDa/dfSl1GNon9NjWZZxmtoyr283RAnFluW5XhAEpmn6/gE8sW1sYUqhSanjUEIw3v+cnFuZqH4QXKwgE0pYWuR5ylgcx4yxvCiKsoSgiymUU7DX8hpHUcIy6GZZdvm9AOY4jgiwXoSy0cQCzHaU5m0F5xCVTiTnHIwmH8dhGJBhGK7jAuzRO5mGa1sHlxyJHfret++esbU3dztC6Po7HB7DRjTLKj153Y1ei2wUrztRd/eqvVcSTF110IRRQsB4DoDwYJ5niPBnmPwP62GCWHyCrHAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"Advertencia de modo de desarrollo en React DevTools\"\n        title=\"\"\n        src=\"/static/ca1c0db064f73cc5c8e21ad605eaba26/fcda8/devmode.png\"\n        srcset=\"/static/ca1c0db064f73cc5c8e21ad605eaba26/12f09/devmode.png 148w,\n/static/ca1c0db064f73cc5c8e21ad605eaba26/e4a3f/devmode.png 295w,\n/static/ca1c0db064f73cc5c8e21ad605eaba26/fcda8/devmode.png 590w,\n/static/ca1c0db064f73cc5c8e21ad605eaba26/0a47e/devmode.png 600w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>Instaladores dogmáticos como Create React App, Next/Nuxt, Vue CLI, Gatsby y otros hacen más difícil equivocarse con esto separando los <em>builds</em> de desarrollo y producción en dos comandos separados (por ejemplo, <code class=\"language-text\">npm start</code> y <code class=\"language-text\">npm run build</code>). Generalmente, solo se puede desplegar el build de producción por lo que el desarrollador ya no puede cometer este error.</p>\n<p>Siempre existe un argumento que quizás el modo <em>producción</em> necesita ser el valor por defecto y el modo de desarrollo opcional. Personalmente no me convence este argumento. Las personas que se benefician más de las advertencias en el modo de desarrollo generalmente son nuevos en la librería. <em>No sabrían cómo activarlo,</em> y evitarían encontrar muchos bugs que con las advertencias se hacen evidentes.</p>\n<p>Si, los problemas de rendimiento son malos, pero también es enviar experiencias rotas y llenas de bugs a los usuarios finales. Por ejemplo, el <a href=\"https://es.reactjs.org/docs/lists-and-keys.html#keys\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">warning de <em>key</em> de React</a> ayuda a prevenir bugs como enviar un mensaje a la persona equivocada o comprar el producto erróneo. Desarrollar con esta advertencia desactivada es un riesgo significativo para ti <em>y</em> tus usuarios. Si está desactivada por defecto, entonces para el momento que encuentres la opción para activarlo, tendrás demasiadas advertencias para limpiar. Así que muchas personas lo volverían a apagar. Este es el motivo por el que necesita estar activado desde el comienzo en lugar de activado luego.</p>\n<p>Finalmente, incluso si las advertencias de desarrollo son opcionales y los desarrolladores <em>supieran</em> que deben activarlas en una etapa temprana del desarrollo, simplemente volveríamos al mismo problema. ¡Alguien accidentalmente las dejaría activadas en producción!</p>\n<p>Y volvimos al primer casillero.</p>\n<p>Personalmente creo en <strong>herramientas que muestran y usan el modo correcto dependiendo si estás depurando o desplegando</strong>. Casi cualquier entorno (sea móvil, escritorio o servidor) excepto el navegador ha tenido una forma de cargar y diferenciar builds de desarrollo y producción por décadas.</p>\n<p>En lugar de dejar a las librerías inventar y nosotros depender de convenciones ad-hoc, quizás es momento que los entornos de JavaScript vean la distinción como una necesidad de primera clase.</p>\n<hr>\n<p>¡Suficiente filosofía!</p>\n<p>Miremos de nuevo a este código:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">NODE_ENV</span> <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">hacerAlgoEnDesarrollo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">hacerAlgoEnProd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Quizás te preguntes: si no hay ningún objeto <code class=\"language-text\">process</code> en el código de front-end, ¿por qué las librerías como React y Vue dependen de ella en los builds de npm?</p>\n<p><em>(Para aclarar esto nuevamente; las etiquetas <code class=\"language-text\">&lt;script&gt;</code> que puedes cargar en el navegador, ofrecidas tanto por React y por Vue, no dependen de esto. En su lugar, tu tienes que manualmente elegir entre los archivos de desarrollo <code class=\"language-text\">.js</code> y de producción <code class=\"language-text\">.min.js</code>. La sección debajo es solo acerca de usar React o Vue con un bundler <code class=\"language-text\">import</code>ándolos desde npm.)</em></p>\n<p>Como muchas cosas en programación, esta convención en particular tiene mayormente motivos históricos. Aún estamos usándola porque ahora es ampliamente adoptada por diferentes herramientas. Cambiar a algo diferente es costoso y no aporta mucho.</p>\n<p>Entonces ¿cuál es la historia detrás?</p>\n<p>Muchos años antes de estandarizar la sintaxis de <code class=\"language-text\">import</code> y <code class=\"language-text\">export</code>, había muchas formas diferentes de expresar relaciones entre módulos. Node.js popularizó <code class=\"language-text\">require()</code> y <code class=\"language-text\">module.exports</code>, conocidos como <a href=\"https://en.wikipedia.org/wiki/CommonJS\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">CommonJS</a>.</p>\n<p>El código publicado en los comienzos del registro de npm era escrito para Node.js. Express era (¿y quizás aún lo sea?) el framework para servidores Node.js y <a href=\"https://expressjs.com/en/advanced/best-practice-performance.html#set-node_env-to-production\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">usaba la variable de entorno <code class=\"language-text\">NODE_ENV</code></a> para activar el modo de producción. Algunos otros paquetes de npm adoptaron la misma convención.</p>\n<p>Los primeros <em>bundlers</em> de JavaScript como browserify querían hacer posible usar el código de npm en proyectos de front-end. (Sí, en <a href=\"https://blog.npmjs.org/post/101775448305/npm-and-front-end-packaging\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ese entonces</a> ¡casi nadie usaba npm para front-end! ¿te imaginas?) Así que extendieron la misma convención ya presente en el ecosistema de Node.js a código de front-end.</p>\n<p>La transformada original “envify” fue <a href=\"https://github.com/hughsk/envify/commit/ae8aa26b759cd2115eccbed96f70e7bbdceded97\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">lanzada en 2013</a>. React fue hecho open source por ese entonces y npm con browserify parecía la mejor solución para compilar código CommonJS de front-end.</p>\n<p>React comenzó a proveer builds npm (adicionalmente a builds para etiquetas <code class=\"language-text\">&lt;script&gt;</code>) desde el comienzo. Cuando React se hizo popular, también lo hicieron las buenas prácticas para escribir JavaScript modular con CommonJS y entregar código de front-end vía npm.</p>\n<p>React necesitaba quitar código que era sólo para desarrollo en el modo de producción. Browserify ya ofrecía una solución a este problema, así que React adoptó la convención de usar <code class=\"language-text\">process.env.NODE_ENV</code> para sus builds npm. Con el tiempo, muchas otras herramientas y librerías, incluyendo webpack y Vue, hicieron lo mismo.</p>\n<p>Por el 2019, browserify ha perdido bastante popularidad. Sin embargo, reemplazar <code class=\"language-text\">process.env.NODE_ENV</code> con <code class=\"language-text\">development</code> o <code class=\"language-text\">production</code> en el paso de compilación es una convención aún popular.</p>\n<p><em>(Sería interesante ver cómo la adaptación de módulos ES como formato de distribución, en lugar de sólo como formato de autoría, cambia la ecuación. ¿Cuéntamelo en Twitter?)</em></p>\n<hr>\n<p>Una cosa que aún podría confundirte es que en el código fuente de React en GitHub verás que <code class=\"language-text\">__DEV__</code>es usada como variable mágica. Pero en el código de React en npm, usa <code class=\"language-text\">process.env.NODE_ENV</code>. ¿Cómo funciona eso?</p>\n<p>Históricamente usamos <code class=\"language-text\">__DEV__</code> en el código fuente para que coincida con el código de Facebook. Por un largo tiempo, React era copiado directamente en la base de código de Facebook por lo que debía seguir las mismas reglas. Para npm, teníamos un paso de compilación que literalmente reemplazaba las verificaciones de <code class=\"language-text\">__DEV__</code> con <code class=\"language-text\">process.env.NODE_ENV !== &#39;production&#39;</code> justo antes de publicar.</p>\n<p>Esto era a veces un problema. A veces, un patrón de código que dependía de alguna convención de Node.js funcionaba bien en npm pero rompía Facebook, o viceversa.</p>\n<p>Desde React 16 cambiamos este enfoque. En su lugar, ahora <a href=\"https://reactjs.org/blog/2017/12/15/improving-the-repository-infrastructure.html#compiling-flat-bundles\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">compilamos un bundle</a> para cada entorno (incluyendo las etiquetas<code class=\"language-text\">&lt;script&gt;</code>, npm y el código interno de Facebook). Así que incluso código en CommonJS para npm es compilado para separar bundles de desarrollo y de producción antes de tiempo.</p>\n<p>Esto significa que mientras el código fuente de React dice <code class=\"language-text\">if (__DEV__)</code>, en realidad producimos dos bundles para cada paquete. Uno ya precompilado con <code class=\"language-text\">__DEV__ = true</code> y otro precompilado con <code class=\"language-text\">__DEV__ = false</code>. El punto de entrada para cada paquete en npm “decide” cuál exportar.</p>\n<p><a href=\"https://unpkg.com/browse/react@16.8.6/index.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Por ejemplo:</a></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">NODE_ENV</span> <span class=\"token operator\">===</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./cjs/react.production.min.js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./cjs/react.development.js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Y ese es el único lugar donde tu <em>bundler</em> interpolará <code class=\"language-text\">&#39;development&#39;</code> o <code class=\"language-text\">&#39;production&#39;</code> como un string, y donde tu minificador se deshacerá de ese <code class=\"language-text\">require</code> sólo para desarrollo.</p>\n<p>Tanto <code class=\"language-text\">react.production.min.js</code> como <code class=\"language-text\">react.development.js</code> ya no tienen verificaciones con <code class=\"language-text\">process.env.NODE_ENV</code>. Esto es muy bueno porque <em>cuando de hecho corremos en Node.js</em>, acceder a <code class=\"language-text\">process.env</code> es un <a href=\"https://reactjs.org/blog/2017/09/26/react-v16.0.html#better-server-side-rendering\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">poco lento</a>. Compilar los bundles en ambas formas antes de tiempo también nos deja optimizar el tamaño de archivo de forma <a href=\"https://reactjs.org/blog/2017/09/26/react-v16.0.html#reduced-file-size\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">mucho más consistente</a>, independientemente de qué <em>bundler</em> o <em>minificador</em> uses.</p>\n<p>¡Y así es como realmente funciona!</p>\n<hr>\n<p>Desearía que existiera una forma más <em>primera clase</em> de hacerlo sin dependender de convenciones, pero aquí estamos. Sería genial si los modos fueran un concepto de primera clase en todos los entornos de JavaScript y que hubiera una forma de que un navegador identifique que algún código está en modo desarrollo cuando no debe.</p>\n<p>Por otro lado, es fascinante ver cómo una convención en un único proyecto puede propagarse en todo el ecosistema. <code class=\"language-text\">EXPRESS_ENV</code> <a href=\"https://github.com/expressjs/express/commit/03b56d8140dc5c2b574d410bfeb63517a0430451\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">se convirtió en <code class=\"language-text\">NODE_ENV</code></a> en 2010 y <a href=\"https://github.com/hughsk/envify/commit/ae8aa26b759cd2115eccbed96f70e7bbdceded97\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">se propagó al front-end</a> en 2013. Quizás la solución no es perfecta, pero para cada proyecto el costo de adoptarla era más bajo que el costo de convencer a todos los demás que adopten algo diferente. Esto nos enseña una valiosa lección sobre la adopción de <a href=\"https://es.wikipedia.org/wiki/Top-down_y_bottom-up\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><em>top-down</em> versus <em>bottom-up</em></a>. Entender cómo esta dinámica funciona distingue entre intentos de estandarización exitosos y fracasos.</p>\n<p>Separar los modos de desarrollo y producción es una técnica muy útil. Recomiendo que la uses en tus librerías y en el código de aplicación para los tipos de chequeos que son demasiado costosos hacer en producción, pero son valiosos (¡y generalmente críticos!) de hacer en desarrollo.</p>\n<p>Como cualquier característica poderosa, hay formas en que puede utilizarse mal. ¡Este será el tema de mi próximo artículo!</p>","timeToRead":11,"frontmatter":{"title":"¿Cómo funciona el modo de desarrollo?","date":"August 04, 2019","spoiler":"Eliminación de código muerto por convención.","cta":null},"fields":{"slug":"/es/how-does-the-development-mode-work/","langKey":"es"}}},"pageContext":{"slug":"/es/how-does-the-development-mode-work/","translations":["zh-hans","es","pt-br","ko"],"translatedLinks":[]}}}
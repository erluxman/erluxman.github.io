{"componentChunkName":"component---src-templates-blog-post-js","path":"/it/why-do-we-write-super-props/","result":{"data":{"site":{"siteMetadata":{"title":"Overreacted","author":"Dan Abramov"}},"markdownRemark":{"id":"2725764c-0cb5-525f-9f22-e405c786765a","html":"<p>Ho sentito che gli <a href=\"https://reactjs.org/docs/hooks-intro.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Hooks</a> sono il nuovo trend. Ironicamente, voglio iniziare questo blog dallo spiegare alcuni fatti divertenti dei componenti scritti con le <em>classi</em>. Che ve ne pare?</p>\n<p><strong>Questi trucchi <em>non</em> sono importanti per usare React produttivamente. PerÃ² potreste trovarli interessanti se vi piace scoprire come funzionano le cose.</strong></p>\n<p>Ecco il primo.</p>\n<hr>\n<p>Ho scritto <code class=\"language-text\">super(props)</code> piÃ¹ volte nella mia vita di quante me ne piacerebbe sapere:</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Ovviamente, la proposta per i <a href=\"https://github.com/tc39/proposal-class-fields\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">class fields</a> ci permette di saltare la cerimonia:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Una sintassi cosÃ¬ Ã¨ stata <a href=\"https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#es7-property-initializers\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">pianificata</a> quando React 0.13 ha introdotto il supporto per le classi nel 2015. Definire il <code class=\"language-text\">constructor</code> e chiamare <code class=\"language-text\">super(props)</code> sono sempre state azioni pensate per essere una soluzione temporanea fin quando i <code class=\"language-text\">class fields</code> avrebbero fornito una soluzione piÃ¹ ergonomica.</p>\n<p>Torniamo allâ€™esempio che usa le classi ES2015:</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>PerchÃ© dobbiamo chiamare <code class=\"language-text\">super</code>? Possiamo <em>non</em> chiamarlo? Se lo dobbiamo chiamare, che cosa succede se non passiamo <code class=\"language-text\">props</code>? Ci sono altri argomenti?</strong> Scopriamolo.</p>\n<hr>\n<p>In JavaScript, <code class=\"language-text\">super</code> si riferisce al costruttore della classe genitore. (Nel nostro esempio, punta allâ€™implementazione della classe <code class=\"language-text\">React.Component</code>.)</p>\n<p>Da notare, non potete usare <code class=\"language-text\">this</code> in un costruttore se non <em>dopo</em> aver chiamato il costruttore genitore. JavaScript non ve lo permette:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ðŸ”´ Non si puÃ² ancora usare `this`</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// âœ… Ora si perÃ²</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Câ€™Ã¨ una buona ragione per la quale JavaScript forza il costruttore genitore a essere eseguito prima di toccare <code class=\"language-text\">this</code>. Considerate questa gerarchia di classi:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">PolitePerson</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">greetColleagues</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ðŸ”´ Non Ã¨ permesso, leggete sotto il perchÃ©</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">greetColleagues</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Buongiorno gente!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Immaginate che lâ€™uso di <code class=\"language-text\">this</code> prima che sia chiamato <code class=\"language-text\">super</code> <em>sia</em> permesso. Un mese dopo, potremmo cambiare <code class=\"language-text\">greetColleagues</code> per includere il nome della persona nel messaggio:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">  <span class=\"token function\">greetColleagues</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Buongiorno gente!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Il mio nome Ã¨ '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">+</span> <span class=\"token string\">', piacere di conoscerti!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>PerÃ² abbiamo dimenticato che <code class=\"language-text\">this.greetColleagues()</code> Ã¨ chiamato prima che la chiamata di <code class=\"language-text\">super()</code> abbia avuto la possibilitÃ  di impostare <code class=\"language-text\">this.name</code>. Quindi <code class=\"language-text\">this.name</code> non Ã¨ nemmeno definito! Come possiamo vedere, codice come questo Ã¨ difficile da comprendere.</p>\n<p>Per evitare queste insidie, <strong>JavaScript vi forza a chiamare <code class=\"language-text\">super</code> prima di utilizzare <code class=\"language-text\">this</code> in un costruttore.</strong> Lasciate che il genitore faccia quello che deve fare! Questa limitazione si applica anche ai componenti di React definiti con le classi:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// âœ… Adesso si puÃ² usare `this`</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>Questo ci lascia unâ€™altra domanda: perchÃ© passare <code class=\"language-text\">props</code>?</p>\n<hr>\n<p>Potremmo pensare che passare <code class=\"language-text\">props</code> a <code class=\"language-text\">super</code> sia necessario per fare in modo che il costruttore di <code class=\"language-text\">React.Component</code> inizializzi <code class=\"language-text\">this.props</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Dentro React</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>In effetti non Ã¨ molto lontano dalla realtÃ  â€” infatti Ã¨ <a href=\"https://github.com/facebook/react/blob/1d25aa5787d4e19704c049c3cfa985d3b5190e0d/packages/react/src/ReactBaseClasses.js#L22\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">quello che fa</a>.</p>\n<p>Ma per qualche ragione, anche se chiamassimo <code class=\"language-text\">super()</code> senza lâ€™argomento <code class=\"language-text\">props</code>, saremmo ancora in grado di accedere a <code class=\"language-text\">this.props</code> dentro <code class=\"language-text\">render</code> e altri metodi. (Se non mi credete, provate voistessi!)</p>\n<p>Come funziona <em>questa</em> cosa? Viene fuori che <strong>React assegna <code class=\"language-text\">props</code> allâ€™istanza subito dopo aver chiamato il <em>vostro</em> costruttore:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">  <span class=\"token comment\">// Dentro React</span>\n  <span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">YourComponent</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  instance<span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Quindi anche se vi dimenticate di passare <code class=\"language-text\">props</code> a <code class=\"language-text\">super()</code>, React lo avrebbe comunque impostato subito dopo. Câ€™Ã¨ una ragione per questo.</p>\n<p>Quando React ha aggiunto il supporto alle classi, non ha aggiunto il supporto solo per le classi ES6. Lâ€™obiettivo era di supportare la piÃ¹ vasta gamma di astrazioni di classe possibile. <a href=\"https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#other-languages\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Non era chiaro</a> quanto di successo sarebbero stati linguaggi come ClojureScript, CoffeeScript, ES6, Fable, Scala.js, TypeScript, o altre soluzioni per definire i componenti. Quindi React era intenzionalmente senza opinioni riguardo a se chiamare <code class=\"language-text\">super()</code> fosse richiesto o meno â€” anche se nelle classi ES6 lo Ã¨.</p>\n<p>Quindi questo vuol dire che possiamo scrivere <code class=\"language-text\">super()</code> invece di <code class=\"language-text\">super(props)</code>?</p>\n<p><strong>Pobabilmente no poichÃ© non Ã¨ ancora molto chiaro.</strong> Certo, React avrebbe comunque assegnato <code class=\"language-text\">this.props</code> <em>dopo</em> aver eseguito il vostro costruttore. Ma <code class=\"language-text\">this.props</code> sarebbe ancora indefinito <em>tra</em> la chiamata a <code class=\"language-text\">super</code> e la fine del costruttore:</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Dentro React</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Nel vostro codice</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Button</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ðŸ˜¬ Abbiamo dimenticato di passare props</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">// âœ… {}</span>\n<span class=\"gatsby-highlight-code-line\">    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ðŸ˜¬ undefined </span></span>  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Il debug puÃ² essere ancora piÃ¹ impegnativo se questo succede in qualche metodo che viene richiamato <em>dal</em> costruttore. <strong>Ed Ã¨ per questo che raccomando di chiamare sempre <code class=\"language-text\">super(props)</code>, anche se non Ã¨ strettamente necessario:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Button</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// âœ… Abbiamo passato props</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">// âœ… {}</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// âœ… {}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Questo assicura che <code class=\"language-text\">this.props</code> sia impostato anche prima che il costruttore esca.</p>\n<hr>\n<p>Câ€™Ã¨ unâ€™altra cosa di cui gli utenti che usano React da tanto tempo potrebbero essere curiosi di sapere.</p>\n<p>Potreste aver notato che quando usiamo le Context API nelle classi (con il vecchio <code class=\"language-text\">contextTypes</code> o con la nuova API <code class=\"language-text\">contextType</code> introdotta in React 16.6), <code class=\"language-text\">context</code> Ã¨ passato come secondo argomento al costruttore.</p>\n<p>Quindi perchÃ© non scriviamo <code class=\"language-text\">super(props, context)</code>? Potremmo, ma il context Ã¨ usato meno spesso delle props, quindi questo problema viene fuori di rado.</p>\n<p><strong>Con la proposta dei class fields queste problematiche per lo piÃ¹ non si presentano.</strong> Senza una chiamata esplicita al costruttore, tutti gli argomenti sono comunque passati automaticamente. Ãˆ per questo che espressioni come <code class=\"language-text\">state = {}</code> permettono lâ€™inclusione di referenze <code class=\"language-text\">this.props</code> o <code class=\"language-text\">this.context</code> se necessario.</p>\n<p>Con gli Hooks, non abbiamo nemmeno <code class=\"language-text\">super</code> o <code class=\"language-text\">this</code>. Ma questo Ã¨ un argomento per unâ€™altra volta.</p>","timeToRead":5,"frontmatter":{"title":"PerchÃ© scriviamo super(props)?","date":"November 30, 2018","spoiler":"C'Ã¨ un twist alla fine.","cta":null},"fields":{"slug":"/it/why-do-we-write-super-props/","langKey":"it"}}},"pageContext":{"slug":"/it/why-do-we-write-super-props/","translations":["cs","de","es","fa","fr","hu","it","my","ja","nl","nb","pl","pt-br","sk","sr","th","tr","uk","vi","zh-hans","zh-hant"],"translatedLinks":[]}}}
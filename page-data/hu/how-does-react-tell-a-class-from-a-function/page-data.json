{"componentChunkName":"component---src-templates-blog-post-js","path":"/hu/how-does-react-tell-a-class-from-a-function/","result":{"data":{"site":{"siteMetadata":{"title":"Overreacted","author":"Dan Abramov"}},"markdownRemark":{"id":"b8a76296-3f7d-595c-989d-8ffcfe31789b","html":"<p>Vegyük ezt a <code class=\"language-text\">Greeting</code> komponenst, ami függvényként van definiálva:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>React-ben ugyanezt osztályként is definiálhatjuk</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Greeting</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>(Egészen <a href=\"https://reactjs.org/docs/hooks-intro.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">mostanáig</a> ez volt az egyetlen módja, hogy éljünk az állapot (state) által nyújtott lehetőségekkel.</p>\n<p>Amikor renderelni akarjuk a <code class=\"language-text\">&lt;Greeting /&gt;</code> komponenst, nem számít hogyan volt definiálva:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Osztály vagy függvény - tökmindegy.</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Greeting</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n<p>De a <em>React-nek</em> igenis fontos ez a különbség!</p>\n<p>Ha a <code class=\"language-text\">Greeting</code> egy függvény, akkor a React-nek meg kell hívnia:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Saját kód</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// React kód</span>\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &lt;p>Hello&lt;/p></span></code></pre></div>\n<p>De ha a <code class=\"language-text\">Greeting</code> egy osztály, akkor a React-nek először létre kell hoznia egy példányt a <code class=\"language-text\">new</code> operátorral és csak <em>ez után</em> hívja meg a <code class=\"language-text\">render</code> metódust az imént létrehozott példányon. </p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Saját kód</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Greeting</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// React kód</span>\n<span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Greeting {}</span>\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> instance<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &lt;p>Hello&lt;/p></span></code></pre></div>\n<p>A React célja mindkét esetben az, hogy megkapja a renderelt elemet (a példánkban <code class=\"language-text\">&lt;p&gt;Hello&lt;/p&gt;</code>). De ennek a folyamatnak a lépései attől függenek, hogyan volt a <code class=\"language-text\">Greeting</code> definiálva.</p>\n<p><strong>Hogyan tudja tehát a React, hogy egy komponens osztály vagy függvény?</strong></p>\n<p>Az <a href=\"/why-do-we-write-super-props/\">előző poszthoz</a> hasonlóan, <strong>nem <em>kell</em> mindezt tudni, ahhoz hogy hatékonyan használjuk a React-et.</strong> Én sem tudtam évekig. Kérek mindenkit, hogy ne csináljunk ebből egy intejú kérdést. Valójában ez a poszt inkább szól a JavaScript-ről mint a React-ről.</p>\n<p>Ez a blog azoknak az érdeklődő olvasóknak szól, akik tudni akarják <em>miért</em> működik a React úgy ahogy. Magadra ismertél? Akkor ugorjunk neki együtt.</p>\n<p><strong>Hosszú lesz az út, öveket becsatolni! Ez a poszt nem a tartalmaz sok információt magáról a React-ről, de át fogjuk venni a <code class=\"language-text\">new</code>, <code class=\"language-text\">this</code>, <code class=\"language-text\">class</code>, nyíl operátoros függvények, <code class=\"language-text\">prototype</code>, <code class=\"language-text\">__proto__</code>, <code class=\"language-text\">instanceof</code> néhány tulajdonságát és hogy ezek hogyan függenek össze JavaScript-ben. Szerencsére ezeken nem kell túl sokat gondolkodni a React <em>használata</em> közben. Viszont ha te implementálod a React-et…</strong></p>\n<p>(Ha csak a válaszra vagy kíváncsi, görgess a legvégére.)</p>\n<hr>\n<p>Először is azt kell megértenünk, miért fontos a függvényeket és az osztályokat külön kezelnünk. Figyeljük meg hogyan használjuk a <code class=\"language-text\">new</code> operátort egy osztály létrehozásakor:</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Ha a Greeting egy függvény</span>\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &lt;p>Hello&lt;/p></span>\n<span class=\"token comment\">// Ha a Greeting egy osztály</span>\n<span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Greeting {}</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> instance<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &lt;p>Hello&lt;/p></span></span></code></pre></div>\n<p>Nézzük meg, hogy nagyjából mit csinál a <code class=\"language-text\">new</code> operátor JavaScript-ben.</p>\n<hr>\n<p>A múltban nem voltak osztályok a JavaScript-ben. Azonban egyszerű függvények segíségével ki lehetett fejezni hasonló kódolási mintákat. <strong>Konkrétan <em>akármilyen</em> függvényt lehet egy osztály konstruktorhoz hasonló szerepkörben használni, mindössze a <code class=\"language-text\">new</code> operátorral kell meghívni:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Egy egyszerű függvény</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ Person {name: 'Fred'}</span>\n<span class=\"token keyword\">var</span> george <span class=\"token operator\">=</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'George'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 🔴 Nem fog működni</span></code></pre></div>\n<p>Ez a kód még ma is érvényes! Próbáld ki DevTools-ban.</p>\n<p>Ha <code class=\"language-text\">new</code> és <code class=\"language-text\">this</code> <strong>nélkül</strong> deklarálnánk és hívnánk meg, akkor a <code class=\"language-text\">Person(&#39;Fred&#39;)</code> valami globális és hasznavehetetlen (mint például a <code class=\"language-text\">window</code> vagy <code class=\"language-text\">undefined</code>) dologra mutatna. A kódunk tehát hibát jelezne vagy váratlanul megváltoztatná a <code class=\"language-text\">window.name</code> értékét.</p>\n<p>A <code class=\"language-text\">new</code> operátort egy függvény meghívása elé rakva azt fejezzük ki, hogy: “Figyelj JavaScript, tudom hogy a <code class=\"language-text\">Person</code> csak egy függvény, de tegyünk úgy mintha egy osztály konstruktor lenne. <strong>Hozz létre egy <code class=\"language-text\">{}</code> objektumot és a <code class=\"language-text\">Person</code> függvényen belül lévő <code class=\"language-text\">this</code> mutasson erre az objektumra, hogy hozzá tudjak rendelni olyan dolgokat, mint a <code class=\"language-text\">this.name</code>. Aztán térj vissza ezzel az objektummal.</strong> ”</p>\n<p>Ezt csinálja a <code class=\"language-text\">new</code> operátor.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">var</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// A `Person`-ban lévő `this` erre az objektumra utal</span></code></pre></div>\n<p>A <code class=\"language-text\">new</code> operátor azt is lehetővé teszi, hogy minden amit a <code class=\"language-text\">Person.prototype</code>-on definiálunk az a <code class=\"language-text\">fred</code> objektum számára is elérhető lesz:</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token class-name\">Person</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">sayHi</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span></span><span class=\"gatsby-highlight-code-line\">  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hi, I am '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\"><span class=\"token punctuation\">}</span></span><span class=\"token keyword\">var</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nfred<span class=\"token punctuation\">.</span><span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Így lehetett osztályokat imitálni mielőtt azok megjelentek volna JavaScript-ben.</p>\n<hr>\n<p>A <code class=\"language-text\">new</code> operátor tehát nem egy újdonság JavaScript-ben. Az osztályok azonban újabb keletűek. A segítségükkel sokkal kifejezőbbé tudjuk tenni a korábbi kódunkat:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hi, I am '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">let</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nfred<span class=\"token punctuation\">.</span><span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><em>A fejlesztő szándékának megőrzése</em> fontos egy programnyelv vagy egy API tervezésekor.</p>\n<p>Ha írunk egy függvényt, a JavaScript nem tudja magától kitalálni, hogy azt úgy kell meghívnia, mint mondjuk az <code class=\"language-text\">alert()</code>-et vagy konstruktorként, mint a <code class=\"language-text\">new Person()</code> esetében. Egy olyan függvény esetében, mint a <code class=\"language-text\">Person</code>, a <code class=\"language-text\">new</code> elhagyása zavaros következményekkel jár.</p>\n<p><strong>Az osztály szintaxissal ki tudjuk fejezni, hogy: “Ez nem csak egy függvény - ez egy osztály és tartozik hozzá egy konstruktor”.</strong> Ha lefelejtjük a <code class=\"language-text\">new</code>-t ennek a meghívásakor, a JavaScript hibát fog jelezni:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ✅  Ha a Person egy függvény: semmi gond</span>\n<span class=\"token comment\">// ✅  Ha a Person egy osztály: szintén semmi gond</span>\n<span class=\"token keyword\">let</span> george <span class=\"token operator\">=</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'George'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Hiányzó `new`</span>\n<span class=\"token comment\">// 😳 Ha a Person egy konstruktor-szerű függvény: zavaros viselkedés</span>\n<span class=\"token comment\">// 🔴 Ha a Person egy osztály: azonnali hibaüzenet</span></code></pre></div>\n<p>A hibákat ezáltal könnyebb korán észrevenni, semmint várni hogy bekövetkezzen valami rejtélyes bug, például hogy a <code class=\"language-text\">this.name</code> a <code class=\"language-text\">george.name</code> helyett a <code class=\"language-text\">window.name</code>-et állítja be.</p>\n<p>Ám ez azzal is jár, hogy a React-nak minden egyes osztály meghívása elé oda kell tennie a <code class=\"language-text\">new</code> operátort. Nem hívhatja meg azokat egyszerű függvényként, mert a JavaScript hibát jelezne!</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Counter</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// 🔴 A React nem hívhatja meg így</span>\n<span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> <span class=\"token function\">Counter</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Ebből még baj lehet.</p>\n<hr>\n<p>Mielőtt látnánk hogyan oldja meg a React ezt a problémát, jusson eszünkbe, hogy a legtöbb React felhasználó valamilyen fordítóprogramot használ - mint például a Babel - hogy az osztályokat és a többi modern funkciókat lefordítsák a régebbi böngészők számára. A tervezéskor tehát ezeket a fordítóprogramokat is figyelembe kell vennünk.</p>\n<p>A Babel korai verzióiban az osztályokat meg lehetett hívni <code class=\"language-text\">new</code> nélkül is. Ez azonban ki lett javítva - egy kis extra kód hozzáadásával:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Leegyszerűsített Babel kód:</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TypeError</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Cannot call a class as a function\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// Saját kód:</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ Oké</span>\n<span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'George'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 🔴 Nem lehet az osztályt függvényként meghívni</span></code></pre></div>\n<p>Hasonló kóddal már találkozhattál a bundle-ödben. Erre való az a sok <code class=\"language-text\">_classCallCheck</code> függvény. (A bundle mérete csökkenthető ha az ilyen ellenőrzéseket nélkülöző “loose mode”-ot választjuk, de ez megnehezítheti a valós natív osztályokra való jövőbeli átállást.) </p>\n<hr>\n<p>Most már tehát nagyjából értjük, hogy mi a különbség ha <code class=\"language-text\">new</code>-val vagy anélkül hívunk meg valamit:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th><code class=\"language-text\">new Person()</code></th>\n<th><code class=\"language-text\">Person()</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">class</code></td>\n<td>✅ A <code class=\"language-text\">this</code> egy <code class=\"language-text\">Person</code> példányra mutat</td>\n<td>🔴 <code class=\"language-text\">TypeError</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">function</code></td>\n<td>✅ A <code class=\"language-text\">this</code> egy <code class=\"language-text\">Person</code> példányra mutat</td>\n<td>😳 A <code class=\"language-text\">this</code> vagy a <code class=\"language-text\">window</code>-ra mutat vagy <code class=\"language-text\">undefined</code></td>\n</tr>\n</tbody>\n</table>\n<p>Ezért fontos, hogy a React helyesen hívja meg a komponenseket. <strong>Ha a komponens osztályként van definiálva a React-nak a <code class=\"language-text\">new</code> operátorral kell meghívnia.</strong></p>\n<p>Akkor a React csupán ellenőrzi, hogy egy osztályról van szó vagy sem?</p>\n<p>Ne olyan hevesen! Még ha <a href=\"https://stackoverflow.com/questions/29093396/how-do-you-check-the-difference-between-an-ecmascript-6-class-and-function\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">meg is tudnánk különböztetni egy osztályt egy függvénytől JavaScript-ben</a>, a Babel és a hozzá hasonló eszközök által fordított osztályok esetében ez akkor sem működne. A böngésző szemében ezek mindössze sima függvények. Nagy pech a React számára.</p>\n<hr>\n<p>Oké, akkor a React nem tehetné oda <code class=\"language-text\">new</code> kulcsszót minden egyes meghívás elé? Sajnos ez sem működne.</p>\n<p>Ha a szokásos függvényeket a <code class=\"language-text\">new</code>-val hívjuk meg, akkor egy objektum példány társul hozzájuk, amire a <code class=\"language-text\">this</code> mutat. Ez kívánatos a konstruktor függvényeknél (mint például a korábbi <code class=\"language-text\">Person</code>), de zavaró a függvény komponensek esetében:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Nem várjuk el, hogy a `this` akármire mutasson</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Ez még akár elviselhető is lenne. Van viszont két <em>másik</em> oka annak, hogy ez az ötlet nem működik.</p>\n<hr>\n<p>Az első ok, amiért nem használhatjuk minden esetben a <code class=\"language-text\">new</code>-t az az, hogy ha a natív (és nem a Babel által lefordított) nyíl operátoros függvényeket a <code class=\"language-text\">new</code> kulcsszóval hívjuk meg, akkor hibaüzenetet kapunk:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Greeting</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 🔴 A Greeting nem egy konstruktor</span></code></pre></div>\n<p>Ez a viselkedés szándékos és a nyíl operátoros függvények dizájnjából ered. A nyíl operátoros függvények egyik előnye ugyanis az, hogy <em>nem</em> rendelkeznek saját <code class=\"language-text\">this</code> értékkel - ehelyett a <code class=\"language-text\">this</code>-t a legközelebbi szabályos függvénytől veszik át:</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Friends</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span></span>    <span class=\"token keyword\">const</span> friends <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>friends<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> friends<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">friend</span> <span class=\"token operator\">=></span>\n      <span class=\"token operator\">&lt;</span>Friend\n<span class=\"gatsby-highlight-code-line\">        <span class=\"token comment\">// `A `this` a `render` metódustól származik</span></span><span class=\"gatsby-highlight-code-line\">        size<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">}</span></span>        name<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>friend<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span>\n        key<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>friend<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">}</span>\n      <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Oké, szóval a <strong>nyíl operátoros függvények nem rendelkeznek saját <code class=\"language-text\">this</code>-szel.</strong> Viszont ez azt jelenti, hogy teljesen használhatatlanok konstruktorként!</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Person</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 🔴 Ennek nincs értelme!</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Emiatt a <strong>JavaScript nem engedélyezi, hogy a nyíl operátoros függvényeket a <code class=\"language-text\">new</code> kulcsszóval hívjuk meg.</strong> Ha mégis így teszünk, az valószínűleg nem volt szándékos és jobb is, ha minél hamarabb tudomást szerzünk róla. Hasonló okokból kifolyólag nem engedi a JavaScript az osztályok meghívását a <code class=\"language-text\">new</code> operátor <em>nélkül</em>.</p>\n<p>Ez így oké, viszont ez keresztülhúzza a számításainkat. A React nem hívhat meg mindent a <code class=\"language-text\">new</code> kulcsszóval, mert a nyíl operátoros függvények esetében ez nem működne! A <code class=\"language-text\">new</code>-val való meghívás helyett megpróbálhatnánk kiszűrni a nyíl operátoros függvényeket azáltal, hogy nekik nincs <code class=\"language-text\">prototype</code> mezőjük:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>prototype <span class=\"token comment\">// undefined</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>prototype <span class=\"token comment\">// {constructor: f}</span></code></pre></div>\n<p>De ez <a href=\"https://github.com/facebook/react/issues/4599#issuecomment-136562930\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">nem működne</a> a Babel által fordított függvények esetében. Ez nem biztos, hogy olyan nagy ügy, van viszont egy másik ok, ami miatt ez a megközelítés egy zsákutca.</p>\n<hr>\n<p>A másik ok amiért nem használhatjuk folyton a <code class=\"language-text\">new</code> kulcsszót az az, hogy ez megakadályozná a React-et abban, hogy támogassa azokat a komponenseket, amik string-ekkel vagy más primitív típusokkal térnek vissza. </p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">'Hello'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ 'Hello'</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 😳 Greeting {}</span></code></pre></div>\n<p>Ez megint csak a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">new</code> operátor</a> különös koncepciójából ered. Ahogy azt láttuk korábban a <code class=\"language-text\">new</code> arra utasítja a JavaScript-et, hogy hozzon létre egy objektumot, a függvényen belül a <code class=\"language-text\">this</code> mutasson erre az objektumra, végül pedig kapjuk meg ezt az objektumot a <code class=\"language-text\">new</code> eredményeként.</p>\n<p>Azonban a JavaScript azt is megengedi, hogy egy <code class=\"language-text\">new</code> operátorral meghívott függvény <em>felülírja</em> a <code class=\"language-text\">new</code> visszatérési értékét azáltal, hogy valami más objektummal tér vissza. Feltehetőleg ezt hasznosnak tekintették az olyan esetekben, amikor a példányok újrafelhasználásával összevontabb kódot szeretnénk írni:</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"gatsby-highlight-code-line\"><span class=\"token comment\">// Szabadon definiálva</span></span><span class=\"gatsby-highlight-code-line\"><span class=\"token keyword\">var</span> zeroVector <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></span><span class=\"token keyword\">function</span> <span class=\"token function\">Vector</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">,</span> y</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">===</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> y <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>zeroVector <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// Újrahasznosítva ugyanazt a példányt</span>\n<span class=\"gatsby-highlight-code-line\">      <span class=\"token keyword\">return</span> zeroVector<span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token punctuation\">}</span></span>    zeroVector <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>x <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>y <span class=\"token operator\">=</span> y<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vector</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vector</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> c <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vector</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 😲 b === c</span></code></pre></div>\n<p>Azonban a <code class=\"language-text\">new</code> <em>teljesen figyelmen kívűl hagyja</em> egy függvény visszatérési értékét abban az esetben, amikor az <em>nem</em> egy objektum. Ha egy string vagy egy szám a visszatérési érték az olyan, mintha nem is volna <code class=\"language-text\">return</code> a függvényben. </p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Answer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">Answer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ 42</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Answer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 😳 Answer {}</span></code></pre></div>\n<p>Egyszerűen nincs rá mód, hogy olvassuk a primitív visszatérési értékeket (mint például string vagy szám) ha a függvény a <code class=\"language-text\">new</code> kulcsszóval került meghívásra. Tehát ha a React mindig a <code class=\"language-text\">new</code>-t használná képtelen lenne azokat a komponenseket támogatni, amelyek egy string-et eredményeznek!</p>\n<p>Mivel ez elfogadhatatlan szükségünk van egy kompromisszumra.</p>\n<hr>\n<p>Mit is tudunk eddig? A React-nek az osztályokat (beleértve a Babel outputot) a <code class=\"language-text\">new</code>-val <em>együtt</em>, a normál és a nyíl operátoros függvényeket (beleértve a Babel outputot) viszont a <code class=\"language-text\">new</code> <em>nélkül</em> kell meghívnia. Ezeket viszont nem lehet megbízható módon megkülönböztetni.</p>\n<p><strong>Ha nem tudjuk ezt az általános problémát megoldani, egy specifikusabbat meg tudnánk?</strong></p>\n<p>Amikor egy komponenst osztályként definiálunk a legtöbbször a <code class=\"language-text\">React.Component</code> osztályt szeretnénk bővíteni, hogy hozzáférjünk olyan beépített metódusokhoz, mint például a <code class=\"language-text\">this.setState()</code>. <strong>Ahelyett, hogy megpróbálnánk azonosítani az összes osztályt, nem tudnánk csak a <code class=\"language-text\">React.Component</code> utódosztályait kiszűrni?</strong></p>\n<p>Spoiler: a React pontosan ezt csinálja.</p>\n<hr>\n<p>Talán a helyes módszer, hogy megállapítsuk a <code class=\"language-text\">Greeting</code> komponensről hogy egy React osztály-e az, hogy megvizsgáljuk a <code class=\"language-text\">Greeting.prototype instanceof React.Component</code> igazságértékét:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">B</span><span class=\"token punctuation\">.</span>prototype <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span></code></pre></div>\n<p>Tudom mire gondoltok. Mi folyik itt? Hogy ezt megválaszoljuk, meg kell értenünk a JavaScript prototípusokat. </p>\n<p>Talán ismerős lehet a “prototípus lánc”. Minden JavaScript objektum rendelkezhet egy “prototípussal”. Amikor azt írjuk, hogy <code class=\"language-text\">fred.sayHi()</code>, viszont a <code class=\"language-text\">fred</code> objektum közvetlenül nem rendelkezik ezzel a metódussal, akkor szétnézünk <code class=\"language-text\">fred</code> prototípusában, hátha ott van a <code class=\"language-text\">sayHi</code> definiálva.  Ha ott sem találjuk, akkor továbbmegyünk a láncban következő prototípusra - <code class=\"language-text\">fred</code> prototípusának a prototípusára. És így tovább.</p>\n<p><strong>Zavaró módon egy osztály vagy egy függvény <code class=\"language-text\">prototype</code> mezője <em>nem</em> az adott elem prototípusára mutat.</strong> Nem viccelek.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Person</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 🤪 Nem a Person prototípusa</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Person<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 😳 A Person prototípusa</span></code></pre></div>\n<p>A “prototípus lánc” tehát inkább úgy néz ki, hogy <code class=\"language-text\">__proto__.__proto__.__proto__</code> semmint hogy <code class=\"language-text\">prototype.prototype.prototype</code>. Évekbe tartott hogy ezt megértsem.</p>\n<p>Akkor visztont mire mutat a <code class=\"language-text\">prototype</code> mező egy függvény vagy osztály esetében? <strong>Hát a <code class=\"language-text\">__proto__</code>-ra, amivel minden olyan objektum rendelkezik, ami egy függvénytől vagy egy osztálytól származik és a <code class=\"language-text\">new</code> operátorral került meghívásra!</strong></p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">Person</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">sayHi</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hi, I am '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// A `fred.__proto__` immár a `Person.prototype`-ra mutat</span></code></pre></div>\n<p>A JavaScript tehát ezt a <code class=\"language-text\">__proto__</code> láncot használja a változók megkeresésére:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">fred<span class=\"token punctuation\">.</span><span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 1. fred rendelkezik saját sayHi metódussal? Nem.</span>\n<span class=\"token comment\">// 2. fred.__proto__ rendelkezik saját sayHi metódussal? Igen. Hívjuk meg!</span>\nfred<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 1. fred rendelkezik saját toString metódussal? Nem.</span>\n<span class=\"token comment\">// 2. fred.__proto__ rendelkezik saját toString metódussal? Nem.</span>\n<span class=\"token comment\">// 3. fred.__proto__.__proto__ rendelkezik saját toString metódussal? Igen. Hívjuk meg!</span></code></pre></div>\n<p>A gyakorlatban szinte sosem kell a <code class=\"language-text\">__proto__</code>-hoz közvetlenül hozzányúlnunk, kivéve ha a prototípus lánchoz köthető hibát keresünk. Ha azt szeretnénk, hogy a <code class=\"language-text\">fred.__proto__</code>-nak legyen hozzáférése valamihez, azt a <code class=\"language-text\">Person.prototype</code>-on kell beállítanunk. Legalábbis eredetileg így kellett.</p>\n<p>A böngészők eredetileg nem is férhettek volna hozzá a <code class=\"language-text\">__proto__</code> mezőhöz, mivel a prototípus láncot egy belső koncepciónak szánták. De néhány böngésző mégis hozzáfért, így a <code class=\"language-text\">__proto__</code> akaratlanul, de mégis standarddá vált (viszont mára elevult és a <code class=\"language-text\">Object.getPrototypeOf()</code> vette át a helyét).</p>\n<p><strong>Akárhogy is, én még mindig nagyon furcsának találom, hogy egy mező amit <code class=\"language-text\">prototype</code>-nak hívnak nem az adott érték prototípusra utal</strong> (például a <code class=\"language-text\">fred.prototype</code> nincs definiálva, mert a <code class=\"language-text\">fred</code> nem egy függvény). Személy szerint én azt gondolom, hogy ez fő oka annak, hogy még a tapasztalt fejlesztők is gyakran félreértik a JavaScript prototípusokat.</p>\n<hr>\n<p>Hosszú egy poszt, mi? Körülbelül 80%-nál tartunk. Kitartás.</p>\n<p>Tudjuk tehát, hogy amikor azt írjuk, hogy <code class=\"language-text\">obj.foo</code>, akkor a JavaScript valójában megnézi, hogy a <code class=\"language-text\">foo</code> definiálva van-e az <code class=\"language-text\">obj</code>-en, <code class=\"language-text\">obj.__proto__</code>-n, <code class=\"language-text\">obj.__proto__.__proto__</code>-n és így tovább.</p>\n<p>Az osztályok esetében ennek a mechanizmusnak nem vagyunk közvetlenül kitéve, de az <code class=\"language-text\">extends</code> ugyanúgy működik a jó öreg prototípus láncon is. Így férnek hozzá a React osztályaink olyan metódusokhoz, mint a <code class=\"language-text\">setState</code>:</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"gatsby-highlight-code-line\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Greeting</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span></span>  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">let</span> c <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Greeting.prototype</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// React.Component.prototype</span>\n<span class=\"gatsby-highlight-code-line\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Object.prototype</span></span>c<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">// Megtalálva a c.__proto__ -n (Greeting.prototype)</span>\nc<span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// Megtalálva a c.__proto__.__proto__ -n (React.Component.prototype)</span>\nc<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// Megtalálva a c.__proto__.__proto__.__proto__ -n (Object.prototype)</span></code></pre></div>\n<p>Más szavakkal, <strong>amikor osztályokat használunk, egy példány <code class=\"language-text\">__proto__</code> lánca “tükrözi” az oszály hierarchiát:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// `extends` lánc</span>\nGreeting\n  → React<span class=\"token punctuation\">.</span>Component\n    → <span class=\"token function\">Object</span> <span class=\"token punctuation\">(</span>implicit módon<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// `__proto__` lánc</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  → <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">.</span>prototype\n    → React<span class=\"token punctuation\">.</span><span class=\"token class-name\">Component</span><span class=\"token punctuation\">.</span>prototype\n      → <span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype</code></pre></div>\n<p>2 Chainz.</p>\n<hr>\n<p>Mivel a <code class=\"language-text\">__proto__</code> letükrözi az osztály hierarchiát, megnézhetjük, hogy a <code class=\"language-text\">Greeting</code> a <code class=\"language-text\">React.Component</code> bővítménye-e, kezdve a <code class=\"language-text\">Greeting.prototype</code>-nál majd tovább követve a <code class=\"language-text\">__proto__</code> láncot:</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// `__proto__` lánc</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"gatsby-highlight-code-line\">  → <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">.</span>prototype <span class=\"token comment\">// 🕵️ Itt kezdünk</span></span><span class=\"gatsby-highlight-code-line\">    → React<span class=\"token punctuation\">.</span><span class=\"token class-name\">Component</span><span class=\"token punctuation\">.</span>prototype <span class=\"token comment\">// ✅ Megvan!</span></span>      → <span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype</code></pre></div>\n<p>Szerencsére az <code class=\"language-text\">x instanceof Y</code> pontosan ezt a fajta keresést hajtja végre. Ez az <code class=\"language-text\">x.__proto__</code> láncot követve kutat az <code class=\"language-text\">Y.prototype</code> után.</p>\n<p>Ezt normális esetben arra használjuk, hogy megmondjuk valamiről hogy egy osztály példánya-e:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> greeting <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>greeting <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n<span class=\"token comment\">// greeting (🕵️‍ Itt kezdünk)</span>\n<span class=\"token comment\">//   .__proto__ → Greeting.prototype (✅ Megvan!)</span>\n<span class=\"token comment\">//     .__proto__ → React.Component.prototype </span>\n<span class=\"token comment\">//       .__proto__ → Object.prototype</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>greeting <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n<span class=\"token comment\">// greeting (🕵️‍ Itt kezdünk)</span>\n<span class=\"token comment\">//   .__proto__ → Greeting.prototype</span>\n<span class=\"token comment\">//     .__proto__ → React.Component.prototype (✅ Megvan!)</span>\n<span class=\"token comment\">//       .__proto__ → Object.prototype</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>greeting <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n<span class=\"token comment\">// greeting (🕵️‍ Itt kezdünk)</span>\n<span class=\"token comment\">//   .__proto__ → Greeting.prototype</span>\n<span class=\"token comment\">//     .__proto__ → React.Component.prototype</span>\n<span class=\"token comment\">//       .__proto__ → Object.prototype (✅ Megvan!)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>greeting <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Banana</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\n<span class=\"token comment\">// greeting (🕵️‍ Itt kezdünk)</span>\n<span class=\"token comment\">//   .__proto__ → Greeting.prototype</span>\n<span class=\"token comment\">//     .__proto__ → React.Component.prototype </span>\n<span class=\"token comment\">//       .__proto__ → Object.prototype (🙅‍ Nem találtuk sehol!)</span></code></pre></div>\n<p>De ugyanúgy működne, ha azt akarnánk meghatározni, hogy egy osztály egy másik osztály bővítménye-e:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">.</span>prototype <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// greeting</span>\n<span class=\"token comment\">//   .__proto__ → Greeting.prototype (🕵️‍ Itt kezdünk)</span>\n<span class=\"token comment\">//     .__proto__ → React.Component.prototype (✅ Megvan!)</span>\n<span class=\"token comment\">//       .__proto__ → Object.prototype</span></code></pre></div>\n<p>Ez az a módszer, amivel meg tudjuk határozni, hogy valami egy React komponens osztály vagy pedig egy szokványos függvény.</p>\n<hr>\n<p>A React azonban nem így csinálja. 😳</p>\n<p>Ezt az <code class=\"language-text\">instanceof</code>-ot használó megoldás egyik ellentmondásossága, hogy nem működik ha a React több példánya is jelen van az oldalon és az a komponens amit éppen ellenőrzünk egy <em>másik</em> React példány <code class=\"language-text\">React.Component</code>-jétől örököl. Többfajta React példány ötvözése egy projekten belül sok okból kifolyólag sem jó ötlet, de a múltban megpróbáltuk elkerülni az ezzel járó problémákat, ha lehetséges volt. (A Hooks-szal azonban, <a href=\"https://github.com/facebook/react/issues/13991\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">lehet hogy muszáj</a> lesz megszabadulnunk a duplikácikótól.)</p>\n<p>Egy másik lehetséges heurisztika, ha ellenőriznénk, hogy a <code class=\"language-text\">render</code> metódus definiálva van-e a prototípuson. Azonban régebben <a href=\"https://github.com/facebook/react/issues/4599#issuecomment-129714112\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">nem volt tiszta</a>, hogy a komponens API hogyan fog fejlődni. Minden ellenőrzésnek van egy ára, így nem akartunk egynél többet elvégezni. Ez akkor sem működne ha a <code class=\"language-text\">render</code> egy példány metódusként lenne definiálva, az osztály attribútumok szintaxisához hasonlóan.</p>\n<p>Ellenben a React inkább egy speciális flag-et <a href=\"https://github.com/facebook/react/pull/4663\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">rendelt</a> a bázis komponenshez. A React ellenőrzi, hogy megvan-e ez a flag, és innen tudja, hogy valami egy React komponens-e vagy sem.</p>\n<p>Eredetileg ez a flag a bázis <code class=\"language-text\">React.Component</code> osztályon magán volt:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Inside React</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nComponent<span class=\"token punctuation\">.</span>isReactClass <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Ellenőrizhetjük így</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Greeting</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Greeting<span class=\"token punctuation\">.</span>isReactClass<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ Igen</span></code></pre></div>\n<p>Ám néhány konkrét osztály implementáció <a href=\"https://github.com/scala-js/scala-js/issues/1900\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">nem</a> tartalmazott másolatokat a statikus tulajdonságokról (vagy maga módosította a <code class=\"language-text\">__proto__</code>-t, ami nem volt a standard része), így ez a flag elveszett.</p>\n<p>A React ezért <a href=\"https://github.com/facebook/react/pull/5021\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">rakta át</a> ezt a flag-et inkább a <code class=\"language-text\">React.Component.prototype</code>-ra:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// React kód</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">Component</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>isReactComponent <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Így tudjuk ellenőrizni</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Greeting</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>isReactComponent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ Igen</span></code></pre></div>\n<p><strong>És lényegében ez minden.</strong></p>\n<p>Felmerülhet a kérdés, hogy ez miért egy objektum egy egyszerű boolean helyett. A gyakorlatban nem számít sokat, de a Jest korábbi verzióiban (mielőtt a Jest jó lett™️) az automocking alapból be volt kapcsolva. Ezek a generált teszt objektumok (mock-ok) nélkülöztek minden primitív adatmezőt, <a href=\"https://github.com/facebook/react/pull/4663#issuecomment-136533373\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">lehetetlenné téve az ellenőrzést</a>. Köszi Jest.</p>\n<p>Az <code class=\"language-text\">isReactComponent</code> ellenőrzése mindmáig <a href=\"https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/react-reconciler/src/ReactFiber.js#L297-L300\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">a React része.</a></p>\n<p>Ha nem a <code class=\"language-text\">React.Component</code>-et bővítjük, akkor a React nem fogja megtalálni az <code class=\"language-text\">isReactComponent</code>-et a prototípuson és ezért nem is fogja osztályként kezelni. Most már tudjuk hogy a <code class=\"language-text\">Cannot call a class as a function</code> hibaüzenetre a <a href=\"https://stackoverflow.com/a/42680526/458193\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">legtöbb szavazatot kapó válasz</a> miért az, hogy adjuk hozzá a komponenshez az <code class=\"language-text\">extends React.Component</code>-et. Végezetül van egy <a href=\"https://github.com/facebook/react/pull/11168\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">figyelmeztetés is</a>, ami jelzi ha a <code class=\"language-text\">prototype.render</code> létezik, de a <code class=\"language-text\">prototype.isReactComponent</code> nem.</p>\n<hr>\n<p>Úgy vélhetitek, hogy ebben a történet kicsit sok a beetetést. <strong>Maga a megoldás rendkívül egyszerű, mégis azért tettem meg ezt a hatalmas kerülőutat, hogy elmagyarázzam a React <em>miért</em> ezt a megoldást választotta és milyen más alternatívák merültek fel.</strong></p>\n<p>Tapasztalatom szerint ez gyakran megesik az API könyvtárakkal. Ha azt várjuk el egy API-tól, hogy egyszerűen lehessen használni akkor figyelembe kell venni a nyelv szemantikáját (valószínűleg több nyelvét is, beleértve a lehetséges jövőbeli irányvonalakat is), a lefutás gyorsaságát, a munkakörnyezetet fordítási műveletekkel és azok nélkül, az ökoszisztéma és a programcsomagok állapotát és számos más tényezőt. A végső megoldás nem mindig a legelegánsabb is, viszont muszáj használhatónak lennie.</p>\n<p><strong>Ha a végső API sikeres, a <em>felhasználónak</em> soha nem kell ezen a procedúrán rágódnia.</strong> Ehelyett fókuszálhatnak inkább az appokra.</p>\n<p>De ha kíváncsi vagy… nem árt ha tudod, hogy működnek a dolgok.</p>","timeToRead":17,"frontmatter":{"title":"Hogyan különbözteti meg a React az osztályt a függvénytől?","date":"December 02, 2018","spoiler":"Lesz szó osztályokról, konstruktorokról, prototípus láncokról és API dizájnról.","cta":null},"fields":{"slug":"/hu/how-does-react-tell-a-class-from-a-function/","langKey":"hu"}}},"pageContext":{"slug":"/hu/how-does-react-tell-a-class-from-a-function/","translations":["es","fr","hu","ja","nl","pt-br","sk","zh-hans","zh-hant"],"translatedLinks":["/why-do-we-write-super-props/"]}}}
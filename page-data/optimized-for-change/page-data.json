{"componentChunkName":"component---src-templates-blog-post-js","path":"/optimized-for-change/","result":{"data":{"site":{"siteMetadata":{"title":"Overreacted","author":"Dan Abramov"}},"markdownRemark":{"id":"9f1e239f-94c3-5918-a87e-c559d8e9bc15","html":"<p>What makes a great API?</p>\n<p><em>Good</em> API design is memorable and unambiguous. It encourages readable, correct and performant code, and helps developers fall into <a href=\"https://blog.codinghorror.com/falling-into-the-pit-of-success/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">the pit of success</a>.</p>\n<p>I call these design aspects “first order” because they are the first things a library developer tends to focus on. You might have to compromise on some of them and make tradeoffs but at least they’re always on your mind.</p>\n<p>However, unless you’re sending a rover to Mars, your code will probably change over time. And so will the code of your API consumers.</p>\n<p>The best API designers I know don’t stop at the “first order” aspects like readability. They dedicate just as much, if not more, effort to what I call the “second order” API design: <strong>how code using this API would evolve over time.</strong></p>\n<p>A slight change in requirements can make the most elegant code fall apart.</p>\n<p><em>Great</em> APIs anticipate that. They anticipate that you’ll want to move some code. Copy and paste some part. Rename it. Unify special cases into a generic reusable helper. Unwind an abstraction back into specific cases. Add a hack. Optimize a bottleneck. Throw away a part and start it anew. Make a mistake. Navigate between the cause and the effect. Fix a bug. Review the fix.</p>\n<p>Great APIs not only let you fall into a pit of success, but help you <em>stay</em> there.</p>\n<p>They’re optimized for change.</p>","timeToRead":1,"frontmatter":{"title":"Optimized for Change","date":"December 12, 2018","spoiler":"What makes a great API?","cta":null},"fields":{"slug":"/optimized-for-change/","langKey":"en"}}},"pageContext":{"slug":"/optimized-for-change/","previous":{"fields":{"slug":"/how-does-setstate-know-what-to-do/","langKey":"en","directoryName":"how-does-setstate-know-what-to-do","maybeAbsoluteLinks":["/why-do-react-elements-have-typeof-property/","/how-does-react-tell-a-class-from-a-function/","/why-do-we-write-super-props/"]},"frontmatter":{"title":"How Does setState Know What to Do?"}},"next":{"fields":{"slug":"/why-do-hooks-rely-on-call-order/","langKey":"en","directoryName":"why-do-hooks-rely-on-call-order","maybeAbsoluteLinks":["/how-does-setstate-know-what-to-do/","/optimized-for-change/"]},"frontmatter":{"title":"Why Do React Hooks Rely on Call Order?"}},"translations":["ar","es","bg","de","fa","fr","he","id","nl","pl","ru","pt-br","tr","uk","zh-hant","zh-hans"],"translatedLinks":[]}}}
{"componentChunkName":"component---src-templates-blog-post-js","path":"/what-is-javascript-made-of/","result":{"data":{"site":{"siteMetadata":{"title":"Overreacted","author":"Dan Abramov"}},"markdownRemark":{"id":"d5b9bce8-8eab-5a00-9a21-e7eafff45cf3","html":"<p>During my first few years of using JavaScript, I felt like a fraud. Even though I could build websites with frameworks, something was missing. I dreaded JavaScript job interviews because I didn’t have a solid grasp on fundamentals.</p>\n<p>Over the years, I’ve formed a mental model of JavaScript that gave me confidence. Here, I’m sharing a <strong>very compressed</strong> version of it. It’s structured like a glossary, with each topic getting a few sentences.</p>\n<p>As you read through this post, try to mentally keep score about how <em>confident</em> you feel about each topic. I won’t judge you if quite a few of them are a miss! At the end of this post, there is something that might help in that case.</p>\n<hr>\n<ul>\n<li>\n<p><strong>Value</strong>: The concept of a value is a bit abstract. It’s a “thing”. A value to JavaScript is what a number is to math, or what a point is to geometry. When your program runs, its world is full of values. Numbers like <code class=\"language-text\">1</code>, <code class=\"language-text\">2</code>, and <code class=\"language-text\">420</code> are values, but so are some other things, like this sentence: <code class=\"language-text\">&quot;Cows go moo&quot;</code>. Not <em>everything</em> is a value though. A number is a value, but an <code class=\"language-text\">if</code> statement is not. We’ll look at a few different kinds of values below.</p>\n<ul>\n<li><strong>Type of Value</strong>: There are a few different “types” of values. For example, <em>numbers</em> like <code class=\"language-text\">420</code>, <em>strings</em> like <code class=\"language-text\">&quot;Cows go moo&quot;</code>, <em>objects</em>, and a few other types. You can learn a type of some value by putting <code class=\"language-text\">typeof</code> before it. For example, <code class=\"language-text\">console.log(typeof 2)</code> prints <code class=\"language-text\">&quot;number&quot;</code>.</li>\n<li><strong>Primitive Values</strong>: Some value types are “primitive”. They include numbers, strings, and a few other types. One peculiar thing about primitive values is that you can’t create more of them, or change them in any way. For example, every time you write <code class=\"language-text\">2</code>, you get the <em>same</em> value <code class=\"language-text\">2</code>. You can’t “create” another <code class=\"language-text\">2</code> in your program, or make the <code class=\"language-text\">2</code> <em>value</em> “become” <code class=\"language-text\">3</code>. This is also true for strings.</li>\n<li><strong><code class=\"language-text\">null</code> and <code class=\"language-text\">undefined</code></strong>: These are two special values. They’re special because there’s a lot of things you can’t do with them — they often cause errors. Usually, <code class=\"language-text\">null</code> represents that some value is missing intentionally, and <code class=\"language-text\">undefined</code> represents that a value is missing unintentionally. However, when to use either is left to the programmer. They exist because sometimes it’s better for an operation to fail than to proceed with a missing value.</li>\n</ul>\n</li>\n<li>\n<p><strong>Equality</strong>: Like “value”, equality is a fundamental concept in JavaScript. We say two values are equal when they’re… actually, I’d never say that. If two values are equal, it means they <em>are</em> the same value. Not two different values, but one! For example, <code class=\"language-text\">&quot;Cows go moo&quot; === &quot;Cows go moo&quot;</code> and <code class=\"language-text\">2 === 2</code> because <code class=\"language-text\">2</code> <em>is</em> <code class=\"language-text\">2</code>. Note we use <em>three</em> equal signs to represent this concept of equality in JavaScript.</p>\n<ul>\n<li><strong>Strict Equality</strong>: Same as above.</li>\n<li><strong>Referential Equality</strong>: Same as above.</li>\n<li><strong>Loose Equality</strong>: Oof, this one is different! Loose equality is when we use <em>two</em> equal signs (<code class=\"language-text\">==</code>). Things may be considered <em>loosely equal</em> even if they refer to <em>different</em> values that look similar (such as <code class=\"language-text\">2</code> and <code class=\"language-text\">&quot;2&quot;</code>). It was added to JavaScript early on for convenience and has caused endless confusion ever since. This concept is not fundamental, but is a common source of mistakes. You can learn how it works on a rainy day, but many people try to avoid it.</li>\n</ul>\n</li>\n<li><strong>Literal</strong>: A literal is when you refer to a value by <em>literally</em> writing it down in your program. For example, <code class=\"language-text\">2</code> is a <em>number literal</em>, and <code class=\"language-text\">&quot;Banana&quot;</code> is a <em>string literal</em>.</li>\n<li>\n<p><strong>Variable</strong>: A variable lets you refer to some value using a name. For example, <code class=\"language-text\">let message = &quot;Cows go moo&quot;</code>. Now you can write <code class=\"language-text\">message</code> instead of repeating the same sentence every time in your code. You may later change <code class=\"language-text\">message</code> to point to another value, like <code class=\"language-text\">message = &quot;I am the walrus&quot;</code>. Note this doesn’t change <em>the value itself</em>, but only where the <code class=\"language-text\">message</code> points to, like a “wire”. It pointed to <code class=\"language-text\">&quot;Cows go moo&quot;</code>, and now it points to <code class=\"language-text\">&quot;I am the walrus&quot;</code>.</p>\n<ul>\n<li><strong>Scope</strong>: It would suck if there could only be one <code class=\"language-text\">message</code> variable in the whole program. Instead, when you define a variable, it becomes available in a <em>part</em> of your program. That part is called a “scope”. There are rules about how scope works, but usually you can search for the closest <code class=\"language-text\">{</code> and <code class=\"language-text\">}</code> braces around where you define the variable. That “block” of code is its scope.</li>\n<li><strong>Assignment</strong>: When we write <code class=\"language-text\">message = &quot;I am the walrus&quot;</code>, we change the <code class=\"language-text\">message</code> variable to point to <code class=\"language-text\">&quot;I am the walrus&quot;</code> value. This is called an assignment, writing, or setting the variable.</li>\n<li><strong><code class=\"language-text\">let</code> vs <code class=\"language-text\">const</code> vs <code class=\"language-text\">var</code></strong>: Usually you want <code class=\"language-text\">let</code>. If you want to forbid assignment to this variable, you can use <code class=\"language-text\">const</code>. (Some codebases and coworkers are pedantic and force you to use <code class=\"language-text\">const</code> when there is only one assignment.) Avoid <code class=\"language-text\">var</code> if you can because its scoping rules are confusing.</li>\n</ul>\n</li>\n<li>\n<p><strong>Object</strong>: An object is a special kind of value in JavaScript. The cool thing about objects is that they can have connections to other values. For example, a <code class=\"language-text\">{flavor: &quot;vanilla&quot;}</code> object has a <code class=\"language-text\">flavor</code> property that points to the <code class=\"language-text\">&quot;vanilla&quot;</code> value. Think of an object as “your own” value with “wires” from it.</p>\n<ul>\n<li><strong>Property</strong>: A property is like a “wire” sticking from an object and pointing to some value. It might remind you of a variable: it has a name (like <code class=\"language-text\">flavor</code>) and points to a value (like <code class=\"language-text\">&quot;vanilla&quot;</code>). But unlike a variable, a property “lives” <em>in</em> the object itself rather than in some place in your code (scope). A property is considered a part of the object — but the value it points to is not.</li>\n<li><strong>Object Literal</strong>: An object literal is a way to create an object value by <em>literally</em> writing it down in your program, like <code class=\"language-text\">{}</code> or <code class=\"language-text\">{flavor: &quot;vanilla&quot;}</code>. Inside <code class=\"language-text\">{}</code>, we can have multiple <code class=\"language-text\">property: value</code> pairs separated by commas. This lets us set up where the property “wires” point to from our object.</li>\n<li><strong>Object Identity</strong>: We mentioned earlier that <code class=\"language-text\">2</code> is <em>equal</em> to <code class=\"language-text\">2</code> (in other words, <code class=\"language-text\">2 === 2</code>) because whenever we write <code class=\"language-text\">2</code>, we “summon” the same value. But whenever we write <code class=\"language-text\">{}</code>, we will always get a <em>different</em> value! So <code class=\"language-text\">{}</code> is <em>not equal</em> to another <code class=\"language-text\">{}</code>. Try this in console: <code class=\"language-text\">{} === {}</code> (the result is false). When the computer meets <code class=\"language-text\">2</code> in our code, it always gives us the same <code class=\"language-text\">2</code> value. However, object literals are different: when a computer meets <code class=\"language-text\">{}</code>, it <em>creates a new object, which is always a new value</em>. So what is object identity? It’s yet another term for equality, or same-ness of values. When we say “<code class=\"language-text\">a</code> and <code class=\"language-text\">b</code> have the same identity”, we mean “<code class=\"language-text\">a</code> and <code class=\"language-text\">b</code> point to the <em>same</em> value” (<code class=\"language-text\">a === b</code>). When we say “<code class=\"language-text\">a</code> and <code class=\"language-text\">b</code> have different identities”, we mean “<code class=\"language-text\">a</code> and <code class=\"language-text\">b</code> point to <em>different</em> values” (<code class=\"language-text\">a !== b</code>).</li>\n<li><strong>Dot Notation</strong>: When you want to read a property from an object or assign to it, you can use the dot (<code class=\"language-text\">.</code>) notation. For example, if a variable <code class=\"language-text\">iceCream</code> points to an object whose property <code class=\"language-text\">flavor</code> points to <code class=\"language-text\">&quot;chocolate&quot;</code>, writing <code class=\"language-text\">iceCream.flavor</code> will give you <code class=\"language-text\">&quot;chocolate&quot;</code>.</li>\n<li><strong>Bracket Notation</strong>: Sometimes you don’t know the name of the property you want to read in advance. For example, maybe sometimes you want to read <code class=\"language-text\">iceCream.flavor</code> and sometimes you want to read <code class=\"language-text\">iceCream.taste</code>. The bracket (<code class=\"language-text\">[]</code>) notation lets you read the property when <em>its name itself</em> is a variable. For example, let’s say that <code class=\"language-text\">let ourProperty = &#39;flavor&#39;</code>. Then <code class=\"language-text\">iceCream[ourProperty]</code> will give us <code class=\"language-text\">&quot;chocolate&quot;</code>. Curiously, we can use it when creating objects too: <code class=\"language-text\">{ [ourProperty]: &quot;vanilla&quot; }</code>.</li>\n<li><strong>Mutation</strong>: We say an object is <em>mutated</em> when somebody changes its property to point to a different value. For example, if we declare <code class=\"language-text\">let iceCream = {flavor: &quot;vanilla&quot;}</code>, we can later <em>mutate</em> it with <code class=\"language-text\">iceCream.flavor = &quot;chocolate&quot;</code>. Note that even if we used <code class=\"language-text\">const</code> to declare <code class=\"language-text\">iceCream</code>, we could still mutate <code class=\"language-text\">iceCream.flavor</code>. This is because <code class=\"language-text\">const</code> would only prevent assignments to the <code class=\"language-text\">iceCream</code> <em>variable itself</em>, but we mutated a <em>property</em> (<code class=\"language-text\">flavor</code>) of the object it pointed to. Some people swore off using <code class=\"language-text\">const</code> altogether because they find this too misleading.</li>\n<li><strong>Array</strong>: An array is an object that represents a list of stuff. When you write an <em>array literal</em> like <code class=\"language-text\">[&quot;banana&quot;, &quot;chocolate&quot;, &quot;vanilla&quot;]</code>, you essentially create an object whose property called <code class=\"language-text\">0</code> points to the <code class=\"language-text\">&quot;banana&quot;</code> string value, property called <code class=\"language-text\">1</code> points to the <code class=\"language-text\">&quot;chocolate&quot;</code> value, and property called <code class=\"language-text\">2</code> points to the <code class=\"language-text\">&quot;vanilla&quot;</code> value. It would be annoying to write <code class=\"language-text\">{0: ..., 1: ..., 2: ...}</code> which is why arrays are useful. There are also some built-in ways to operate on arrays, like <code class=\"language-text\">map</code>, <code class=\"language-text\">filter</code>, and <code class=\"language-text\">reduce</code>. Don’t despair if <code class=\"language-text\">reduce</code> seems confusing — it’s confusing to everyone.</li>\n<li><strong>Prototype</strong>: What happens if we read a property that doesn’t exist? For example, <code class=\"language-text\">iceCream.taste</code> (but our property is called <code class=\"language-text\">flavor</code>). The simple answer is we’ll get the special <code class=\"language-text\">undefined</code> value. The more nuanced answer is that most objects in JavaScript have a “prototype”. You can think of a prototype as a “hidden” property on every object that determines “where to look next”. So if there’s no <code class=\"language-text\">taste</code> property on <code class=\"language-text\">iceCream</code>, JavaScript will look for a <code class=\"language-text\">taste</code> property on its prototype, then on <em>that</em> object’s prototype, and so on, and will only give us <code class=\"language-text\">undefined</code> if it reaches the end of this “prototype chain” without finding <code class=\"language-text\">.taste</code>. You will rarely interact with this mechanism directly, but it explains why our <code class=\"language-text\">iceCream</code> object has a <code class=\"language-text\">toString</code> method that we never defined — it comes from the prototype.</li>\n</ul>\n</li>\n<li>\n<p><strong>Function</strong>: A function is a special value with one purpose: it represents <em>some code in your program</em>. Functions are handy if you don’t want to write the same code many times. “Calling” a function like <code class=\"language-text\">sayHi()</code> tells the computer to run the code inside it and then go back to where it was in the program. There are many ways to define a function in JavaScript, with slight differences in what they do.</p>\n<ul>\n<li><strong>Arguments (or Parameters)</strong>: Arguments let you pass some information to your function from the place you call it: <code class=\"language-text\">sayHi(&quot;Amelie&quot;)</code>. Inside the function, they act similar to variables. They’re called either “arguments” or “parameters” depending on which side you’re reading (function definition or function call). However, this distinction in terminology is pedantic, and in practice these two terms are used interchangeably.</li>\n<li><strong>Function Expression</strong>: Previously, we set a variable to a <em>string value</em>, like <code class=\"language-text\">let message = &quot;I am the walrus&quot;</code>. It turns out that we can also set a variable to a <em>function</em>, like <code class=\"language-text\">let sayHi = function() { }</code>. The thing after <code class=\"language-text\">=</code> here is called a <em>function expression</em>. It gives us a special value (a function) that represents our piece of code, so we can call it later if we want to.</li>\n<li><strong>Function Declaration</strong>: It gets tiring to write something like <code class=\"language-text\">let sayHi = function() { }</code> every time, so we can use a shorter form instead: <code class=\"language-text\">function sayHi() { }</code>. This is called a <em>function declaration</em>. Instead of specifying the variable name on the left, we put it after the <code class=\"language-text\">function</code> keyword. These two styles are mostly interchangeable.</li>\n<li><strong>Function Hoisting</strong>: Normally, you can only use a variable after its declaration with <code class=\"language-text\">let</code> or <code class=\"language-text\">const</code> has run. This can be annoying with functions because they may need to call each other, and it’s hard to track which function is used by which others and needs to be defined first. As a convenience, when (and only when!) you use the <em>function declaration</em> syntax, the order of their definitions doesn’t matter because they get “hoisted”. This is a fancy way of saying that conceptually, they all automatically get moved to the top of the scope. By the time you call them, they’re all defined.</li>\n<li><strong><code class=\"language-text\">this</code></strong>: Probably the most misunderstood JavaScript concept, <code class=\"language-text\">this</code> is like a special argument to a function. You don’t pass it to a function yourself. Instead, JavaScript itself passes it, depending on <em>how you call</em> the function. For example, calls using the dot <code class=\"language-text\">.</code> notation — like <code class=\"language-text\">iceCream.eat()</code> — will get a special <code class=\"language-text\">this</code> value from whatever is before the <code class=\"language-text\">.</code> (in our example, <code class=\"language-text\">iceCream</code>). The value of <code class=\"language-text\">this</code> inside a function depends on how the function is <em>called</em>, not where it’s defined. Helpers like <code class=\"language-text\">.bind</code>, <code class=\"language-text\">.call</code>, and <code class=\"language-text\">.apply</code> let you have for more control over the value of <code class=\"language-text\">this</code>.</li>\n<li><strong>Arrow Functions</strong>: Arrow functions are similar to function expressions. You declare them like this: <code class=\"language-text\">let sayHi = () =&gt; { }</code>. They’re concise and are often used for one-liners. Arrow functions are <em>more limited</em> than regular functions — for example, they have no concept of <code class=\"language-text\">this</code> whatsoever. When you write <code class=\"language-text\">this</code> inside of an arrow function, it uses <code class=\"language-text\">this</code> of the closest “regular” function above. This is similar to what would happen if you used an argument or a variable that only exists in a function above. Practically, this means that people use arrow functions when they want to “see” the same <code class=\"language-text\">this</code> inside of them as in the code surrounding them.</li>\n<li><strong>Function Binding</strong>: Usually, <em>binding</em> a function <code class=\"language-text\">f</code> to a particular <code class=\"language-text\">this</code> value and arguments means creating a <em>new</em> function that calls <code class=\"language-text\">f</code> with those predefined values. JavaScript has a built-in helper to do it called <code class=\"language-text\">.bind</code>, but you could also do it by hand. Binding was a popular way to make nested functions “see” the same value of <code class=\"language-text\">this</code> as the outer functions. But now this use case is handled by arrow functions, so binding is not used as often.</li>\n<li><strong>Call Stack</strong>: Calling a function is like entering a room. Every time we call a function, the variables inside of it are initialized all over again. So each function call is like <em>constructing</em> a new “room” with its code and entering it. Our function’s variables “live” in that room. When we return from the function, that “room” disappears with all its variables. You can visualize these rooms as a vertical stack of rooms — a <em>call stack</em>. When we exit a function, we go back to the function “below” it on the call stack.</li>\n<li><strong>Recursion</strong>: Recursion means that a function calls itself from within itself. This is useful for when you want to repeat the thing you just did in your function <em>again</em>, but for different arguments. For example, if you’re writing a search engine that crawls the web, your <code class=\"language-text\">collectLinks(url)</code> function might first collect the links from a page, and then <em>call itself</em> for every <em>link</em> until it visits all pages. The pitfall with recursion is that it’s easy to write code that never finishes because a function keeps calling itself forever. If this happens, JavaScript will stop it with an error called “stack overflow”. It’s called this way because it means we have too many function calls stacked in our call stack, and it has literally overflown.</li>\n<li><strong>Higher-Order Function</strong>: A higher-order function is a function that deals with other functions by taking them as arguments or returning them. This might seem weird at first, but we should remember that functions are values so we can pass them around — like we do with numbers, strings, or objects. This style can be overused, but it’s very expressive in moderation.</li>\n<li><strong>Callback</strong>: A callback is not really a JavaScript term. It’s more of a pattern. It’s when you pass a function as an argument to another function, expecting it to <em>call your function back later</em>. You’re expecting a “call back”. For example, <code class=\"language-text\">setTimeout</code> takes a <em>callback</em> function and… calls you back after a timeout. But there’s nothing special about callback functions. They’re regular functions, and when we say “callback” we only talk about our expectations.</li>\n<li><strong>Closure</strong>: Normally, when you exit a function, all its variables “disappear”. This is because nothing needs them anymore. But what if you declare a function <em>inside</em> a function? Then the inner function could still be called later, and read the variables of the <em>outer</em> function. In practice, this is very useful! But for this to work, the outer function’s variables need to “stick around” somewhere. So in this case, JavaScript takes care of “keeping the variables alive” instead of “forgetting” them as it would usually do. This is called a “closure”. While closures are often considered a misunderstood JavaScript aspect, you probably use them many times a day without realizing it!</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>JavaScript is made of these concepts, and more. I felt very anxious about my knowledge of JavaScript until I could build a correct mental model, and I’d like to help the next generation of developers bridge this gap sooner.</p>\n<p>If you want to join me for a deeper dive in each of these topics, I have something for you. <strong><a href=\"https://justjavascript.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Just JavaScript</a> is my distilled mental model of how JavaScript works, and it’s going to feature visual illustrations by the amazing <a href=\"https://illustrated.dev/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Maggie Appleton</a></strong>. Unlike this post, it goes at a slower pace so you can follow along on every detail.</p>\n<p><em>Just JavaScript</em> is in a very early stage so it’s only available as a series of emails with zero polish or editing. If this project sounds interesting, you can <a href=\"https://justjavascript.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">sign up</a> to receive free drafts by email. I will be grateful for your feedback. Thank you!</p>","timeToRead":13,"frontmatter":{"title":"What Is JavaScript Made Of?","date":"December 20, 2019","spoiler":"Getting a closure on JavaScript.","cta":null},"fields":{"slug":"/what-is-javascript-made-of/","langKey":"en"}}},"pageContext":{"slug":"/what-is-javascript-made-of/","previous":{"fields":{"slug":"/algebraic-effects-for-the-rest-of-us/","langKey":"en","directoryName":"algebraic-effects-for-the-rest-of-us","maybeAbsoluteLinks":["/things-i-dont-know-as-of-2018/","/how-does-setstate-know-what-to-do/"]},"frontmatter":{"title":"Algebraic Effects for the Rest of Us"}},"next":null,"translations":["es","pt-br"],"translatedLinks":[]}}}
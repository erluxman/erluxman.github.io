{"componentChunkName":"component---src-templates-blog-post-js","path":"/de/why-do-we-write-super-props/","result":{"data":{"site":{"siteMetadata":{"title":"Overreacted","author":"Dan Abramov"}},"markdownRemark":{"id":"c15f5d7b-f310-578b-916a-bde50062bae3","html":"<p><a href=\"https://reactjs.org/docs/hooks-intro.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Hooks</a> sind scheinbar der letzte Schrei. Ironischerweise m√∂chte ich diesen Blogeintrag damit beginnen ein par Fun-Facts zum Thema <em>class</em> components loszuwerden. Wie w√§re es damit!</p>\n<p><strong>Es ist absolut <em>nicht</em> notwendig diese Fakten zu kennen um effektiv mit React arbeiten zu k√∂nnen. Jedoch k√∂nnte es interessant werden, wenn man tiefer in die Materie einsteigen m√∂chte.</strong></p>\n<p>Fun-Fact Nummer Eins.</p>\n<hr>\n<p>Ich habe <code class=\"language-text\">super(props)</code> bereits √∂fter schreiben d√ºrfen, als es mir lieb ist:</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Das <a href=\"https://github.com/tc39/proposal-class-fields\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">class fields proposal</a> macht es nat√ºrlich einfach das Ganze zu √ºberspringen:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Eine √§hnliche Syntax war bereits <a href=\"https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#es7-property-initializers\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">geplant</a>, als 2015, mit React 0.13, die Unterst√ºtzung von plain classes hinzugef√ºgt wurde. Das Definieren vom separaten <code class=\"language-text\">Konstruktor</code> und der Aufruf von <code class=\"language-text\">super(props)</code> war schon immer als √úbergangsl√∂sung gedacht. Diese sollte letztlich durch eine ergonomischere L√∂sung mithilfe von Klassenattributen abgel√∂st werden.</p>\n<p>Schauen wir uns das Beispiel nochmal an, jedoch mit den ES2015-Funktionalit√§ten:</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Warum rufen wir <code class=\"language-text\">super</code> auf? K√∂nnen wir nicht darauf <em>verzichten</em>? Wenn kein Weg daran vorbei f√ºhrt, was passiert wenn wir die <code class=\"language-text\">props</code> nicht √ºbergeben? Gibt es au√üerdem noch weitere Eingabeparameter?</strong> Gehen wir der Sache n√§her auf den Grund.</p>\n<hr>\n<p>In Javascript weist <code class=\"language-text\">super</code> immer auf den Konstruktor der Basisklasse. (In unserem Beispiel bezieht es sich auf die Implementation von <code class=\"language-text\">React.Component</code>.)</p>\n<p>Es sei wichtig zu wissen, dass man <code class=\"language-text\">this</code> im Konstruktor erst <em>nach</em> dem Aufruf des eigentlichen Basiskonstruktors verwenden kann. Javascript erlaubt es nicht:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// üî¥ Kann `this` noch nicht verwenden</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ‚úÖ Jetzt funktioniert es</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Es gibt einen guten Grund warum Javascript es verlangt den √ºbergeordneten Konstruktor aufzurufen, bevor man <code class=\"language-text\">this</code> nutzen darf. Stellen wir uns folgende Klassenhierarchie vor:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">PolitePerson</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">greetColleagues</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// üî¥ Dies ist verboten, unten steht warum</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">greetColleagues</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Guten Morgen, Freunde!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Nehmen wir einmal an, es <em>w√§re</em> erlaubt <code class=\"language-text\">this</code> vor <code class=\"language-text\">super</code> aufzurufen. Nach einem Monat √§ndern wir dann <code class=\"language-text\">greetColleagues</code>, sodass es den Namen der Person mit beinhaltet:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">  <span class=\"token function\">greetColleagues</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Guten Morgen, Freunde!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Mein Name ist '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">+</span> <span class=\"token string\">', freut mich euch kennenzulernen!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>An dieser Stelle vergessen wir jedoch, dass <code class=\"language-text\">this.greetColleagues()</code> vor <code class=\"language-text\">super()</code> aufgerufen wird. Das Attribut <code class=\"language-text\">this.name</code> konnte also noch gar nicht richtig gesetzt werden. Zum Zeitpunkt an dem wir den Wert in der Methode abrufen ist <code class=\"language-text\">this.name</code> noch nicht einmal definiert! Es ist wahrlich schwer sich mit solchem Code auseinanderzusetzen.</p>\n<p>Um Fallen wie diesen aus dem Weg zu gehen <strong>wird von Javascript verlangt, dass <code class=\"language-text\">super</code> <em>aufgerufen werden muss</em>, bevor man <code class=\"language-text\">this</code> im Konstruktor benutzen darf.</strong> Lassen wir also die Superklasse ihr Ding machen! Diese Einschr√§nkung trifft auch auf in Klassen definierte React-Komponenten zu:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ‚úÖ Jetzt k√∂nnen wir `this` benutzen</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>Nun f√ºhrt uns das alles jedoch zur n√§chsten Frage: Warum reichen wir die <code class=\"language-text\">props</code> weiter?</p>\n<hr>\n<p>Es ist denkbar, dass das Hinunterreichen der <code class=\"language-text\">props</code> an <code class=\"language-text\">super</code> notwendig ist, damit <code class=\"language-text\">React.Component</code> seine <code class=\"language-text\">this.props</code> korrekt setzen kann:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Im Inneren von React</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Und dies ist gar nicht so falsch, letztendlich ist es sogar <a href=\"https://github.com/facebook/react/blob/1d25aa5787d4e19704c049c3cfa985d3b5190e0d/packages/react/src/ReactBaseClasses.js#L22\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">genau so</a>.</p>\n<p>Nun erscheint es jedoch eigenartig, dass, selbst wenn man <code class=\"language-text\">super()</code> ohne jeglich Argumente aufruft, man in Methoden wie <code class=\"language-text\">render</code> noch immer Zugriff auf <code class=\"language-text\">this.props</code> hat. (Wenn Du mir nicht traust, probiere es selber aus!)</p>\n<p>Wie kann <em>das</em> funktionieren? Es stellt sich heraus, dass <strong>React jeder Instanz ebenfalls <code class=\"language-text\">props</code> zuweist, gleich nach Aufruf <em>deines</em> Konstruktors:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">  <span class=\"token comment\">// Im Inneren von React</span>\n  <span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">YourComponent</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  instance<span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Somit sorgt React daf√ºr, dass selbst wenn man vergisst die <code class=\"language-text\">props</code> an <code class=\"language-text\">super()</code> weiterzureichen, diese unmittelbar nach der Instanziierung automatisch gesetzt werden. Hierf√ºr gibt es einen Grund.</p>\n<p>Als in React die Unterst√ºtzung von Klassen hinzugef√ºgt wurde, hat man dabei nicht nur ES6-Klassen ber√ºcksichtig. Das Ziel war es, ein m√∂glichst weites Spektrum an Klassenabstraktionen abdecken zu k√∂nnen. Es war <a href=\"https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#other-languages\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">nicht absehbar</a>, wie erfolgreich L√∂sungen hinsichtlich React-Komponenten mit ClojureScript, CoffeeScript, ES6, Fable, Scala.js, TypeScript oder Anderen werden k√∂nnten. Aus diesem Grund blieb React absichtlich neutral gegen√ºber, ob ein Aufruf von <code class=\"language-text\">super()</code> erforderlich sei - auch wenn dies f√ºr ES6-Klassen n√∂tig ist.</p>\n<p>Hei√üt das also, dass man einfach <code class=\"language-text\">super()</code> anstelle von <code class=\"language-text\">super(props)</code> schreiben kann?</p>\n<p><strong>Wahrscheinlich nicht, weil auch dies noch immer f√ºr Verwirrung sorgt.</strong> Einerseits w√ºrde React <em>nach</em> dem Aufruf des eigenen Konstruktors <code class=\"language-text\">this.props</code> automatisch zuweisen, jedoch w√§ren <code class=\"language-text\">this.props</code> dann <em>zwischen</em> dem Aufruf von <code class=\"language-text\">super</code> und dem Ende des Konstruktors nicht definiert:</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Im Inneren von React</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Im eigenen Code</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Button</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// üò¨ Wir haben vergessen props zu √ºbergeben</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">// ‚úÖ {}</span>\n<span class=\"gatsby-highlight-code-line\">    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// üò¨ nicht definiert</span></span>  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Dieses Verhalten kann noch verwirrender werden, wenn es in einzelnen Methoden vorkommt, welche <em>innerhalb</em> eines Konstruktors aufgerufen werden. <strong>Ich empfehle daher, die <code class=\"language-text\">props</code> immer mit <code class=\"language-text\">super(props)</code> an die Basisklasse runterzureichen, selbst wenn dies nicht dringend notwendig ist:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Button</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ‚úÖ Wir haben props √ºbergeben</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">// ‚úÖ {}</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ‚úÖ {}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Damit stellt man sicher, dass <code class=\"language-text\">this.props</code> schon vor Ende des Konstruktors gesetzt wurde.</p>\n<hr>\n<p>Es gibt noch eine weitere Sache, die erfahrene React-Nutzer neugierig machen k√∂nnte.</p>\n<p>Es k√∂nnte aufgefallen sein, dass beim Nutzen der Context-API in Klassen (entweder mittels der alten <code class=\"language-text\">contextTypes</code> oder der modernen <code class=\"language-text\">contextType</code> API, hinzugef√ºgt in React 16.6), <code class=\"language-text\">context</code> als zweites Argument an den Konstruktor √ºbergeben wird.</p>\n<p>Warum schreiben wir also nicht <code class=\"language-text\">super(props, context)</code>? Dies w√§re ohne Weiteres m√∂glich, jedoch wird context seltener benutzt und daher st√∂√üt also seltener auf diese Falle.</p>\n<p><strong>Mit dem class fields proposal er√ºbrigen sich m√∂gliche Fallstricke allemal.</strong> Ohne einen expliziten Konstruktor werden alle Argumente automatisch reingereicht. Dadurch kann ein Ausdruck wie <code class=\"language-text\">state = {}</code> bei Bedarf Verweise auf <code class=\"language-text\">this.props</code> oder <code class=\"language-text\">this.context</code> enthalten.</p>\n<p>Mit Hooks braucht man nicht einmal mehr <code class=\"language-text\">super</code> oder <code class=\"language-text\">this</code>. Das ist allerdings ein Thema f√ºr einen anderen Tag.</p>","timeToRead":5,"frontmatter":{"title":"Warum verwenden wir super(props)?","date":"November 30, 2018","spoiler":"Das Ende besitzt eine Wendung.","cta":null},"fields":{"slug":"/de/why-do-we-write-super-props/","langKey":"de"}}},"pageContext":{"slug":"/de/why-do-we-write-super-props/","translations":["cs","de","es","fa","fr","hu","it","my","ja","nl","nb","pl","pt-br","sk","sr","th","tr","uk","vi","zh-hans","zh-hant"],"translatedLinks":[]}}}
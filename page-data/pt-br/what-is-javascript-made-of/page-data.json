{"componentChunkName":"component---src-templates-blog-post-js","path":"/pt-br/what-is-javascript-made-of/","result":{"data":{"site":{"siteMetadata":{"title":"Overreacted","author":"Dan Abramov"}},"markdownRemark":{"id":"895d7809-8fcc-5eb4-9431-f1587ae8fc86","html":"<p>Durante os meus primeiros anos usando JavaScript eu me sentia uma fraude. Mesmo que eu já conseguia construir sites usando frameworks, algo estava faltando. Eu temia entrevistas de emprego de JavaScript por não ter uma base solida dos fundamentos.</p>\n<p>Com o passar dos anos formei um modelo mental de JavaScript que me deu confiança. Neste post irei compartilhar uma versão <strong>bem resumida</strong> disto. Está estruturado como um glossário, com cada tópico contendo algumas sentenças.</p>\n<p>Assim que for lendo este post, tente mentalmente manter um placar sobre o quão <em>confiante</em> você se sente com cada tópico. Eu não irei te julgar se não souber muitos deles. No final do post tem algo que talvez te ajude neste caso.</p>\n<hr>\n<ul>\n<li>\n<p><strong>Valores</strong>: O conceito de um valor é um pouco abstrato. É uma “coisa”. Um valor para JavaScript é o que um número é para matemática, ou o que um ponto é para geometria. Quando um programa roda, seu mundo é repleto de valores. Números como <code class=\"language-text\">1</code>, <code class=\"language-text\">2</code> e <code class=\"language-text\">420</code> são valores, mas também há outras coisas, como esta sentença: <code class=\"language-text\">&quot;Cows go moo&quot;</code>. Apesar disso nem <strong>tudo</strong> é um valor. Um número é um valor, mas um <code class=\"language-text\">if</code> não. Vamos olhar alguns diferentes valores a baixo.</p>\n<ul>\n<li><strong>Tipos de valores</strong>: Existem alguns diferentes “tipos” de valores. Por exemplo, <em>numbers</em> como <code class=\"language-text\">420</code>, <em>strings</em> como <code class=\"language-text\">&quot;Cow go moo&quot;</code>, <em>objects</em> e alguns outros. Você pode descobrir o tipo de algum valor ao colocar typeof antes do mesmo. Por exemplo, console.log(typeof 2) printa “number”.</li>\n<li><strong>Valores primitivos</strong>: Alguns valores são “primitivos”. Eles includem números, strings e alguns outros tipos. Uma coisa peculiar sobre valores primitivos é que você não pode criar mais deles, ou modifica-los de qualquer maneira. Por exemplo, sempre que você escreve <code class=\"language-text\">2</code> você obtêm o <em>mesmo</em> valor <code class=\"language-text\">2</code>. Você não pode “criar” outro <code class=\"language-text\">2</code> em seu programa ou fazer o <em>valor</em> de <code class=\"language-text\">2</code> “virar” <code class=\"language-text\">3</code>. Isso também é verdade para strings.</li>\n<li><strong><code class=\"language-text\">null</code> e <code class=\"language-text\">undefined</code></strong>: Estes são dois valores especiais. São especiais porque existem muitas coisas que não é possível fazer com eles — e quase sempre causam erros. Normalmente, <code class=\"language-text\">null</code> representa que o valor está faltando voluntariamente e <code class=\"language-text\">undefined</code> representa que o valor está faltando involuntariamente. De qualquer maneira, quando usar um ou outro fica para de escolha do programador. Eles existem porque algumas vezes é melhor que uma operação falhe do que proceder sem um valor.</li>\n</ul>\n</li>\n<li>\n<p><strong>Igualdade</strong>: Assim como “valor”, igualdade é um conceito fundamento no JavaScript. Dizemos que dois valores são iguais quando eles… na verdade, eu nunca diria isso. Se dois valores são iguais, isso significa que eles <em>são</em> o mesmo valor. Não dois valores diferentes. Por exemplo, <code class=\"language-text\">&quot;Cows go moo&quot; === &quot;Cows go moo&quot;</code> e <code class=\"language-text\">2 === 2</code> porque <code class=\"language-text\">2</code> <em>é</em>  <code class=\"language-text\">2</code>. Note que usamos <em>três</em> sinais de igual para representar este conceito de igualdade no JavaScript.</p>\n<ul>\n<li><strong>Igualdade estrita</strong>: O mesmo que acima.</li>\n<li><strong>Igualdade referencial</strong>: O mesmo que acima.</li>\n<li><strong>Igualdade ampla</strong>: É, este é diferente! Igualdade ampla acotnece quando usamos <em>dois</em> sinais de igual (<code class=\"language-text\">==</code>). Pode ser considerado de <em>igualdade ampla</em> mesmo se referir a valores <em>diferentes</em> que parecem iguais (como <code class=\"language-text\">2</code> e <code class=\"language-text\">&quot;2&quot;</code>). Foi adicionado ao JavaScript para comodidade, mas causa uma confusão sem fim desde o início. Este conceito não é fundamental, mas é uma fonte de erros comum. Você pode aprender sobre como isso funciona em um dia chuvoso, mas a maioria das pessoas apenas ignora este assunto.</li>\n</ul>\n</li>\n<li><strong>Literal</strong>: Se classifica literal quando você se refere a um valor <em>literalmente</em> escrevendo em seu programa. Por exemplo, <code class=\"language-text\">2</code> é um <em>number literal</em> e <code class=\"language-text\">&quot;Banana&quot;</code> é um <em>string literal</em>.</li>\n<li>\n<p><strong>Variável</strong>: Uma variável te deixa referir a um valor usando seu nome. Por exemplo, <code class=\"language-text\">let message = &quot;Cows go moo&quot;</code>. Agora você pode escrever <code class=\"language-text\">message</code> em vez de repetir a sentença toda vez no seu código. Você pode depois mudar <code class=\"language-text\">message</code> para apontar para outro valor, como <code class=\"language-text\">message = &quot;I am the walrus&quot;</code>. Perceba que isso não muda <em>o valor em si</em>, apenas para onde <code class=\"language-text\">message</code> aponta, como um “fio”. Estava apontado para <code class=\"language-text\">&quot;Cows go moo&quot;</code> e agora aponta para <code class=\"language-text\">&quot;I am the walrus&quot;</code>.</p>\n<ul>\n<li><strong>Escopo</strong>: Seria muito ruim se só pudesse ter uma variável <code class=\"language-text\">message</code> em todo nosso programa. Em vez disso, quando você define uma variável ela fica disponível em uma <em>parte</em> do seu programa. Esta parte é chamada um “escopo”. Existem regras de como um escopo funciona, mas normalmente você pode procurar pelos <code class=\"language-text\">{</code> e <code class=\"language-text\">}</code> mais próximo de onde você definiu a variável. Este “bloco” de código é seu escopo.</li>\n<li><strong>Atribuição</strong>: Quando escrevemos <code class=\"language-text\">message = &quot;I am the walrus&quot;</code>, nós mudamos a variável <code class=\"language-text\">message</code> para apontar ao valor <code class=\"language-text\">&quot;I am the walrus&quot;</code>. Isto é chamado atribuição, escrevendo ou fixando a variável.</li>\n<li><strong><code class=\"language-text\">let</code> vs <code class=\"language-text\">const</code> vs <code class=\"language-text\">var</code></strong>: Normalmente vai preferir <code class=\"language-text\">let</code>. Se você quer impedir atribuições para esta variável você pode usar <code class=\"language-text\">const</code>. (Algumas codebases e colegas de trabalho são minuciosos e te forçam a usar <code class=\"language-text\">const</code> onde tem apenas uma atribuição). Evite <code class=\"language-text\">var</code> se puder porque suas regras de escopo são confusas.</li>\n</ul>\n</li>\n<li>\n<p><strong>Objeto</strong>: Um objeto é um tipo especial de valor no JavaScript. O legal sobre objetos é que eles podem ter conexões com outros valores. Por exemplo, um objeto <code class=\"language-text\">{flavor: &quot;vanilla&quot;}</code> tem uma propriedade <code class=\"language-text\">flavor</code> que aponta para o valor <code class=\"language-text\">&quot;vanilla&quot;</code>. Pense em um objeto como “seu próprio” valor com “fios” a partir dele.</p>\n<ul>\n<li><strong>Propriedade</strong>: Uma propriedade é como um “fio” liga no objeto e apontando para algum valor. Pode te lembrar de como funciona com variáveis: tem um nome (como <code class=\"language-text\">flavor</code>) e aponta para um valor (como <code class=\"language-text\">&quot;vanilla&quot;</code>). Mas diferente de uma variável, uma propriedade “vive” <em>em</em>  um próprio objeto em vez de algum espaço do seu código (escopo). Uma propriedade é considerada parte do objeto — mas o valor que este aponta não.</li>\n<li><strong>Objeto Literal</strong>: Um objeto literal é uma maneira de criar um objeto por <em>literalmente</em> escrevendo em seu programa, como <code class=\"language-text\">{}</code> ou <code class=\"language-text\">{flavor: &quot;vanilla&quot;}</code>. Dentro de <code class=\"language-text\">{}</code> você pode ter vários pares de <code class=\"language-text\">propriedade: valor</code> separados por vírgula. Isso nos deixa “configurar” onde os “fios” das propriedades apontam.</li>\n<li><strong>Identidade do Objeto</strong>: Mencionamos antes que <code class=\"language-text\">2</code> é <em>igual</em> a <code class=\"language-text\">2</code> (em outras palavras, <code class=\"language-text\">2 === 2</code>) porque sempre que escrevermos <code class=\"language-text\">2</code> nós “chamamos” o mesmo valor. Mas sempre que você escreve <code class=\"language-text\">{}</code> terá um valor <em>diferente</em>. Então <code class=\"language-text\">{}</code> <em>não é igual</em>  a outro  <code class=\"language-text\">{}</code>. Tente isso no console: <code class=\"language-text\">{} === {}</code> (o resultado é false). Quando o computador encontra <code class=\"language-text\">2</code> em nosso código ele sempre nos da o mesmo valor <code class=\"language-text\">2</code>. Entretanto, com objetos isso é diferente: quando o computador encontra <code class=\"language-text\">{}</code>, ele <em>cria um novo objeto, que é sempre um novo valor</em>. Então o que é identidade do objeto? É outro termo para igualdade. Quando dizemos ”<code class=\"language-text\">a</code> e <code class=\"language-text\">b</code> tem a mesma identidade” queremos dizer que ”<code class=\"language-text\">a</code> e <code class=\"language-text\">b</code> apontam para o <em>mesmo</em> valor” (<code class=\"language-text\">a === b</code>). Quando dizemos ”<code class=\"language-text\">a</code> e <code class=\"language-text\">b</code> tem identidades diferentes”, queremos dizer ”<code class=\"language-text\">a</code> e <code class=\"language-text\">b</code> apontam para valores <em>diferentes</em>” (<code class=\"language-text\">a !== b</code>). </li>\n<li><strong>Notação de ponto</strong>: Quando você quer ler uma propriedade de um objeto ou atribuir a ele, você pode usar a notação de ponto (<code class=\"language-text\">.</code>). Por exemplo, uma variável <code class=\"language-text\">iceCream</code> aponta ao objeto que sua propriedade <code class=\"language-text\">flavor</code> aponta para <code class=\"language-text\">&quot;chocolate&quot;</code>, escrevendo <code class=\"language-text\">iceCream.flavor</code> vai te retornar <code class=\"language-text\">&quot;chocolate&quot;</code>.</li>\n<li><strong>Notação de colchetes</strong>: Às vezes você não sabe o nome da propriedade que você quer ler. Por exemplo, talvez você queira ler <code class=\"language-text\">iceCream.flavor</code> e às vezes <code class=\"language-text\">iceCream.taste</code>. A notação de colchetes (<code class=\"language-text\">[]</code>) te deixa ler uma propriedade quando seu proprio nome é uma variável. Por exemplo, vamos dizer que <code class=\"language-text\">let ouProperty = &#39;flavor&#39;</code>. Então <code class=\"language-text\">iceCream[outProperty]</code> vai nos dar <code class=\"language-text\">&quot;chocolate&quot;</code>. Curiosamente, podemos usar isto ao criar objetos também: <code class=\"language-text\">{ [ourProperty]: &quot;vanilla&quot;}</code>.</li>\n<li><strong>Mutação</strong>: Dizemos que um objeto é <em>mutado/alterado</em> quando alguém muda sua propriedade para apontar a um valor diferente. Por exemplo, se nós declaramos <code class=\"language-text\">let iceCream = {flavor: &quot;vanilla&quot;}</code>, podemos depois <em>mutar</em>  com <code class=\"language-text\">iceCream.flavor = &quot;chocolate&quot;</code>. Perceba que mesmo se usarmos <code class=\"language-text\">const</code> para declarar <code class=\"language-text\">iceCream</code>, ainda sim podemos mutar <code class=\"language-text\">iceCream.flavor</code>. Isso porque <code class=\"language-text\">const</code> pode apenas impedir de atribuições para <em>própria variável</em>  <code class=\"language-text\">iceCream</code>, mas mutamos a <em>propriedade</em> (<code class=\"language-text\">flavor</code>) do objeto que este aponta. Algumas pessoas optam por não usar <code class=\"language-text\">const</code> por achar isso muito confuso.</li>\n<li><strong>Array</strong>: Uma Array é um objeto que representa uma lista de coisas. Quando você escreve uma <em>array literal</em> como <code class=\"language-text\">[&quot;banana&quot;, &quot;chocolate&quot;, &quot;vanilla&quot;]</code>, você essencialmente cria um objeto que a propriedade <code class=\"language-text\">0</code> aponta para o valor <code class=\"language-text\">&quot;banana&quot;</code>, a propriedade chamada <code class=\"language-text\">1</code>aponta para <code class=\"language-text\">&quot;chocolate&quot;</code> e a <code class=\"language-text\">2</code> aponta para <code class=\"language-text\">&quot;vanilla&quot;</code>. Seria irritante escrever <code class=\"language-text\">{0: ..., 1: ..., 2: ...}</code>, é por isto que arrays são úteis. Existem também algumas maneiras embutidas de de operar arrays, como <code class=\"language-text\">map</code>, <code class=\"language-text\">filter</code> e <code class=\"language-text\">reduce</code>. Não se preocupe se <code class=\"language-text\">reduce</code> parecer confuso — é confuso para todo mundo.</li>\n<li><strong>Prototype</strong>: O que acontece se lermos uma propriedade que não existe? Por exemplo, <code class=\"language-text\">iceCream.taste</code> (mas nossa propriedade é chamada <code class=\"language-text\">flavor</code>). A resposta simples que é que vamos receber o valor <code class=\"language-text\">undefined</code>. A resposta mais completa é que a maioria dos objetos em javascript tem um “prototype”. Você pode pensar no prototype como uma propriedade escondida em cada objeto que determina “onde olhar”. Então se não existe a propriedade <code class=\"language-text\">taste</code> no <code class=\"language-text\">iceCream</code>, JavaScript vai procurar por <code class=\"language-text\">taste</code> em seu prototype, então no prototype <em>deste</em> objeto e ai por diante. Só nós retorna <code class=\"language-text\">undefined</code> se chegar ao fim da “cadeia de prototype” sem encontrar <code class=\"language-text\">.taste</code>. Você raramente vai interagir com este mecanismo diretamente, mas isto explica porque o objeto <code class=\"language-text\">iceCream</code> tem um método <code class=\"language-text\">toString</code> que nós nunca definimos — isso vem do prototype.</li>\n</ul>\n</li>\n<li>\n<p><strong>Função</strong>: Uma função é um valor especial com um proposito: representar <em>algum código no seu programa</em>. Funções são úteis se você não quer escrever o mesmo código várias vezes. “Chamando” uma função como <code class=\"language-text\">sayHi()</code> diz ao computador para executar o código dentro disto e então voltar onde estava no programa. Existem outras maneiras de definir uma função no JavaScript, com algumas diferenças no que elas fazem.</p>\n<ul>\n<li><strong>Argumentos (ou Parâmetros)</strong>: Argumentos te deixam passar alguma informação  para sua função do lugar onde você a chamou: <code class=\"language-text\">sayHi(&quot;Amelie&quot;</code>. Dentro da função elas funcionam de forma parecida com variáveis. São chamadas de “argumentos” ou “parâmetros”, dependendo de qual lado você está lendo (definição da função ou chamada da função). Entretanto, na prática essa distinção na terminologia não é obrigatório.</li>\n<li><strong>Expressão de função</strong>: Anteriormente definimos uma variável para um <em>valor de string</em>, como <code class=\"language-text\">let message = &quot;I am the walrus&quot;</code>. Acontece que podemos também atribuir uma variável para uma <em>função</em>, como <code class=\"language-text\">let sayHi = function() { }</code>. O que acontece depois de <code class=\"language-text\">=</code> é chamado de <em>expressão de função</em>. Retorna um valor especial (uma função) que representa nosso pedaço de código, então podemos chamar depois se quisermos.</li>\n<li><strong>Declaração de função</strong>: Fica cansativo escrever algo como <code class=\"language-text\">let sayHi = function() { }</code> toda vez, então podemos escrever de forma curta: <code class=\"language-text\">function sayHi() { }</code>. Isto é chamado de <em>declaração de função</em>. Em vez de especificar o nome da variável na esquerda, colocamos depois da palavra-chave <code class=\"language-text\">function</code>. Este dois estilos são praticamente iguais.</li>\n<li><strong>Hoisting de função</strong>: Normalmente, você só pode usar uma variável depois que sua declaração com <code class=\"language-text\">let</code>ou <code class=\"language-text\">const</code> ocorreu. Isso pode ser irritante com funções porque elas podem precisar chamar outra função e é dificil saber quais funções usam cada outra função para saber a ordem de definição. Por comodidade, quando (e apenas quando!) você usa a syntax de <em>declaração de função</em> a ordem dessas definições não importam, elas são “hoisted”. Este é um jeito de dizer que todas são automaticamente movidas ao topo do escopo.</li>\n<li><strong><code class=\"language-text\">this</code></strong>: Provavelmente o conceito mais incompreendido do JavaScript, <code class=\"language-text\">this</code> é como um argumento especial para uma função. Você não define isso manualmente e sim o JavaScript, dependendo de <em>como você chama</em> a função. Por exemplo, chama usando a notação de ponto <code class=\"language-text\">.</code>, como <code class=\"language-text\">iceCream.eat()</code> — vai receber um <code class=\"language-text\">this</code>especial de seja lá o que for antes do <code class=\"language-text\">.</code> (no nosso exemplo <code class=\"language-text\">iceCream</code>). O valor de <code class=\"language-text\">this</code> dentro de uma função depende de como a função é <em>chamada</em>, não onde é definida. Auxiliares como <code class=\"language-text\">.bind</code>, <code class=\"language-text\">.call</code> e <code class=\"language-text\">.apply</code> te deixa ter mais controle do valor do <code class=\"language-text\">this</code>.</li>\n<li><strong>Funcões Arrow</strong>: Funções arrow são simulares a expressões de função. Você declara como: <code class=\"language-text\">let sayHi = () =&gt; { }</code>. Elas são concisas e normalmente usadas para funções de uma linha. Funções arrow são <em>mais limitadas</em> que funções comuns — por exemplo, elas não possuem o conceito de <code class=\"language-text\">this</code>. Quando você escreve <code class=\"language-text\">this</code> dentro de uma função arrow é usado o <code class=\"language-text\">this</code> da função “comum” mais próxima. É parecido com o que aconteceria se você usasse um argumento ou variável que só existe numa função acima. Praticamente, isso significa que as pessoas usam funções arrow quando eles querem “ver” o mesmo <code class=\"language-text\">this</code> dentro assim como no código em volta.</li>\n<li><strong>Binding de função</strong>: Normalmente, <em>binding/ligando</em> uma função <code class=\"language-text\">f</code> para um certo valor <code class=\"language-text\">this</code> e argumentos, significa criar uma <em>nova</em> função que chama <code class=\"language-text\">f</code> com seus valores predefinidos. JavaScript tem um auxiliar embutido chamado <code class=\"language-text\">.bind</code>, você pode também fazer isso manualmente. Binding era um jeito popular de fazer funções aninhadas “verem” o mesmo valor de <code class=\"language-text\">this</code> que as funções externas. Mas agora este caso é resolvido com funções arrow, então binding não é usado com tanta frequência.</li>\n<li><strong>Pilha de chamadas</strong>: Chamar uma função é como entrar em uma sala. Toda vez que chamamos uma função, as variáveis internas são inicializadas de novo. Então cada chamada de função é como <em>construir</em> uma nova sala com seu código e entrar nela. Quando retornamos de uma função, essa “sala” desaparece com todas suas variáveis. Você pode visualizar essas salas como pilhas verticais de salas — uma <em>pilha de chamadas</em>. Quando saímos de uma função, vamos para função abaixo na pilha.</li>\n<li><strong>Recursão</strong>: Recursão significa que uma função chama ela mesmo. Isso é útil quando você quer <em>repetir</em> o que você acabou de fazer com sua função. Por exemplo, se você está escrevendo um programa de busca, que faz “crawls” na web, sua função <code class=\"language-text\">colletLinks(url)</code> deve primeiro coletar os links da página e então <em>chamar a si própria</em> para cada <em>link</em> até visitar todas as páginas. O problema com recursão é que é fácil escrever um código que nunca termina porque a função chama a si mesmo para sempre. Se isso acontecer, JavaScrpt vai parar com um erro chamado “stack overflow”. É chamado assim porque temos muitas chamadas na nossa pilha e então literalmente transborda.</li>\n<li><strong>Função Higher-Order</strong>: Uma função higher order (de ordem superior) é uma função que lida com outras funções ao recebe-las como argumento ou retornando elas. Isso pode parecer estranho no primeiro olhar, mas devemos lembrar que funções são valores, então podemos passar elas pra frente — como fazemos com números, strings ou objetos. Esse estilo pode ser usado em excesso, mas é muito expressivo em moderação.</li>\n<li><strong>Callback</strong>: Um callback não é realmente um termo do JavaScript. É mais como um padrão que acontece quando você passa uma função como argumento para outra função, esperando que isto <em>chame sua função depois</em>. Você está esperando um “call back”. Por exemplo, <code class=\"language-text\">setTimeout</code> recebe uma função <em>callback</em> e… chama depois de determinado tempo. Não há nada de especial com funções de callback, são funções comuns e quando dizemos “callbacks” estamos falando das nossas expectativas.</li>\n<li><strong>Fechamento</strong>: Normalmente quando você sai de uma função, todas suas variáveis “desaparecem”. Isso porque nada depende mais delas. E se você declara uma função <em>dentro</em> de uma função? Então a função interna ainda pode ser chamada depois e ler as variáveis da sua função externa. Em prática isso é muito útil, Mas para isso funcionar, as variáveis precisam “estarem por perto” em algum lugar. Então neste caso, JavaScript toma conta de “manter as variáveis vivas” em vez de “esquecer” como normalmente faz. Isso é chamado “fechamento”. Mesmo que fechamento é normalmente considerado um assunto incompreendido do JavaScript, você provavelmente usa várias vezes no dia sem perceber!</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>JavaScript é feito destes conceitos, e outros. Eu me sentia muito ansioso sobre o meu conhecimento de JavaScript até que pude construir o modelo mental correto e eu gostaria de ajudar a próxima geração de desenvolvedores preencher a lacuna mais rápido.</p>\n<p>Se você quer se aprofundar em cada um destes topicos, eu tenho algo para você. <strong><a href=\"https://justjavascript.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Just JavaScript</a> é o meu modelo mental de como JavaScript funciona e que vai conter ilustrações de <a href=\"https://illustrated.dev/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Maggie Appleton</a></strong>. Diferente deste post, vamos devagar e de maneira que você vai conseguir seguir cada detalhe.</p>\n<p><em>Just JavaScript</em> está em sua fase inicial, então apenas está disponível como uma série de emails sem nenhuma edição, você pode se <a href=\"https://justjavascript.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">inscrever</a> para receber rascunhos grátis por email. Serei grato pelo seu feedback. Obrigado!</p>","timeToRead":13,"frontmatter":{"title":"Do que JavaScript é feito?","date":"December 20, 2019","spoiler":"Desmistificando conceitos do JavaScript.","cta":null},"fields":{"slug":"/pt-br/what-is-javascript-made-of/","langKey":"pt-br"}}},"pageContext":{"slug":"/pt-br/what-is-javascript-made-of/","translations":["es","pt-br"],"translatedLinks":[]}}}
{"componentChunkName":"component---src-templates-blog-post-js","path":"/pt-br/why-do-we-write-super-props/","result":{"data":{"site":{"siteMetadata":{"title":"Overreacted","author":"Dan Abramov"}},"markdownRemark":{"id":"b6fb6600-3259-5620-8b05-b9552bf1df0a","html":"<p>Eu ouvi dizer que os <a href=\"https://reactjs.org/docs/hooks-intro.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Hooks</a> s√£o a nova moda. Ironicamente, eu quero come√ßar este blog listando fatos curiosos sobre os componentes de <em>classes</em>. Olha s√≥ para isso!</p>\n<p><strong>Essas pegadinhas <em>n√£o</em> s√£o importantes para o uso produtivo do React. Contudo, voc√™ pode ach√°-los interessantes se quiser se aprofundar em saber como essas coisas funcionam.</strong></p>\n<p>Eis a primeira.</p>\n<hr>\n<p>Eu j√° escrevi <code class=\"language-text\">super(props)</code> mais vezes na minha vida do que eu gostaria de ter feito:</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Claro, a <a href=\"https://github.com/tc39/proposal-class-fields\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">proposta de atributos de classe</a> nos permite pular toda essa cerim√¥nia.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Uma sintaxe como essa foi <a href=\"https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#es7-property-initializers\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">planejada</a> quando o React 0.13 passou a dar suporte a classes em 2015. Definir o <code class=\"language-text\">constructor</code> e invocar o <code class=\"language-text\">super(props)</code> desde sempre foi pensada como uma solu√ß√£o tempor√°ria at√© que os atributos das classes oferecessem uma alternativa mais ergon√¥mica.</p>\n<p>Mas vamos voltar para esse exemplo usando apenas as funcionalidades do ES2015:</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Por que n√≥s invocamos o <code class=\"language-text\">super</code>? N√≥s podemos <em>n√£o</em> invoc√°-lo? Se n√≥s tivermos que invoc√°-lo, o que acontece se n√≥s n√£o passarmos as <code class=\"language-text\">props</code>? Existe mais algum argumento?</strong> Vamos descobrir.</p>\n<hr>\n<p>No JavaScript, o <code class=\"language-text\">super</code> refere-se ao construtor da classe pai. (No nosso exemplo, ele refere-se √† implementa√ß√£o de <code class=\"language-text\">React.Component</code>.)</p>\n<p>√â importante lembrar que voc√™ n√£o pode usar o <code class=\"language-text\">this</code> em um construtor <em>at√©</em> que voc√™ tenha chamado o construtor pai. O JavaScript n√£o vai te deixar fazer isso:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// üî¥ Ainda n√£o podemos usar o `this`</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ‚úÖ Agora podemos</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Existe uma boa raz√£o do porqu√™ o JavaScript requer que o construtor pai seja executado antes que voc√™ mexa com o <code class=\"language-text\">this</code>. Considere essa hierarquia de classes:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">PolitePerson</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">greetColleagues</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// üî¥ Isso n√£o √© permitido, leia abaixo para saber o porqu√™</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">greetColleagues</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Good morning folks!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Suponha que usar o <code class=\"language-text\">this</code> antes de invocar o <code class=\"language-text\">super</code> <em>fosse</em> permitido. Um m√™s depois, n√≥s poder√≠amos alterar o m√©todo <code class=\"language-text\">greetColleagues</code> para incluir o nome da pessoa na mensagem:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">  <span class=\"token function\">greetColleagues</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Good morning folks!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'My name is '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">+</span> <span class=\"token string\">', nice to meet you!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>Mas n√≥s esquecemos que <code class=\"language-text\">this.greetColleagues()</code> √© invocado antes que a chamada do <code class=\"language-text\">super()</code> tivesse a chance de inicializar o <code class=\"language-text\">this.name</code>. Desse modo, <code class=\"language-text\">this.name</code> n√£o est√° sequer definido ainda! Como voc√™ pode ver, um c√≥digo como esse pode ser bem dif√≠cil de entender.</p>\n<p>Para evitar tais armadilhas, <strong>o JavaScript requer que, caso queira usar o <code class=\"language-text\">this</code> em um construtor, voc√™ <em>precisar√°</em> invocar o <code class=\"language-text\">super</code> primeiro.</strong> Deixe que o construtor pai fa√ßa as coisas dele. E essa limita√ß√£o tamb√©m √© aplicada em componentes do React definidas como classes:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ‚úÖ Tudo bem usar o `this` agora</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>Isso nos deixa com outra pergunta: por que passar as <code class=\"language-text\">props</code>?</p>\n<hr>\n<p>Voc√™ pode achar que passar as <code class=\"language-text\">props</code> como par√¢metro para o <code class=\"language-text\">super</code> √© necess√°rio para que o construtor base de <code class=\"language-text\">React.Component</code> possa inicializar o <code class=\"language-text\">this.props</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Dentro do React</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>E isso n√£o est√° longe de ser verdade - de fato, isto <a href=\"https://github.com/facebook/react/blob/1d25aa5787d4e19704c049c3cfa985d3b5190e0d/packages/react/src/ReactBaseClasses.js#L22\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">√© o que ele faz</a>.</p>\n<p>Mas de alguma forma, mesmo se voc√™ invocar o <code class=\"language-text\">super()</code> sem o argumento <code class=\"language-text\">props</code>, voc√™ ainda ser√° capaz de acessar o <code class=\"language-text\">this.props</code> no <code class=\"language-text\">render</code> e em outros m√©todos. (Se voc√™ n√£o acredita em mim, tente voc√™ mesmo!)</p>\n<p>Como <em>isso</em> funciona? Acontece que o <strong>React tamb√©m atribui as <code class=\"language-text\">props</code> na inst√¢ncia logo ap√≥s chamar o <em>seu</em> construtor:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">  <span class=\"token comment\">// Dentro do React</span>\n  <span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">YourComponent</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  instance<span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Ent√£o mesmo que voc√™ esque√ßa de passar as <code class=\"language-text\">props</code> para o <code class=\"language-text\">super</code>, o React ainda vai realizar a configura√ß√£o das mesmas logo em seguida. Existe um motivo para tal.</p>\n<p>Quando o React passou a dar suporte para classes, ele n√£o fez isso somente para as classes do ES6. O objetivo era dar suporte para o maior n√∫mero de abstra√ß√µes de classes que fosse poss√≠vel. <a href=\"https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#other-languages\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">N√£o estava claro</a> o qu√£o bem-sucedidos seriam ClojureScript, CoffeeScript, ES6, Fable, Scala.js, TypeScript ou outras solu√ß√µes para definir componentes. Ent√£o, o React intencionalmente n√£o tinha uma posi√ß√£o clara se era necess√°rio invocar o <code class=\"language-text\">super()</code> - ainda que isso fosse necess√°rio em classes do ES6.</p>\n<p>Ent√£o isso significa que voc√™ pode escrever somente <code class=\"language-text\">super()</code> ao inv√©s de <code class=\"language-text\">super(props)</code>?</p>\n<p><strong>Provavelmente n√£o, porque isso ainda deixaria as coisas confusas.</strong> De fato, o React em seguida iria inicializar o <code class=\"language-text\">this.props</code> <em>ap√≥s</em> a execu√ß√£o do seu construtor. Por√©m o <code class=\"language-text\">this.props</code> ainda estaria indefinido <em>entre</em> a invoca√ß√£o do <code class=\"language-text\">super</code> e o t√©rmino do seu construtor.</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Dentro do React</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Dentro do seu c√≥digo</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Button</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// üò¨ N√≥s esquecemos de passar as props</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">// ‚úÖ {}</span>\n<span class=\"gatsby-highlight-code-line\">    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// üò¨ undefined </span></span>  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Isso pode ser ainda mais complicado de depurar se ocorrer em algum m√©todo que √© invocado <em>de dentro</em> do construtor. <strong>E √© por isso que eu recomendo sempre usar o <code class=\"language-text\">super(props)</code>, mesmo que isso n√£o seja estritamente necess√°rio:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Button</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ‚úÖ N√≥s passamos as props</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">// ‚úÖ {}</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ‚úÖ {}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Isso garante que o <code class=\"language-text\">this.props</code> estar√° configurado antes do t√©rmino da execu√ß√£o do construtor.</p>\n<hr>\n<p>Existe um √∫ltimo ponto sobre o qual os usu√°rios mais antigos do React talvez estejam curiosos.</p>\n<p>Voc√™ deve ter percebido que quando voc√™ usa a API de Context em classes (seja com a antiga API <code class=\"language-text\">contextTypes</code> ou com a moderna <code class=\"language-text\">contextType</code>, que foi adicionada no React 16.6), o <code class=\"language-text\">context</code> √© passado como segundo argumento para o construtor.</p>\n<p>Ent√£o por que n√≥s n√£o escrevemos <code class=\"language-text\">super(props, context)</code>? N√≥s poder√≠amos, mas o contexto √© pouco usado, ent√£o essa armadilha n√£o aparece com a mesma frequ√™ncia.</p>\n<p><strong>Com a proposta de atributos de classe, essa armadilha praticamente desaparece de qualquer modo.</strong> Sem um construtor expl√≠cito, todos os argumentos s√£o passados automaticamente. √â isso que permite que uma express√£o como <code class=\"language-text\">state = {}</code> inclua refer√™ncias para <code class=\"language-text\">this.props</code> ou <code class=\"language-text\">this.context</code> se necess√°rio.</p>\n<p>Com os Hooks, n√≥s sequer temos <code class=\"language-text\">super</code> ou <code class=\"language-text\">this</code>. Mas isso √© conversa para outro dia.</p>","timeToRead":5,"frontmatter":{"title":"Por Que N√≥s Escrevemos super(props)?","date":"November 30, 2018","spoiler":"There‚Äôs a twist at the end.","cta":null},"fields":{"slug":"/pt-br/why-do-we-write-super-props/","langKey":"pt-br"}}},"pageContext":{"slug":"/pt-br/why-do-we-write-super-props/","translations":["cs","de","es","fa","fr","hu","it","my","ja","nl","nb","pl","pt-br","sk","sr","th","tr","uk","vi","zh-hans","zh-hant"],"translatedLinks":[]}}}
{"componentChunkName":"component---src-templates-blog-post-js","path":"/zh-hant/optimized-for-change/","result":{"data":{"site":{"siteMetadata":{"title":"Overreacted","author":"Dan Abramov"}},"markdownRemark":{"id":"74031cc3-0b2c-5525-aaab-e1115af97e85","html":"<p>什麼造就了一個優秀的 API ?</p>\n<p><em>好</em>的 API 設計是容易記憶且不模糊的。他促進易讀、正確且高效能的程式碼，且幫助開發者掉進<a href=\"https://blog.codinghorror.com/falling-into-the-pit-of-success/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">「the pit of success」</a>。</p>\n<p>我稱這些設計為「第一層級」，因為他們是一個函式庫開發者第一個傾向於專注的事。你也許必須對他們其中一些妥協且權衡利弊，但至少他們永遠在你的心中。</p>\n<p>然而，除非你要送一個探測器到火星，你的程式碼將可能會隨著時間而改變。同樣地，你的 API 使用者的程式碼也是。</p>\n<p>我所認識的最好的 API 設計師們不停止於「第一層級」，例如可讀性。他們盡可能花力氣致力於那些我們稱之為「第二層級」API 設計上面：<strong>使用這個 API 的程式碼將如何隨時間演化。</strong></p>\n<p>一個些微的需求改變可以讓最優雅簡潔的程式碼支離破碎。</p>\n<p><em>優秀</em>的 API 預期他會發生。他們預期你會想要移動一些程式碼、將一部分複製與貼上 、重新命名他、統整特殊案例進一個通用且可重複使用的 helper 、解構抽象回一些實際案例、加一個 hack 、優化一個瓶頸、拋棄一部分程式碼並重寫、犯了一個錯、在原因和效果之間徘徊、修正了一個 bug 、審查這個修正。</p>\n<p>優秀的 API 不只讓你掉進 pit of success，他幫助你<em>停留</em>在那裡。</p>\n<p>他們為改變而優化。</p>","timeToRead":1,"frontmatter":{"title":"為改變而優化","date":"December 12, 2018","spoiler":"什麼造就了一個優秀的 API ?","cta":null},"fields":{"slug":"/zh-hant/optimized-for-change/","langKey":"zh-hant"}}},"pageContext":{"slug":"/zh-hant/optimized-for-change/","translations":["ar","es","bg","de","fa","fr","he","id","nl","pl","ru","pt-br","tr","uk","zh-hant","zh-hans"],"translatedLinks":[]}}}
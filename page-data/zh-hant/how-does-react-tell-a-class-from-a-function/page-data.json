{"componentChunkName":"component---src-templates-blog-post-js","path":"/zh-hant/how-does-react-tell-a-class-from-a-function/","result":{"data":{"site":{"siteMetadata":{"title":"Overreacted","author":"Dan Abramov"}},"markdownRemark":{"id":"a039d712-3a59-5245-9414-b75a3c12a8f3","html":"<p>看看這個被定義為函式的 <code class=\"language-text\">Greeting</code> 元件：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>React 也支援把它定義為類別：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Greeting</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>（直到 最近 <a href=\"https://reactjs.org/docs/hooks-intro.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">hooks</a> 的出現，這是唯一能使用像是 state 功能的方法。）</p>\n<p>當你想要繪製（render）一個 <code class=\"language-text\">&lt;Greeting /&gt;</code> 時，你不需要煩惱這個元件是如何被定義的：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 類別或函式 — 隨意。</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Greeting</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n<p>但是 <em>React 本身</em> 在乎這兩者的不同！</p>\n<p>如果 <code class=\"language-text\">Greeting</code> 是一個函式, React 需要呼叫它：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 你的程式碼</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// React 內</span>\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &lt;p>Hello&lt;/p></span></code></pre></div>\n<p>但如果 <code class=\"language-text\">Greeting</code> 是一個類別，React 需要用 <code class=\"language-text\">new</code> 運算符實現出它的實例，<em>再</em> 呼叫剛才創建的實例中的 <code class=\"language-text\">render</code> 方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 你的程式碼</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Greeting</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// React 內</span>\n<span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Greeting {}</span>\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> instance<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &lt;p>Hello&lt;/p></span></code></pre></div>\n<p>在上述兩種情境中，React 的目的是拿到繪製過的節點（在這例子中是<code class=\"language-text\">&lt;p&gt;Hello&lt;/p&gt;</code>），但是確切的步驟取決於 <code class=\"language-text\">Greeting</code> 是如何被定義的。</p>\n<p><strong>所以 React 是如何知道這個元件是類別還是函式？</strong></p>\n<p>正如我 <a href=\"/why-do-we-write-super-props/\">上一篇文章</a>所說的，<strong>你 <em>不需要</em> 知道這個也能夠有效使用 React，</strong>我多年以來也都不知道這兩者的差別。請不要把這變成一道面試題。事實上，這篇文章與其說是討論 React 的運作，更多的是討論 JavaScript 如何運作。</p>\n<p>這個部落格是給想要知道 <em>為什麽</em> React 是以這種方式運作而感到好奇的讀者。你是這種人嗎？那讓我們一起鑽研吧。</p>\n<p><strong>這是一段漫長的旅程，繫好安全帶了。這篇文章並不會討論太多關於 React 本身的資訊。相反的，我們會討論 <code class=\"language-text\">new</code>、<code class=\"language-text\">this</code>、<code class=\"language-text\">class</code>、箭頭函式、<code class=\"language-text\">prototype</code>、<code class=\"language-text\">__proto__</code>、<code class=\"language-text\">instanceof</code> 的某些面向，還有這些東西是如何在 JavaScript 中協同運作的。幸運的是，當你 <em>使用</em> React 時你不必考慮那麼多。不過如果你正在實做 React 的話…</strong></p>\n<p>（如果你真的只想知道答案的話，直接看最後一段。）</p>\n<hr>\n<p>首先，我們需要理解為什麼以不同的方式處理函式跟類別是很重要的。注意我們在呼叫類別時是如何使用 <code class=\"language-text\">new</code> 運算符：</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 如果 Greeting 是個函式</span>\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &lt;p>Hello&lt;/p></span>\n\n<span class=\"token comment\">// 如果 Greeting 是個類別</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Greeting {}</span></span><span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> instance<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &lt;p>Hello&lt;/p></span></code></pre></div>\n<p>讓我們看看 <code class=\"language-text\">new</code> 運算符在 JavaScript 中大致上有什麼作用。</p>\n<hr>\n<p>以前 JavaScript 是沒有類別的。然而，你可以直接用函式表達類似類別的模式。說得更具體一點，你可以用 <em>任何</em> 函式扮演類似類別的建構子，你只要在呼叫函式前加上 <code class=\"language-text\">new</code> 就可以了：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 只是個函式</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ Person {name: 'Fred'}</span>\n<span class=\"token keyword\">var</span> george <span class=\"token operator\">=</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'George'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 🔴 不行</span></code></pre></div>\n<p>你到今天仍然能寫這樣的程式碼！在 DevTools 中試試看。</p>\n<p>如果你呼叫 <code class=\"language-text\">Person(&#39;Fred&#39;)</code> 時<strong>缺少了</strong> <code class=\"language-text\">new</code>，在這之間的 <code class=\"language-text\">this</code> 會指向某個全域而無用的東西（例如，<code class=\"language-text\">window</code> 或 <code class=\"language-text\">undefined</code>）。所以我們的程式碼將會異常終止，或是做一些像設置 <code class=\"language-text\">window.name</code> 的蠢事。</p>\n<p>藉由在呼叫前增加 <code class=\"language-text\">new</code>，我們告訴 JavaScript 說：「嘿 JavaScript，我知道 <code class=\"language-text\">Person</code> 只是一個函式，但讓我們假裝它就像一個類別的建構子，<strong>創建一個 <code class=\"language-text\">{}</code> 物件並且將 <code class=\"language-text\">Person</code> 函式內部的 <code class=\"language-text\">this</code> 指向這個物件，這樣我就能設置 <code class=\"language-text\">this.name</code> 之類的東西了。然後把這個物件回傳給我。</strong>」</p>\n<p>這就是 <code class=\"language-text\">new</code> 運算符做的事。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">var</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 與 `Person` 內的 `this` 相同的物件</span></code></pre></div>\n<p><code class=\"language-text\">new</code> 運算符也可以創建出我們放在 <code class=\"language-text\">Person.prototype</code> 上的任何東西到 <code class=\"language-text\">fred</code> 物件上：</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token class-name\">Person</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">sayHi</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span></span><span class=\"gatsby-highlight-code-line\">  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hi, I am '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\"><span class=\"token punctuation\">}</span></span>\n<span class=\"token keyword\">var</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"gatsby-highlight-code-line\">fred<span class=\"token punctuation\">.</span><span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span></code></pre></div>\n<p>這就是大家在 JavaScript 直接增加類別之前模擬它的方式。</p>\n<hr>\n<p>所以 <code class=\"language-text\">new</code> 已經在 JavaScript 中存在了一段時間。然而，類別是最近才有的。它讓我們能更貼近我們意圖地重寫上述的程式碼：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hi, I am '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nfred<span class=\"token punctuation\">.</span><span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>在程式語言和 API 設計中，<em>抓住開發者的意圖</em> 是重要的。</p>\n<p>如果你使用函式，JavaScript 會無法猜測它是否該被呼叫（如 <code class=\"language-text\">alert()</code> ），或是它是被用來當成一個建構子（ 如<code class=\"language-text\">new Person()</code>）。而如果你忘記在的函式前指定 <code class=\"language-text\">new</code>（像是 <code class=\"language-text\">Person</code>），這亦會導致程式出現令人困惑的異常行為。</p>\n<p><strong>類別語法讓我們能表示：「這不只是一個函式 —— 他是一個類別，而且有建構子。」</strong>如果你在呼叫它時忘記用 <code class=\"language-text\">new</code>，JavaScript 將會提出錯誤：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ✅  如果 Person 是一個函式： 沒問題</span>\n<span class=\"token comment\">// ✅  如果 Person 是一個類別： 也沒問題</span>\n\n<span class=\"token keyword\">let</span> george <span class=\"token operator\">=</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'George'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 我們忘記 `new` 了</span>\n<span class=\"token comment\">// 😳 如果 Person 是一個像建構子的函式：令人困惑的行為</span>\n<span class=\"token comment\">// 🔴 如果 Person 是一個類別：直接失敗</span></code></pre></div>\n<p>這有助於我們儘早發現錯誤，而不是等待一些晦澀費解的錯誤發生，例如 <code class=\"language-text\">this.name</code> 被當成 <code class=\"language-text\">window.name</code> 而不是 <code class=\"language-text\">george.name</code>。</p>\n<p>然而，這意味著 React 需要在呼叫任何類別之前寫 <code class=\"language-text\">new</code>，它不能只是將它當作一般的函式呼叫，因為 JavaScript 會將其視為一個錯誤！</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Counter</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 🔴 React 不能這樣做：</span>\n<span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> <span class=\"token function\">Counter</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>這會帶來麻煩。</p>\n<hr>\n<p>在我們探討 React 如何解決這個問題前，重要的是要記得大多數 React 的開發者會使用如 Babel 的編譯器來編譯最新的功能，比如對舊版瀏覽器支援類別的使用。所以我們需要在我們的設計中考慮到有編譯器的狀況。</p>\n<p>在 Babel 早期的版本，類別可以在沒有指名 <code class=\"language-text\">new</code> 的情況下被呼叫，然而，這已經被修正了 ——  藉由產生一些額外的程式碼：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 稍微簡化從 Babel 的輸出</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TypeError</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Cannot call a class as a function\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// 我們的程式碼：</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ 沒問題</span>\n<span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'George'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 🔴 無法像呼叫函式般呼叫一個類別</span></code></pre></div>\n<p>你可能在捆綁包中看過這樣的程式碼，這全是 <code class=\"language-text\">_classCallCheck</code> 函式所做的事。（你可以藉由選擇不進行檢查的「鬆散模式（loose mode）」來減少捆綁包大小，但這可能會使你最終轉換為原生的類別變得複雜。）</p>\n<hr>\n<p>目前為止，你應該對用 <code class=\"language-text\">new</code> 或不用 <code class=\"language-text\">new</code> 呼叫某些東西之間的差別有一個大致的理解：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th><code class=\"language-text\">new Person()</code></th>\n<th><code class=\"language-text\">Person()</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">class</code></td>\n<td>✅ <code class=\"language-text\">this</code> 是 <code class=\"language-text\">Person</code> 的實例</td>\n<td>🔴 <code class=\"language-text\">TypeError</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">function</code></td>\n<td>✅ <code class=\"language-text\">this</code> 是 <code class=\"language-text\">Person</code> 的實例</td>\n<td>😳 <code class=\"language-text\">this</code> 是 <code class=\"language-text\">window</code> 或 <code class=\"language-text\">undefined</code></td>\n</tr>\n</tbody>\n</table>\n<p>這就是為什麼正確地呼叫你的元件對 React 來說是極為重要的。<strong>如果你的元件被定義為類別，React 便需要在呼叫時使用 <code class=\"language-text\">new</code>。</strong></p>\n<p>所以 React 光是透過檢查就能確認某個元件是不是類別嗎？</p>\n<p>沒那麼容易！即使我們可以 <a href=\"https://stackoverflow.com/questions/29093396/how-do-you-check-the-difference-between-an-ecmascript-6-class-and-function\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">在 JavaScript 函式中區別出類別</a>，這仍然不適用於被像是 Babel 這樣的工具處理過的類別。對於瀏覽器而言，它們就只是單純的函式。對 React 來說真是倒楣。</p>\n<hr>\n<p>好吧，所以或許 React 可以在每次呼叫時使用 <code class=\"language-text\">new</code>？不幸的是，這也不見得總是奏效。</p>\n<p>在一般的函式中用 <code class=\"language-text\">new</code> 來呼叫它們，會給它們一個物件實例當作是 <code class=\"language-text\">this</code>。這對於寫成建構子的函式（像上述的 <code class=\"language-text\">Person</code>）是合適的，但它對函式元件而言是很混亂的：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 我們不會期望 `this` 在這裡是任何一種實例。</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>但這種情況還算可以忍受的。這裡有兩個 <em>其他</em> 可以扼殺這個想法的理由。</p>\n<hr>\n<p>第一個為什麼使用 <code class=\"language-text\">new</code> 不總是奏效的理由，是使用 <code class=\"language-text\">new</code> 呼叫原生（不是被 Babel 編譯過）的箭頭函式（Arrow function）會拋出一個錯誤：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Greeting</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 🔴 Greeting is not a constructor</span></code></pre></div>\n<p>這種行為是刻意的，並且遵循箭頭函數的設計。箭頭函式的主要優點之一是它們 <em>沒有</em> 自己的 <code class=\"language-text\">this</code> 值。 <code class=\"language-text\">this</code> 是從最靠近自身的一般函式決定的：</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Friends</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span></span>    <span class=\"token keyword\">const</span> friends <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>friends<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> friends<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">friend</span> <span class=\"token operator\">=></span>\n      <span class=\"token operator\">&lt;</span>Friend\n<span class=\"gatsby-highlight-code-line\">        <span class=\"token comment\">// `this` 是從 `render` 方法中決定的</span></span><span class=\"gatsby-highlight-code-line\">        size<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">}</span></span>        name<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>friend<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span>\n        key<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>friend<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">}</span>\n      <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>好的，所以<strong>箭頭函式是沒有自己的 <code class=\"language-text\">this</code> 值的，</strong>但這意味著拿它們當作建構子是完全沒有作用的！</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Person</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 🔴 這樣不合理！</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>因此，<strong>JavaScript 不允許使用 <code class=\"language-text\">new</code> 呼叫一個箭頭函式。</strong>如果你這麼做的話，你無論如何都會產生一個錯誤，這件事最好早點告訴你。這跟 JavaScript 不讓你在 <em>沒有</em> <code class=\"language-text\">new</code> 時呼叫一個類別的情況類似。</p>\n<p>這個行為很棒，但同時也搞雜了我們的計劃，React 不能僅僅對所有的東西呼叫 <code class=\"language-text\">new</code>，因為它違背了箭頭函式！我們也許能試著透過箭頭函式缺少 <code class=\"language-text\">prototype</code> 的特性來特別偵測出它們，並且只不 <code class=\"language-text\">new</code> 它們：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>prototype <span class=\"token comment\">// undefined</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>prototype <span class=\"token comment\">// {constructor: f}</span></code></pre></div>\n<p>但這對被 Babel 編譯過的函式 <a href=\"https://github.com/facebook/react/issues/4599#issuecomment-136562930\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">不奏效</a>。這或許不是什麼大問題，但是還有另一個理由能使這種方法走向一條死路。</p>\n<hr>\n<p>另一個我們不能總是使用 <code class=\"language-text\">new</code> 的理由，是它會阻隔 React 拿到從那些支援回傳字串或其他基本型態的元件。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">'Hello'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ 'Hello'</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 😳 Greeting {}</span></code></pre></div>\n<p>又來，這再次與 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">new</code> 運算符</a> 的古怪設計有關，正如我們之前看到的，<code class=\"language-text\">new</code> 告訴 JavaScript 引擎創建一個物件，在內部創建一個 <code class=\"language-text\">this</code> 物件，然後將這個物件當作 <code class=\"language-text\">new</code> 的結果回給我們。</p>\n<p>然而，JavaScript 還允許被 <code class=\"language-text\">new</code> 呼叫的函式藉由回傳其他物件來 <em>覆蓋</em> 它的回傳值，根據推測，這被認為對於如果我們想要用池化來重用實例，這樣的模式會很有用：</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"gatsby-highlight-code-line\"><span class=\"token comment\">// 懶創建</span></span><span class=\"gatsby-highlight-code-line\"><span class=\"token keyword\">var</span> zeroVector <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Vector</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">,</span> y</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">===</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> y <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>zeroVector <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">      <span class=\"token comment\">// 重用相同的實例</span></span><span class=\"gatsby-highlight-code-line\">      <span class=\"token keyword\">return</span> zeroVector<span class=\"token punctuation\">;</span></span>    <span class=\"token punctuation\">}</span>\n    zeroVector <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>x <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>y <span class=\"token operator\">=</span> y<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vector</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vector</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\"><span class=\"token keyword\">var</span> c <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vector</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 😲 b === c</span></span></code></pre></div>\n<p>然而，如果一個函式的回傳值 <em>不是</em> 一個物件， <code class=\"language-text\">new</code> 會 <em>完全忽略</em> 它，就是說如果你回傳字串或是數字，它會像根本沒有回傳一樣。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Answer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">Answer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ 42</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Answer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 😳 Answer {}</span></code></pre></div>\n<p>所以這裡根本沒有辦法當函式被用 <code class=\"language-text\">new</code> 呼叫時，讀到它原本的回傳值（像是數字或字串）。因此，如果 React 總是使用 <code class=\"language-text\">new</code> 來呼叫函式，它將會無法增加那些回傳字串的元件的支援！</p>\n<p>這無法接受，我們勢必得妥協。</p>\n<hr>\n<p>到目前為止我們學到了什麼？React 必須 <em>用</em> <code class=\"language-text\">new</code> 呼叫類別（包含 Babel 的輸出），但必須 <em>不用</em> <code class=\"language-text\">new</code> 呼叫一般的函式（包含 Babel 的輸出）或是箭頭函式，而且並沒有可靠的方法區別它們。</p>\n<p><strong>如果我們解決不了一般性的問題，那我們能否解決比較特定的問題？</strong></p>\n<p>當你將元件定義一個類別時，你可能想要為了 <code class=\"language-text\">this.setState()</code> 這樣的預設方法去擴展 <code class=\"language-text\">React.Component</code>，<strong>跟試著檢查所有類別相比，我們能否只偵測 <code class=\"language-text\">React.Component</code> 的子孫？</strong></p>\n<p>劇透：這正是 React 所做的。</p>\n<hr>\n<p>或許，檢查 <code class=\"language-text\">Greeting</code> 是不是 React 元件的慣用方法，是測試是否 <code class=\"language-text\">Greeting.prototype instanceof React.Component</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">B</span><span class=\"token punctuation\">.</span>prototype <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span></code></pre></div>\n<p>我知道你在想什麼，剛剛發生什麼事！？要回答這個問題，我們需要了解 JavaScript 的原型（prototype）。</p>\n<p>你可以常聽到「原型鏈（prototype chain）」，在 JavaScript 中，所有的物件都應該有一個「原型」。當我們寫 <code class=\"language-text\">fred.sayHi()</code> 而沒有 <code class=\"language-text\">sayHi</code> 屬性時，我們會從 <code class=\"language-text\">fred</code> 物件的原型中尋找 <code class=\"language-text\">sayHi</code> 屬性。如果我們在那裡找不到，我們會看看鏈中的下一個原型 — <code class=\"language-text\">fed</code> 原型的原型，以此類推。</p>\n<p><strong>令人費解的是，一個類別或函式的 <code class=\"language-text\">prototype</code> 屬性 <em>並不會</em> 指向該值的原型。</strong>我不是在開玩笑。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Person</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 🤪 不是 Person 的原型</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Person<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 😳 Person 的原型</span></code></pre></div>\n<p>所以「原型鏈」比較像是 <code class=\"language-text\">__proto__.__proto__.__proto__</code> 而不是 <code class=\"language-text\">prototype.prototype.prototype</code>，這我花了多年才理解。</p>\n<p>那麼在函式或是類別上的 <code class=\"language-text\">prototype</code> 屬性是什麼？<strong>它是提供給所有被類別或函式 <code class=\"language-text\">new</code> 過的物件的 <code class=\"language-text\">__proto__</code>！</strong></p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">Person</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">sayHi</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hi, I am '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"gatsby-highlight-code-line\"><span class=\"token keyword\">var</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 把 `fred.__proto__` 設成 `Person.prototype`</span></span></code></pre></div>\n<p>然而 <code class=\"language-text\">__proto__</code> 鏈就是 JavaScript 找屬性的方式：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">fred<span class=\"token punctuation\">.</span><span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 1. fred 有 sayHi 屬性嗎？ 沒有。</span>\n<span class=\"token comment\">// 2. fred.__proto__ 有 sayHi 屬性嗎？有。呼叫它！</span>\n\nfred<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 1. fred 有 toString 屬性嗎？ 沒有。</span>\n<span class=\"token comment\">// 2. fred.__proto__ 有 toString 屬性嗎？ 沒有。</span>\n<span class=\"token comment\">// 3. fred.__proto__.__proto__ 有 toString 屬性嗎？ 有。呼叫它！</span></code></pre></div>\n<p>在實務上，除非你在除原型鏈相關的錯誤，否則你幾乎不需要直接在程式碼中碰到 <code class=\"language-text\">__proto__</code>，如果你想在 <code class=\"language-text\">fed.__proto__</code> 提供東西的話，你應該把它放在 <code class=\"language-text\">Person.prototype</code>，至少它原先是這麼被設計的。</p>\n<p>起初， <code class=\"language-text\">__proto__</code> 屬性甚至不應該被瀏覽器曝露的，因為原型鏈被視為是內部的概念，但是有些瀏覽器添加了 <code class=\"language-text\">__proto__</code>，最終它勉為其難地被標準化了（但已經被棄用了，取而代之的是 <code class=\"language-text\">Object.getPrototypeOf()</code>）。</p>\n<p><strong>然而，我仍然覺得一個被稱為 <code class=\"language-text\">prototype</code> 的屬性並沒有提供給你該值的原型而感到非常的困惑</strong>（舉例來說，<code class=\"language-text\">fred.prototype</code> 未被定義是因為 <code class=\"language-text\">fred</code> 不是一個函式）。對我而言，我認為這個即使是經驗豐富的開發者也會誤解 JavaScript 原型最大的原因。</p>\n<hr>\n<p>這是一篇很長的貼文，你說是吧？我們在這已經 8 成，稍等一會兒。</p>\n<p>當我們提到 <code class=\"language-text\">obj.foo</code>，我們已經知道 JavaScript 實際上會在 <code class=\"language-text\">obj</code>，<code class=\"language-text\">obj.__proto__</code>，<code class=\"language-text\">obj.__proto__.__proto__</code> 尋找 <code class=\"language-text\">foo</code>，以此類推。</p>\n<p>在類別中，你不會直接被曝露這個機制，不過 <code class=\"language-text\">extends</code> 也是在這個經典的原型鏈上運作，這就是我們 React 類別的實例如何取得像是 <code class=\"language-text\">setState</code> 方法的方式：</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"gatsby-highlight-code-line\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Greeting</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span></span>  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> c <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Greeting.prototype</span>\n<span class=\"gatsby-highlight-code-line\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// React.Component.prototype</span></span>console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Object.prototype</span>\n\nc<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">// 在 c.__proto__ (Greeting.prototype) 找到</span>\n<span class=\"gatsby-highlight-code-line\">c<span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 在 c.__proto__.__proto__ (React.Component.prototype) 找到</span></span>c<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 在 c.__proto__.__proto__.__proto__ (Object.prototype) 找到</span></code></pre></div>\n<p>換句話說，<strong>當你在用類別的時候，一個實例的 <code class=\"language-text\">__proto__</code> 鏈會「鏡像於」類別的階層結構：</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// `extends` 鏈</span>\nGreeting\n  → React<span class=\"token punctuation\">.</span>Component\n    → <span class=\"token function\">Object</span> <span class=\"token punctuation\">(</span>隱藏的<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// `__proto__` 鏈</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  → <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">.</span>prototype\n    → React<span class=\"token punctuation\">.</span><span class=\"token class-name\">Component</span><span class=\"token punctuation\">.</span>prototype\n      → <span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype</code></pre></div>\n<p>兩個鏈，<a href=\"https://twitter.com/2chainz\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">2 Chainz</a>。</p>\n<hr>\n<p>因為 <code class=\"language-text\">__proto__</code> 鏈反映了類別的階層結構，我們可以從 <code class=\"language-text\">Greeting.prototype</code> 開始，隨著 <code class=\"language-text\">__proto__</code> 鏈往下檢查，是否一個 <code class=\"language-text\">Greeting</code> 擴展了 <code class=\"language-text\">React.Component</code>：</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// `__proto__` chain</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"gatsby-highlight-code-line\">  → <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">.</span>prototype <span class=\"token comment\">// 🕵️ 我們從這裡開始</span></span><span class=\"gatsby-highlight-code-line\">    → React<span class=\"token punctuation\">.</span><span class=\"token class-name\">Component</span><span class=\"token punctuation\">.</span>prototype <span class=\"token comment\">// ✅ 找到了！</span></span>      → <span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype</code></pre></div>\n<p>便利上來說，<code class=\"language-text\">x instanceof Y</code> 正好做了這種搜尋，它隨著 <code class=\"language-text\">x.__proto__</code> 鏈尋找在那裡尋找 <code class=\"language-text\">Y.prototype</code>。</p>\n<p>通常，這被拿來判斷是否某個東西是不是一個類別的實例：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> greeting <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>greeting <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n<span class=\"token comment\">// greeting （🕵️‍ 我們從這裡開始）</span>\n<span class=\"token comment\">//   .__proto__ → Greeting.prototype （✅ 找到了！）</span>\n<span class=\"token comment\">//     .__proto__ → React.Component.prototype</span>\n<span class=\"token comment\">//       .__proto__ → Object.prototype</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>greeting <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n<span class=\"token comment\">// greeting （‍🕵 我們從這裡開始）</span>\n<span class=\"token comment\">//   .__proto__ → Greeting.prototype</span>\n<span class=\"token comment\">//     .__proto__ → React.Component.prototype （✅ 找到了！）</span>\n<span class=\"token comment\">//       .__proto__ → Object.prototype</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>greeting <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n<span class=\"token comment\">// greeting （‍🕵 我們從這裡開始）</span>\n<span class=\"token comment\">//   .__proto__ → Greeting.prototype</span>\n<span class=\"token comment\">//     .__proto__ → React.Component.prototype</span>\n<span class=\"token comment\">//       .__proto__ → Object.prototype （✅ 找到了！）</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>greeting <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Banana</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\n<span class=\"token comment\">// greeting （‍🕵 我們從這裡開始）</span>\n<span class=\"token comment\">//   .__proto__ → Greeting.prototype</span>\n<span class=\"token comment\">//     .__proto__ → React.Component.prototype</span>\n<span class=\"token comment\">//       .__proto__ → Object.prototype（🙅‍ 沒有找到！）</span></code></pre></div>\n<p>而它也可以用來對判斷一個類別是否擴展另一個類別：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">.</span>prototype <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// greeting</span>\n<span class=\"token comment\">//   .__proto__ → Greeting.prototype （‍🕵 我們從這裡開始）</span>\n<span class=\"token comment\">//     .__proto__ → React.Component.prototype （✅ 找到了！）</span>\n<span class=\"token comment\">//       .__proto__ → Object.prototype</span></code></pre></div>\n<p>然而，這就是我們如何判斷東西是一個 React 元件的類別還是一個一般函式的方法。</p>\n<hr>\n<p>雖然這不是 React 的作法。😳</p>\n<p>有一個對用 <code class=\"language-text\">instanceof</code> 解法的警告，是它在有多個 React 複製品的網頁不奏效，我們會用到 <em>另一個</em> React 複製品的 <code class=\"language-text\">React.Component</code> 來檢查元件的繼承關係。有一些的原因說明了單一專案混雜了多個 React 的複製品是不好的，但在歷史上我們已盡可能避免出現這樣的問題。（在 Hook 中，我們 <a href=\"https://github.com/facebook/react/issues/13991\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">可能需要</a> 強制將複製品刪除。）</p>\n<p>另外一種可行的想法或許可以檢查原型中是否存在 <code class=\"language-text\">render</code> 方法，然而在當時我們 <a href=\"https://github.com/facebook/react/issues/4599#issuecomment-129714112\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">並不清楚</a> 元件的 API 將會如何包裝，而每一種檢查方式都有成本，所以我們也不希望添加超過一種的檢查，還有這種方法如果 <code class=\"language-text\">render</code> 沒有定義為實例方法也不適用，例如類別屬性的語法。</p>\n<p>所以取而代之的是，React 在底層元件中 <a href=\"https://github.com/facebook/react/pull/4663\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">添加了</a> 一個特殊的標記，React 會透過檢查這個標記是否存在，來判斷東西是不是 React 元件的方法，就是這樣。</p>\n<p>最初，這個標記是位於底層的 <code class=\"language-text\">React.Component</code> 類別本身：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// React 內</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nComponent<span class=\"token punctuation\">.</span>isReactClass <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 我們能像這樣檢查它</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Greeting</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Greeting<span class=\"token punctuation\">.</span>isReactClass<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ Yes</span></code></pre></div>\n<p>然而，在有些我們的目標的類別實作 <a href=\"https://github.com/scala-js/scala-js/issues/1900\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">沒有</a> 複製靜態的屬性（或設置非標準的 <code class=\"language-text\">__proto__</code>），所以這個標記不見了。</p>\n<p>這就是為什麽 React 把標記 <a href=\"https://github.com/facebook/react/pull/5021\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">移動</a> 到了 <code class=\"language-text\">React.Component.prototype</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// React 內</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">Component</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>isReactComponent <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 我們能像這樣檢查</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Greeting</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>isReactComponent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ Yes</span></code></pre></div>\n<p><strong>而這就是實際上關於它全部的內容。</strong></p>\n<p>你可能會疑惑為什麼標記是物件而不是布林值，實作上它是什麽並不重要，但在早年版本的 Jest（在 Jest 是 Good™️ 之前）預設會將自動模仿（automocking）打開，生成的模仿物省略了原生的屬性，<a href=\"https://github.com/facebook/react/pull/4663#issuecomment-136533373\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">破壞了檢查</a>。謝了，Jest。</p>\n<p>截至今日，這個 <code class=\"language-text\">isReactComponent</code> 檢查仍 <a href=\"https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/react-reconciler/src/ReactFiber.js#L297-L300\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">在 React 中被使用</a>。</p>\n<p>如果你沒有擴展 <code class=\"language-text\">React.Component</code>，React 在原型中會找不到 <code class=\"language-text\">isReactComponent</code>，進而不會把元件當成一個類別。現在你知道為何發生 <code class=\"language-text\">Cannot call a class as a function</code> 錯誤 <a href=\"https://stackoverflow.com/a/42680526/458193\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">最受歡迎的解答</a> 是加 <code class=\"language-text\">extends React.Component</code> 了。最後，<a href=\"https://stackoverflow.com/a/42680526/458193\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">增加了一個警告</a>，是會在 <code class=\"language-text\">prototype.render</code> 存在，而 <code class=\"language-text\">prototype.isReactComponent</code> 不存在時發出警告。</p>\n<hr>\n<p>你可能會說這篇故事有點誘導推銷（bait-and-switch）。<strong>實際上的答案其實非常簡單，但我卻用大量離題的事來 <em>解釋</em> 為什麼 React 到最後會用這個解法，以及替代方案是什麼。</strong></p>\n<p>以我的經驗，函式庫 API 通常就是這種情況，為了使 API 易於使用，你常常需要去考慮程式語言的語意（對於很多種程式語言可能還需要考慮未來的走向）、運行效能、在有或沒有編譯階段時的的人體工學、生態系以及包裝解法的現狀、預先的警告、和其他很多東西，最後的結果可能不會總是那麼優雅，但它一定可行。</p>\n<p><strong>如果最終 API 是可行的，<em>它的使用者</em> 就永遠不必去思考其中的過程，</strong>反而他們能專注於創造應用程式。</p>\n<p>但如果你也充滿好奇心…，知道它如何運作也不錯。</p>","timeToRead":17,"frontmatter":{"title":"React 如何從函式（Function）中區分出類別（Class）？","date":"December 02, 2018","spoiler":"我們談論關於類別、new、instanceof、原型鏈（prototype chains）、和 API 設計。","cta":null},"fields":{"slug":"/zh-hant/how-does-react-tell-a-class-from-a-function/","langKey":"zh-hant"}}},"pageContext":{"slug":"/zh-hant/how-does-react-tell-a-class-from-a-function/","translations":["es","fr","hu","ja","nl","pt-br","sk","zh-hans","zh-hant"],"translatedLinks":["/why-do-we-write-super-props/"]}}}
{"componentChunkName":"component---src-templates-blog-post-js","path":"/zh-hant/why-do-we-write-super-props/","result":{"data":{"site":{"siteMetadata":{"title":"Overreacted","author":"Dan Abramov"}},"markdownRemark":{"id":"2c73bc50-0068-57f2-86a6-dfa1841ca5eb","html":"<p>我聽說 <a href=\"https://reactjs.org/docs/hooks-intro.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Hooks</a> 正夯， 但我想要從談論 <em>class</em> 有趣的小知識來開始這個部落格。如何？</p>\n<p><strong>這些解釋對於有效地使用 React 並<em>不</em>重要，但對於喜歡深入了解其運作的你，將會發現當中有趣的事情。</strong></p>\n<hr>\n<p>首先，我生命中寫過 <code class=\"language-text\">super(props)</code> 的次數比我想要知道的還多：</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>沒錯，<a href=\"https://github.com/tc39/proposal-class-fields\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">類別欄位提案</a> 讓我們能省略宣告：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>類似這樣的語法是在 2015 年React 0.13 新增對一般類別的支援時就有的<a href=\"https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#es7-property-initializers\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">計劃</a> 。定義 <code class=\"language-text\">constructor</code> 和呼叫 <code class=\"language-text\">super(props)</code> 的語法在當時一直都被當作是暫時的解決方法，直到類別欄位提供合適的替代方案。</p>\n<p>但在此之前，讓我們回到只有使用 ES2015 的例子：</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>為什麼我們要呼叫 <code class=\"language-text\">super</code>？能<em>不</em>呼叫嗎？或者是如果我們必須得呼叫，不帶入 <code class=\"language-text\">props</code> 會發生什麽事？還有其他有參數嗎？</strong> 我們來看看。</p>\n<hr>\n<p>在 JavaScript 中，<code class=\"language-text\">super</code> 會參照父類別的建構子。（在我們的例子當中，它會指向 <code class=\"language-text\">React.Component</code> 的實作。）</p>\n<p>重要的是，直到你呼叫父類別的建構子<em>後</em>，你才能在建構子中使用 <code class=\"language-text\">this</code>。JavaScript 不會讓你這麼做：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 🔴 還不能用 `this`</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ✅ 現在沒問題了</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>JavaScript 會強制父建構子在你碰 <code class=\"language-text\">this</code> 前被執行是有原因的。想想類別的階層：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">PolitePerson</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">greetColleagues</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 🔴 這不被允許，看下面說明</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">greetColleagues</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Good morning folks!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>想像一下如果在 <code class=\"language-text\">super</code> 被呼叫前使用 <code class=\"language-text\">this</code> <em>是</em>被允許的會是怎樣的情況。幾個月後，我們可能想讓某人的名字包含在 <code class=\"language-text\">greetColleagues</code> 的訊息中：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">  <span class=\"token function\">greetColleagues</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Good morning folks!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'My name is '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">+</span> <span class=\"token string\">', nice to meet you!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>但是我們忘了 <code class=\"language-text\">this.greetColleagues()</code> 是在 <code class=\"language-text\">super()</code> 有機會設置 <code class=\"language-text\">this.name</code> 之前就被呼叫了。所以 <code class=\"language-text\">this.name</code> 根本不曾被定義過！如你所見，這樣的程式碼是很難理解的。</p>\n<p>為了避免踩這種雷，<strong>如果你想在建構子中使用 <code class=\"language-text\">this</code>，JavaScript 強制你<em>必須</em>先呼叫 <code class=\"language-text\">super</code></strong>。讓父類別去做它的事！這個限制也適用於定義為類別的 React 元件：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ✅ 能使用 `this` 了</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>這裡留下了另一個問題：為什麼要帶入 <code class=\"language-text\">props</code>？</p>\n<hr>\n<p>你可能會想，帶入 <code class=\"language-text\">props</code> 到 <code class=\"language-text\">super</code> 是必須的，因為底層的 <code class=\"language-text\">React.Component</code> 建構子才能初始化 <code class=\"language-text\">this.props</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// React 內部</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>這離真實情況相去不遠 — 的確，它是 <a href=\"https://github.com/facebook/react/blob/1d25aa5787d4e19704c049c3cfa985d3b5190e0d/packages/react/src/ReactBaseClasses.js#L22\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">這麼做</a> 的。</p>\n<p>但不知為何，即使你呼叫的是沒有帶入 <code class=\"language-text\">props</code> 參數的 <code class=\"language-text\">super()</code>，你仍然可以在 <code class=\"language-text\">render</code> 中或其他函式讀取 <code class=\"language-text\">this.props</code>。（如果你不相信我，自己試試看！）</p>\n<p>那<em>這</em>是如何運作的？事實上 <strong>在 React 呼叫<em>你的</em>建構子後，它也會馬上配置 <code class=\"language-text\">props</code> 到實例中：</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">  <span class=\"token comment\">// React 內部</span>\n  <span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">YourComponent</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  instance<span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span></code></pre></div>\n<p>這就是為什麼就算你忘記帶入 <code class=\"language-text\">props</code> 到 <code class=\"language-text\">super()</code> 中，React 仍會在之後配置它。這是有原因的。</p>\n<p>當 React 增加對類別的支援，它並不是只想增加對 ES6 類別的支援。它的目標是盡可能廣泛地支援抽象的類別。當時我們還 <a href=\"https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#other-languages\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">不清楚</a> 如 ClojureScript，CoffeeScript，ES6，Fable，Scala.js，TypeScript 或其他的解決方案如何相對地成功定義元件，所以當時 React 是刻意設計成對是否必須呼叫 <code class=\"language-text\">super()</code> 這點睜一隻眼閉一隻眼的 —— 即使是 ES6 的類別也是如此。</p>\n<p>所以意思是說你可以只寫 <code class=\"language-text\">super()</code> 而不用寫 <code class=\"language-text\">super(props)</code> 嗎？</p>\n<p><strong>最好不要，因為這仍然會造成誤解。</strong>沒錯，React 會在你的建構子執行之後自行配置 <code class=\"language-text\">this.props</code>。但是 <code class=\"language-text\">this.props</code> <em>從</em>呼叫 <code class=\"language-text\">super</code> 到建構子的結尾仍然會是未定義（undefined）。</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// React 內部</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 你的程式碼內部</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Button</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 😬 我們忘了帶入 props</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">// ✅ {}</span>\n<span class=\"gatsby-highlight-code-line\">    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 😬 未定義（undefined）</span></span>  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>如果某些<em>從</em>建構子中被呼叫的函式發生以上這種狀況，除錯將會更加艱難。<strong>這就是為什麽我建議開發者總是要帶入 <code class=\"language-text\">super(props)</code>，即使這並非絕對必要：</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Button</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ 我們帶入 props</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">// ✅ {}</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ {}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>這確保了 <code class=\"language-text\">this.props</code> 在建構子終止之前都會被設置。</p>\n<hr>\n<p>最後還有一點是長期以來 React 的使用者可能會感到好奇的。</p>\n<p>你或許有注意到，當你在類別中使用 Context API（不論是舊有 <code class=\"language-text\">contextTypes</code> 或是從 React 16.6 新增的新式 <code class=\"language-text\">contextType</code> API），<code class=\"language-text\">context</code> 會作為第二個參數傳給建構子。</p>\n<p>所以為什麼我們不取而代之寫成 <code class=\"language-text\">super(props, context)</code> 呢？其實我們可以，只是 context 使用的頻率比較低，會踩到的雷並不是那麼多。</p>\n<p><strong>當有了類別欄位提案，整個這種的雷大部份都會消失。</strong>在沒有標明建構子的狀況下，所有的參數都會自動地被帶入。這樣就允許了像 <code class=\"language-text\">state = {}</code> 這樣的表達式，在有需要的狀況下，還是能包含參考（reference） <code class=\"language-text\">this.props</code> 跟 <code class=\"language-text\">this.context</code> 的能力。</p>\n<p>而當有了 Hooks 後，我們甚至不需要 <code class=\"language-text\">super</code> 或是 <code class=\"language-text\">this</code>。但這就改天再說了。</p>","timeToRead":5,"frontmatter":{"title":"為什麼我們要寫 super(props) ？","date":"November 30, 2018","spoiler":"在結尾有一個轉折。","cta":null},"fields":{"slug":"/zh-hant/why-do-we-write-super-props/","langKey":"zh-hant"}}},"pageContext":{"slug":"/zh-hant/why-do-we-write-super-props/","translations":["cs","de","fr","fa","es","hu","it","ja","my","nb","sr","pl","sk","pt-br","nl","th","uk","vi","tr","zh-hant","zh-hans"],"translatedLinks":[]}}}
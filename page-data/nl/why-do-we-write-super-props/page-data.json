{"componentChunkName":"component---src-templates-blog-post-js","path":"/nl/why-do-we-write-super-props/","result":{"data":{"site":{"siteMetadata":{"title":"Overreacted","author":"Dan Abramov"}},"markdownRemark":{"id":"2c17a95f-78a2-53fe-98c0-1d84ea34c2ff","html":"<p><a href=\"https://reactjs.org/docs/hooks-intro.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Hooks</a> zijn blijkbaar helemaal in. Ironisch genoeg wil ik dit blog beginnen met een aantal leuke feiten over <em>class</em> components. Wat dacht je daarvan!</p>\n<p><strong>Het is totaal <em>niet</em> nodig om deze feitjes te weten om effectief met React te kunnen werken. Maar het kan wel interessant zijn als je wil weten hoe alles samenhangt.</strong></p>\n<p>Ten eerste.</p>\n<hr>\n<p>Ik heb <code class=\"language-text\">super(props)</code> vaker geschreven dan ik zou willen toegeven:</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Natuurlijk maakt <a href=\"https://github.com/tc39/proposal-class-fields\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">the class fields proposal</a> het heel makkelijk om dit hele gedoe over te slaan:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Deze syntax stond al in de <a href=\"https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#es7-property-initializers\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">planning</a> toen er in React 0.13 in 2015 ondersteuning kwam voor plain classes. Het definiÃ«ren van de <code class=\"language-text\">constructor</code> en aanroepen van <code class=\"language-text\">super(props)</code> was altijd bedoeld als een tijdelijke oplossing totdat class fields een goed alternatief kon bieden.</p>\n<p>Laten we het voorbeeld nog eens bekijken, maar dan met gebruik van ES2015 functionaliteiten:</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Waarom is het nodig om <code class=\"language-text\">super</code> aan te roepen? Is het ook mogelijk dit niet te doen? En als dit dan toch nodig is, wat gebeurt er dan als we geen <code class=\"language-text\">props</code> meegeven? Zijn er nog andere argumenten?</strong> Laten we kijken.</p>\n<hr>\n<p><code class=\"language-text\">super</code> refereert in JavaScript naar de parent class <code class=\"language-text\">constructor</code>. (In ons voorbeeld verwijst het naar de implementatie van <code class=\"language-text\">React.Component</code>.)</p>\n<p>Belangrijk om te weten is dat je <code class=\"language-text\">this</code> pas kan gebruiken in een <code class=\"language-text\">constructor</code> <em>nadat</em> je de parent <code class=\"language-text\">constructor</code> hebt aangeroepen. JavaScript laat het niet toe om:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ðŸ”´ Kan 'this' nog niet gebruiken.</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// âœ… Nu kan het wel.</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Er is een goede reden dat JavaScript aandringt op het uitvoeren van de parent <code class=\"language-text\">constructor</code> voordat je iets met <code class=\"language-text\">this</code> doet. Stel je een class hierarchie voor:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">PolitePerson</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">greetColleagues</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ðŸ”´ Dit mag niet, lees hieronder waarom.</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">greetColleagues</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Good morning folks!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Stel je voor dat je <code class=\"language-text\">this</code> gebruikt <em>voordat</em> <code class=\"language-text\">super</code> kan worden aangeroepen. Een maand later willen we misschien <code class=\"language-text\">greetColleagues</code> aanpassen zodat deze ook de naam van de persoon heeft in het bericht:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">  <span class=\"token function\">greetColleagues</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Good morning folks!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'My name is '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">+</span> <span class=\"token string\">', nice to meet you!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>Maar we zijn vergeten dat <code class=\"language-text\">this.greetColleagues()</code> aangeroepen is voordat <code class=\"language-text\">super()</code> de kans heeft gekregen om <code class=\"language-text\">this.name</code> op te zetten. <code class=\"language-text\">this.name</code> is dus nog niet eens gedefinieerd! Zoals je kan zien kan dit soort code moeilijk zijn om rekening mee te houden.</p>\n<p>Om dit soort valkuilen te voorkomen <strong>forceert JavaScript ons eerst <code class=\"language-text\">super</code> aan te roepen voordat je <code class=\"language-text\">this</code> kan gebruiken.</strong> Laat de parent zijn ding doen! Deze beperking is ook van toepassing op React components die als class worden gedefinieerd:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// âœ… Het is OK om `this` nu te gebruiken.</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>Dit brengt ons bij de volgende vraag: waarom zou je <code class=\"language-text\">props</code> meegeven?</p>\n<hr>\n<p>Je zou denken dat het meegeven van <code class=\"language-text\">props</code> aan <code class=\"language-text\">super</code> noodzakelijk is, omdat het de constructor van <code class=\"language-text\">React.Component</code> in staat stelt <code class=\"language-text\">this.props</code> te initialiseren:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// In React</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Dit ligt niet ver van de waarheid - dat is ook precies <a href=\"https://github.com/facebook/react/blob/1d25aa5787d4e19704c049c3cfa985d3b5190e0d/packages/react/src/ReactBaseClasses.js#L22\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">wat het doet</a>.</p>\n<p>Maar als je <code class=\"language-text\">super()</code> aanroept zonder het <code class=\"language-text\">props</code> argument, is het op een of andere manier toch nog mogelijk om <code class=\"language-text\">this.props</code> te benaderen in de <code class=\"language-text\">render</code> method en andere methods. (Geloof je me niet? Probeer het dan vooral zelf uit).</p>\n<p>Hoe <em>dat</em> werkt? Het blijkt dat <strong>React props ook toewijst op de instance net nadat <em>jouw</em> constructor is aangeroepen:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">  <span class=\"token comment\">// In React</span>\n  <span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">YourComponent</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  instance<span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Dus zelfs als je vergeet <code class=\"language-text\">props</code> mee te geven aan <code class=\"language-text\">super()</code> zal React ze direct na afloop klaarzetten. En daar is een reden voor.</p>\n<p>Toen er in React ondersteuning kwam voor classes, kwam er niet alleen ondersteuning voor ES6 classes. Het doel was om een zo breed mogelijk scala aan class abstracties te ondersteunen. Het was <a href=\"https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#other-languages\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">niet geheel duidelijk</a> hoe succesvol ClojureScript, CoffeeScript, ES6, Fable, Scala.js, TypeScript of andere oplossingen zouden zijn voor het definiÃ«ren van componenten. Daarom bleef React neutraal wat betreft of het aanroepen van <code class=\"language-text\">super()</code> nodig zou zijn - zelfs als dat bij ES6 classes wel nodig is.</p>\n<p>Betekent dit dat je gewoon <code class=\"language-text\">super()</code> kan gebruiken in plaats van <code class=\"language-text\">super(props)</code>?</p>\n<p><strong>Waarschijnlijk niet, sinds het nog steeds verwarrend is.</strong> Uiteraard, React zal <code class=\"language-text\">this.props</code> toewijzen nadat de <code class=\"language-text\">constructor</code> zijn werk heeft gedaan. Maar <code class=\"language-text\">this.props</code> zou nog steeds niet gedefinieerd zijn <em>tussen</em> de <code class=\"language-text\">super</code> call en het einde van je <code class=\"language-text\">constructor</code>:</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// In React</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// In de code</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Button</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ðŸ˜¬ We vergaten props mee te geven</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">// âœ… {}</span>\n<span class=\"gatsby-highlight-code-line\">    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ðŸ˜¬ undefined</span></span>  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Het kan nog uitdagender zijn om te debuggen als dit in een method gebeurt die wordt aangeroepen <em>vanuit</em> de <code class=\"language-text\">constructor</code>. <strong>En dat is waarom ik aanraad om altijd <code class=\"language-text\">super(props)</code> door te geven, zelfs als het niet per se verplicht is:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Button</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// âœ… We gaven props mee</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">// âœ… {}</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// âœ… {}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Dit waarborgt dat <code class=\"language-text\">this.props</code> is gedefinieerd nog voordat de <code class=\"language-text\">constructor</code> klaar is.</p>\n<hr>\n<p>Er is nog Ã©Ã©n ding waar mensen die React al langer gebruiken misschien nieuwsgierig naar zijn.</p>\n<p>Het is je misschien opgevallen dat als je de Context API in classes (met legacy <code class=\"language-text\">contextTypes</code> of de modernere <code class=\"language-text\">contextType</code> API die werd toegevoegd in React 16.6), gebruikt, <code class=\"language-text\">context</code> als tweede argument wordt meegegeven aan de <code class=\"language-text\">constructor</code>.</p>\n<p>Dus waarom schrijven we dan niet <code class=\"language-text\">super(props, context)</code>?  Dit zou kunnen, maar context wordt veel minder vaak gebruikt, dus deze valkuil zal minder vaak voorkomen.</p>\n<p><strong>Met de class fields proposal verdwijnt deze valkuil sowieso al zo goed als volledig.</strong> Zonder een expliciete <code class=\"language-text\">constructor</code> worden alle argumenten automatisch al doorgegeven. Dit maakt het mogelijk dat een expressie zoals <code class=\"language-text\">state = {}</code> referenties bevat naar <code class=\"language-text\">this.props</code> of <code class=\"language-text\">this.context</code> als het nodig is.</p>\n<p>Met Hooks hebben we niet eens <code class=\"language-text\">super</code> of <code class=\"language-text\">this</code>. Maar dat is een onderwerp voor een andere dag.</p>","timeToRead":5,"frontmatter":{"title":"Waarom gebruiken we super(props)?","date":"November 30, 2018","spoiler":"Het einde heeft een wending.","cta":null},"fields":{"slug":"/nl/why-do-we-write-super-props/","langKey":"nl"}}},"pageContext":{"slug":"/nl/why-do-we-write-super-props/","translations":["cs","de","es","fr","fa","it","ja","hu","my","nl","nb","sk","pl","sr","pt-br","vi","tr","th","uk","zh-hans","zh-hant"],"translatedLinks":[]}}}
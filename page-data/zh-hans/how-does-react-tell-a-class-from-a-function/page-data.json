{"componentChunkName":"component---src-templates-blog-post-js","path":"/zh-hans/how-does-react-tell-a-class-from-a-function/","result":{"data":{"site":{"siteMetadata":{"title":"Overreacted","author":"Dan Abramov"}},"markdownRemark":{"id":"09485b6f-7f84-5751-ae20-2fe32aa990a7","html":"<p>让我们来看一下这个以函数形式定义的 <code class=\"language-text\">Greeting</code> 组件：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>React 也支持将他定义成一个类：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Greeting</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>（直到<a href=\"https://reactjs.org/docs/hooks-intro.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">最近</a>，这是使用 state 特性的唯一方式）</p>\n<p>当你要渲染一个 <code class=\"language-text\">&lt;Greeting /&gt;</code> 组件时，你并不需要关心它是如何定义的：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 是类还是函数 —— 无所谓</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Greeting</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n<p>但 <em>React 本身</em> 在意其中的差别！</p>\n<p>如果 <code class=\"language-text\">Greeting</code> 是一个函数，React 需要调用它。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 你的代码</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// React 内部</span>\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &lt;p>Hello&lt;/p></span></code></pre></div>\n<p>但如果 <code class=\"language-text\">Greeting</code> 是一个类，React 需要先用 <code class=\"language-text\">new</code> 操作符将其实例化，<em>然后</em> 调用刚才生成实例的 <code class=\"language-text\">render</code> 方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 你的代码</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Greeting</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// React 内部</span>\n<span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Greeting {}</span>\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> instance<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &lt;p>Hello&lt;/p></span></code></pre></div>\n<p>无论哪种情况 React 的目标都是去获取渲染后的节点（在这个案例中，<code class=\"language-text\">&lt;p&gt;Hello&lt;/p&gt;</code>）。但具体的步骤取决于 <code class=\"language-text\">Greeting</code> 是如何定义的。</p>\n<p><strong>所以 React 是怎么知道某样东西是 class 还是 function 的呢？</strong></p>\n<p>就像我<a href=\"https://overreacted.io/why-do-we-write-super-props/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">上一篇博客</a>中提到的，<strong>你并不<em>需要</em>知道这个才能高效使用 React。</strong> 我多年来都不知道这个。请不要把这变成一道面试题。事实上，这篇博客更多的是关于 JavaScript 而不是 React。</p>\n<p>这篇博客是写给那些对 React 具体是 <strong>如何</strong> 工作的表示好奇的读者的。你是那样的人吗？那我们一起深入探讨一下吧。</p>\n<p><strong>这将是一段漫长的旅程，系好安全带。这篇文章并没有多少关于 React 本身的信息，但我们会涉及到 <code class=\"language-text\">new</code>、<code class=\"language-text\">this</code>、<code class=\"language-text\">class</code>、箭头函数、<code class=\"language-text\">prototype</code>、<code class=\"language-text\">__proto__</code>、<code class=\"language-text\">instanceof</code> 等方面，以及这些东西是如何在 JavaScript 中一起工作的。幸运的是，你并不需要在使用 React 时一直想着这些，除非你正在实现 React…</strong></p>\n<p>（如果你真的很想知道答案，直接翻到最下面。）</p>\n<hr>\n<p>首先，我们需要理解为什么把函数和类分开处理很重要。注意看我们是怎么使用 <code class=\"language-text\">new</code> 操作符来调用一个类的：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 如果 Greeting 是一个函数</span>\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &lt;p>Hello&lt;/p></span>\n\n<span class=\"token comment\">// 如果 Greeting 是一个类</span>\n<span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Greeting {}</span>\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> instance<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &lt;p>Hello&lt;/p></span></code></pre></div>\n<p>我们来简单看一下 <code class=\"language-text\">new</code> 在 JavaScript 是干什么的。</p>\n<hr>\n<p>在过去，JavaScript 还没有类。但是，你可以使用普通函数来模拟。<strong>具体来讲，只要在函数调用前加上 <code class=\"language-text\">new</code> 操作符，你就可以把<em>任何</em>函数当做一个类的构造函数来用：</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 只是一个函数</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ Person {name: 'Fred'}</span>\n<span class=\"token keyword\">var</span> george <span class=\"token operator\">=</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'George'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 🔴 没用的</span></code></pre></div>\n<p>现在你依然可以这样写！在 DevTools 里试试吧。</p>\n<p>如果你调用 <code class=\"language-text\">Person(&#39;Fred&#39;)</code> 时<strong>没有</strong>加 <code class=\"language-text\">new</code>，其中的 <code class=\"language-text\">this</code> 会指向某个全局且无用的东西（比如，<code class=\"language-text\">window</code> 或者 <code class=\"language-text\">undefined</code>），因此我们的代码会崩溃，或者做一些像设置 <code class=\"language-text\">window.name</code> 之类的傻事。</p>\n<p>通过在调用前增加 <code class=\"language-text\">new</code>，我们说：「嘿 JavaScript，我知道 <code class=\"language-text\">Person</code> 只是个函数，但让我们假装它是个构造函数吧。<strong>创建一个 <code class=\"language-text\">{}</code> 对象并把 <code class=\"language-text\">Person</code> 中的 <code class=\"language-text\">this</code> 指向那个对象，以便我可以通过类似 <code class=\"language-text\">this.name</code> 的形式去设置一些东西，然后把这个对象返回给我。</strong>」</p>\n<p>这就是 <code class=\"language-text\">new</code> 操作符所做的事。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">var</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 和 `Person` 中的 `this` 等效的对象</span></code></pre></div>\n<p><code class=\"language-text\">new</code> 操作符同时也把我们放在 <code class=\"language-text\">Person.prototype</code> 上的东西放到了 <code class=\"language-text\">fred</code> 对象上：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">Person</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">sayHi</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hi, I am '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nfred<span class=\"token punctuation\">.</span><span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这就是在 JavaScript 直接支持类之前，人们模拟类的方式。</p>\n<hr>\n<p><code class=\"language-text\">new</code> 在 JavaScript 中已经存在了好久了，然而类还只是最近的事，它的出现让我们能够重构我们前面的代码以使它更符合我们的本意：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hi, I am '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nfred<span class=\"token punctuation\">.</span><span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong><em>捕捉开发者的本意</em></strong>是语言和 API 设计中非常重要的一点。</p>\n<p>如果你写了一个函数，JavaScript 没办法判断它应该像 <code class=\"language-text\">alert()</code> 一样被调用，还是应该被视作像 <code class=\"language-text\">new Person()</code> 一样的构造函数。忘记给像 <code class=\"language-text\">Person</code> 这样的函数指定 <code class=\"language-text\">new</code> 会导致令人费解的行为。</p>\n<p><strong>类语法允许我们说：「这不仅仅是个函数 —— 这是个类并且它有构造函数」。</strong> 如果你在调用它时忘了加 <code class=\"language-text\">new</code>，JavaScript 会报错：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ✅  如果 Person 是个函数：有效</span>\n<span class=\"token comment\">// ✅  如果 Person 是个类：依然有效</span>\n\n<span class=\"token keyword\">let</span> george <span class=\"token operator\">=</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'George'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 我们忘记使用 `new`</span>\n<span class=\"token comment\">// 😳 如果 Person 是个长得像构造函数的方法：令人困惑的行为</span>\n<span class=\"token comment\">// 🔴 如果 Person 是个类：立即失败</span></code></pre></div>\n<p>这可以帮助我们在早期捕捉错误，而不会遇到类似 <code class=\"language-text\">this.name</code> 被当成 <code class=\"language-text\">window.name</code> 对待而不是 <code class=\"language-text\">george.name</code> 的隐晦错误。</p>\n<p>然而，这意味着 React 需要在调用所有类之前加上 <code class=\"language-text\">new</code>，而不能把它直接当做一个常规的函数去调用，因为 JavaScript 会把它当做一个错误对待！</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Counter</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 🔴 React 不能简单这么做：</span>\n<span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> <span class=\"token function\">Counter</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这意味着麻烦。</p>\n<hr>\n<p>在我们看到 React 如何处理这个问题之前，很重要的一点就是要记得大部分 React 的用户会使用 Babel 等编译器来编译类等现代化的特性以便能在老旧的浏览器上运行。因此我们需要在我们的设计中考虑编译器。</p>\n<p>在 Babel 的早期版本中，类不加 <code class=\"language-text\">new</code> 也可以被调用。但这个问题已经被修复了 —— 通过生成额外的代码的方式。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 稍微简化了一下 Babel 的输出：</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TypeError</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Cannot call a class as a function\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// Our code:</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ OK</span>\n<span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'George'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 🔴 无法把类当做函数来调用</span></code></pre></div>\n<p>你或许已经在你构建出来的包中见过类似的代码，这就是那些 <code class=\"language-text\">_classCallCheck</code> 函数做的事。（你可以通过启用「loose mode」来关闭检查以减小构建包的尺寸，但这或许会使你最终转向真正的原生类时变得复杂）</p>\n<hr>\n<p>至此，你应该已经大致理解了调用时加不加 <code class=\"language-text\">new</code> 的差别：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th><code class=\"language-text\">new Person()</code></th>\n<th><code class=\"language-text\">Person()</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">class</code></td>\n<td>✅ <code class=\"language-text\">this</code> 是一个 <code class=\"language-text\">Person</code> 实例</td>\n<td>🔴 <code class=\"language-text\">TypeError</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">function</code></td>\n<td>✅ <code class=\"language-text\">this</code> 是一个 <code class=\"language-text\">Person</code> 实例</td>\n<td>😳 <code class=\"language-text\">this</code> 是 <code class=\"language-text\">window</code> 或 <code class=\"language-text\">undefined</code></td>\n</tr>\n</tbody>\n</table>\n<p>这就是 React 正确调用你的组件很重要的原因。<strong>如果你的组件被定义为一个类，React 需要使用 <code class=\"language-text\">new</code> 来调用它</strong>。</p>\n<p>所以 React 能检查出某样东西是否是类吗？</p>\n<p>没那么容易！即便我们能够<a href=\"https://stackoverflow.com/questions/29093396/how-do-you-check-the-difference-between-an-ecmascript-6-class-and-function\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">在 JavaScript 中区分类和函数</a>，面对被 Babel 等工具处理过的类这还是没用。对浏览器而言，它们只是不同的函数。这是 React 的不幸。</p>\n<hr>\n<p>好，那 React 可以直接在每次调用时都加上 <code class=\"language-text\">new</code> 吗？很遗憾，这种方法并不总是有用。</p>\n<p>对于常规函数，用 <code class=\"language-text\">new</code> 调用会给它们一个 <code class=\"language-text\">this</code> 作为对象实例。对于用作构造函数的函数（比如我们前面提到的 <code class=\"language-text\">Person</code>）是可取的，但对函数组件这或许就比较令人困惑了：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 我们并不期望 `this` 在这里表示任何类型的实例</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这暂且还能忍，还有两个<em>其他</em>理由会扼杀这个想法。</p>\n<hr>\n<p>关于为什么总是使用 <code class=\"language-text\">new</code> 是没用的的第一个理由是，对于原生的箭头函数（不是那些被 Babel 编译过的），用 <code class=\"language-text\">new</code> 调用会抛出一个错误：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Greeting</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 🔴 Greeting 不是一个构造函数</span></code></pre></div>\n<p>这个行为是遵循箭头函数的设计而刻意为之的。箭头函数的一个附带作用是它<em>没有</em>自己的 <code class=\"language-text\">this</code> 值 —— <code class=\"language-text\">this</code> 解析自离得最近的常规函数：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Friends</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> friends <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>friends<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> friends<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">friend</span> <span class=\"token operator\">=></span>\n      <span class=\"token operator\">&lt;</span>Friend\n        <span class=\"token comment\">// `this` 解析自 `render` 方法</span>\n        size<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">}</span>\n        name<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>friend<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span>\n        key<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>friend<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">}</span>\n      <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>OK，所以<strong>箭头函数没有自己的 <code class=\"language-text\">this</code>。</strong>但这意味着它作为构造函数是完全无用的！</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Person</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 🔴 这么写是没有意义的！</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>因此，<strong>JavaScript 不允许用 <code class=\"language-text\">new</code> 调用箭头函数。</strong>如果你这么做，你或许已经犯了错，最好早点告诉你。这和 JavaScript 不让你<em>不加</em> <code class=\"language-text\">new</code> 去调用一个类是类似的。</p>\n<p>这样很不错，但这也让我们的计划受阻。React 不能简单对所有东西都使用 <code class=\"language-text\">new</code>，因为会破坏箭头函数！我们可以利用箭头函数没有 <code class=\"language-text\">prototype</code> 的特点来检测箭头函数，不对它们使用 <code class=\"language-text\">new</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>prototype <span class=\"token comment\">// undefined</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>prototype <span class=\"token comment\">// {constructor: f}</span></code></pre></div>\n<p>但这对于被 Babel 编译过的函数是<a href=\"https://github.com/facebook/react/issues/4599#issuecomment-136562930\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">没用</a>的。这或许没什么大不了，但还有另一个原因使得这条路不会有结果。</p>\n<hr>\n<p>另一个我们不能总是使用 <code class=\"language-text\">new</code> 的原因是它会妨碍 React 支持返回字符串或其它原始类型的组件。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">'Hello'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ 'Hello'</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 😳 Greeting {}</span></code></pre></div>\n<p>这，再一次，和<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">new</code> 操作符</a>的怪异设计有关。如我们之前所看到的，<code class=\"language-text\">new</code> 告诉 JavaScript 引擎去创建一个对象，让这个对象成为函数内部的 <code class=\"language-text\">this</code>，然后把这个对象作为 <code class=\"language-text\">new</code> 的结果给我们。</p>\n<p>然而，JavaScript 也允许一个使用 <code class=\"language-text\">new</code> 调用的函数返回另一个对象以 <strong>覆盖</strong> <code class=\"language-text\">new</code> 的返回值。或许，这在我们利用诸如「对象池模式」来对组件进行复用时是被认为有用的：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 创建了一个懒变量 zeroVector = null;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Vector</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">,</span> y</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">===</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> y <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>zeroVector <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 复用同一个实例</span>\n      <span class=\"token keyword\">return</span> zeroVector<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    zeroVector <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>x <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>y <span class=\"token operator\">=</span> y<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vector</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vector</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> c <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vector</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 😲 b === c</span></code></pre></div>\n<p>然而，如果一个函数的返回值<em>不是</em>一个对象，它会被 <code class=\"language-text\">new</code> <em>完全忽略</em>。如果你返回了一个字符串或数字，就好像完全没有 <code class=\"language-text\">return</code> 一样。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Answer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">Answer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ 42</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Answer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 😳 Answer {}</span></code></pre></div>\n<p>当使用 <code class=\"language-text\">new</code> 调用函数时，是没办法读取原始类型（例如一个数字或字符串）的返回值的。因此如果 React 总是使用 <code class=\"language-text\">new</code>，就没办法增加对返回字符串的组件的支持！</p>\n<p>这是不可接受的，因此我们必须妥协。</p>\n<hr>\n<p>至此我们学到了什么？React 在调用类（包括 Babel 输出的）时<em>需要用</em> <code class=\"language-text\">new</code>，但在调用常规函数或箭头函数时（包括 Babel 输出的）<strong>不需要用</strong> <code class=\"language-text\">new</code>，并且没有可靠的方法来区分这些情况。</p>\n<p><strong>如果我们没法解决一个笼统的问题，我们能解决一个具体的吗？</strong></p>\n<p>当你把一个组件定义为类，你很可能会想要扩展 <code class=\"language-text\">React.Component</code> 以便获取内置的方法，比如 <code class=\"language-text\">this.setState()</code>。 <strong>与其试图检测所有的类，我们能否只检测 <code class=\"language-text\">React.Component</code> 的后代呢？</strong></p>\n<p>剧透：React 就是这么干的。</p>\n<hr>\n<p>或许，检查 <code class=\"language-text\">Greeting</code> 是否是一个 React 组件类的最符合语言习惯的方式是测试 <code class=\"language-text\">Greeting.prototype instanceof React.Component</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">B</span><span class=\"token punctuation\">.</span>prototype <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span></code></pre></div>\n<p>我知道你在想什么，刚才发生了什么？！为了回答这个问题，我们需要理解 JavaScript 原型。</p>\n<p>你或许对「原型链」很熟悉。JavaScript 中的每一个对象都有一个「原型」。当我们写 <code class=\"language-text\">fred.sayHi()</code> 但 <code class=\"language-text\">fred</code> 对象没有 <code class=\"language-text\">sayHi</code> 属性，我们尝试到 <code class=\"language-text\">fred</code> 的原型上去找 <code class=\"language-text\">sayHi</code> 属性。要是我们在这儿找不到，就去找原型链的下一个原型 —— <code class=\"language-text\">fred</code> 的原型的原型，以此类推。</p>\n<p><strong>费解的是，一个类或函数的 <code class=\"language-text\">prototype</code> 属性 <em>并不</em> 指向那个值的原型。</strong>我没开玩笑。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Person</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 🤪 不是 Person 的原型</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Person<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 😳 Person 的原型</span></code></pre></div>\n<p>因此「原型链」更像是 <code class=\"language-text\">__proto__.__proto__.__proto__</code> 而不是 <code class=\"language-text\">prototype.prototype.prototype</code>，我花了好几年才搞懂这一点。</p>\n<p>那么函数和类的 <code class=\"language-text\">prototype</code> 属性又是什么？<strong>是用 <code class=\"language-text\">new</code> 调用那个类或函数生成的所有对象的 <code class=\"language-text\">__proto__</code>！</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">Person</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">sayHi</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hi, I am '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 设置 `fred.__proto__` 为 `Person.prototype`</span></code></pre></div>\n<p>那个 <code class=\"language-text\">__proto__</code> 链才是 JavaScript 用来查找属性的：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">fred<span class=\"token punctuation\">.</span><span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 1. fred 有 sayHi 属性吗？不。</span>\n<span class=\"token comment\">// 2. fred.__proto__ 有 sayHi 属性吗？是的，调用它！</span>\n\nfred<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 1. fred 有 toString 属性吗？不。</span>\n<span class=\"token comment\">// 2. fred.__proto__ 有 toString 属性吗？不。</span>\n<span class=\"token comment\">// 3. fred.__proto__.__proto__ 有 toString 属性吗？是的，调用它！</span></code></pre></div>\n<p>在实战中，你应该几乎永远不需要直接在代码里动到 <code class=\"language-text\">__proto__</code> ，除非你在调试和原型链相关的问题。如果你想让某样东西在 <code class=\"language-text\">fred.__proto__</code> 上可用，你应该把它放在 <code class=\"language-text\">Person.prototype</code>，至少它最初是这么设计的。</p>\n<p><code class=\"language-text\">__proto__</code> 属性甚至一开始就不应该被浏览器暴露出来，因为原型链应该被视为一个内部概念，然而某些浏览器增加了 <code class=\"language-text\">__proto__</code> 并最终勉强被标准化（但已被废弃并推荐使用 <code class=\"language-text\">Object.getPrototypeOf()</code>）。</p>\n<p><strong>然而一个名叫「原型」的属性却给不了我一个值的「原型」这一点还是很让我困惑</strong>（例如，<code class=\"language-text\">fred.prototype</code> 是未定义的，因为 <code class=\"language-text\">fred</code> 不是一个函数）。个人观点，我觉得这是即便有经验的开发者也容易误解 JavaScript 原型链的最大原因。</p>\n<hr>\n<p>这篇博客很长，是吧？已经到 80% 了，坚持住。</p>\n<p>我们知道当说 <code class=\"language-text\">obj.foo</code> 的时候，JavaScript 事实上会沿着 <code class=\"language-text\">obj</code>, <code class=\"language-text\">obj.__proto__</code>, <code class=\"language-text\">obj.__proto__.__proto__</code> 等等一路寻找 <code class=\"language-text\">foo</code>。</p>\n<p>在使用类时，你并非直接面对这一机制，但 <code class=\"language-text\">extends</code> 的原理依然是基于这项老旧但有效的原型链机制。这也是的我们的 React 类实例能够访问如 <code class=\"language-text\">setState</code> 这样方法的原因：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Greeting</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> c <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Greeting.prototype</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// React.Component.prototype</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Object.prototype</span>\n\nc<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">// 在 c.__proto__ (Greeting.prototype) 上找到</span>\nc<span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 在 c.__proto__.__proto__ (React.Component.prototype) 上找到</span>\nc<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 在 c.__proto__.__proto__.__proto__ (Object.prototype) 上找到</span></code></pre></div>\n<p>换句话说，<strong>当你在使用类的时候，实例的 <code class=\"language-text\">__proto__</code> 链「镜像」了类的层级结构：</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// `extends` 链</span>\nGreeting\n  → React<span class=\"token punctuation\">.</span>Component\n    → <span class=\"token function\">Object</span> <span class=\"token punctuation\">(</span>间接的<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// `__proto__` 链</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  → <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">.</span>prototype\n    → React<span class=\"token punctuation\">.</span><span class=\"token class-name\">Component</span><span class=\"token punctuation\">.</span>prototype\n      → <span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype</code></pre></div>\n<p>2 条链。</p>\n<hr>\n<p>既然 <code class=\"language-text\">__proto__</code> 链镜像了类的层级结构，我们可以检查一个 <code class=\"language-text\">Greeting</code> 是否扩展了 <code class=\"language-text\">React.Component</code>，我们从 <code class=\"language-text\">Greeting.prototype</code> 开始，一路沿着 <code class=\"language-text\">__proto__</code> 链：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// `__proto__` chain</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  → <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">.</span>prototype <span class=\"token comment\">// 🕵️ 我们从这儿开始</span>\n    → React<span class=\"token punctuation\">.</span><span class=\"token class-name\">Component</span><span class=\"token punctuation\">.</span>prototype <span class=\"token comment\">// ✅ 找到了！</span>\n      → <span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype</code></pre></div>\n<p>方便的是，<code class=\"language-text\">x instanceof Y</code> 做的就是这类搜索。它沿着 <code class=\"language-text\">x.__proto__</code> 链寻找 <code class=\"language-text\">Y.prototype</code> 是否在那儿。</p>\n<p>通常，这被用来判断某样东西是否是一个类的实例：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> greeting <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>greeting <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n<span class=\"token comment\">// greeting (🕵️‍ 我们从这儿开始)</span>\n<span class=\"token comment\">//   .__proto__ → Greeting.prototype (✅ 找到了！)</span>\n<span class=\"token comment\">//     .__proto__ → React.Component.prototype</span>\n<span class=\"token comment\">//       .__proto__ → Object.prototype</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>greeting <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n<span class=\"token comment\">// greeting (🕵️‍ 我们从这儿开始)</span>\n<span class=\"token comment\">//   .__proto__ → Greeting.prototype</span>\n<span class=\"token comment\">//     .__proto__ → React.Component.prototype (✅ 找到了！)</span>\n<span class=\"token comment\">//       .__proto__ → Object.prototype</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>greeting <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n<span class=\"token comment\">// greeting (🕵️‍ 我们从这儿开始)</span>\n<span class=\"token comment\">//   .__proto__ → Greeting.prototype</span>\n<span class=\"token comment\">//     .__proto__ → React.Component.prototype</span>\n<span class=\"token comment\">//       .__proto__ → Object.prototype (✅ 找到了！)</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>greeting <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Banana</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\n<span class=\"token comment\">// greeting (🕵️‍ 我们从这儿开始)</span>\n<span class=\"token comment\">//   .__proto__ → Greeting.prototype</span>\n<span class=\"token comment\">//     .__proto__ → React.Component.prototype</span>\n<span class=\"token comment\">//       .__proto__ → Object.prototype (🙅‍ 没找到！)</span></code></pre></div>\n<p>但这用来判断一个类是否扩展了另一个类还是有效的：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">.</span>prototype <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// greeting</span>\n<span class=\"token comment\">//   .__proto__ → Greeting.prototype (🕵️‍ 我们从这儿开始)</span>\n<span class=\"token comment\">//     .__proto__ → React.Component.prototype (✅ 找到了！)</span>\n<span class=\"token comment\">//       .__proto__ → Object.prototype</span></code></pre></div>\n<p>这种检查方式就是我们判断某样东西是一个 React 组件类还是一个常规函数的方式。</p>\n<hr>\n<p>然而 React 并不是这么做的。 😳</p>\n<p>关于 <code class=\"language-text\">instanceof</code> 解决方案有一点附加说明，当页面上有多个 React 副本，并且我们要检查的组件继承自 <strong>另一个</strong> React 副本的 <code class=\"language-text\">React.Component</code> 时，这种方法是无效的。在一个项目里混合多个 React 副本是不好的，原因有很多，但站在历史角度来看，我们试图尽可能避免问题。（有了 Hooks，我们<a href=\"https://github.com/facebook/react/issues/13991\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">或许得</a>强制避免重复。）</p>\n<p>另一点启发可以是去检查原型链上的 <code class=\"language-text\">render</code> 方法。然而，当时还<a href=\"https://github.com/facebook/react/issues/4599#issuecomment-129714112\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">不确定</a>组件的 API 会如何演化。每一次检查都有成本，所以我们不想再多加了。如果 <code class=\"language-text\">render</code> 被定义为一个实例方法，例如使用类属性语法，这个方法也会失效。</p>\n<p>因此, React 为基类<a href=\"https://github.com/facebook/react/pull/4663\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">增加了</a>一个特别的标记。React 检查是否有这个标记，以此知道某样东西是否是一个 React 组件类。</p>\n<p>最初这个标记是在 <code class=\"language-text\">React.Component</code> 这个基类自己身上：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// React 内部</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nComponent<span class=\"token punctuation\">.</span>isReactClass <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 我们可以像这样检查它</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Greeting</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Greeting<span class=\"token punctuation\">.</span>isReactClass<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ 是的</span></code></pre></div>\n<p>然而，有些我们希望作为目标的类实现<a href=\"https://github.com/scala-js/scala-js/issues/1900\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">并没有</a>复制静态属性（或设置非标准的 <code class=\"language-text\">__proto__</code>），标记也因此丢失。</p>\n<p>这也是为什么 React 把这个标记<a href=\"https://github.com/facebook/react/pull/5021\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">移动到了</a> <code class=\"language-text\">React.Component.prototype</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// React 内部</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">Component</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>isReactComponent <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 我们可以像这样检查它</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Greeting</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>isReactComponent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ 是的</span></code></pre></div>\n<p><strong>说真的这就是全部了。</strong></p>\n<p>你或许奇怪为什么是一个对象而不是一个布尔值。实战中这并不重要，但早期版本的 Jest（在 Jest 商品化之前）是默认开始自动模拟功能的，生成的模拟数据省略掉了原始类型属性，<a href=\"https://github.com/facebook/react/pull/4663#issuecomment-136533373\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">破坏了检查</a>。谢了，Jest。</p>\n<p>一直到今天，<a href=\"https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/react-reconciler/src/ReactFiber.js#L297-L300\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React 都在用</a> <code class=\"language-text\">isReactComponent</code> 进行检查。</p>\n<p>如果你不扩展 <code class=\"language-text\">React.Component</code>，React 不会在原型上找到 <code class=\"language-text\">isReactComponent</code>，因此就不会把组件当做类处理。现在你知道为什么解决 <code class=\"language-text\">Cannot call a class as a function</code> 错误的<a href=\"https://stackoverflow.com/a/42680526/458193\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">得票数最高的答案</a>是增加 <code class=\"language-text\">extends React.Component</code>。最后，我们还<a href=\"https://github.com/facebook/react/pull/11168\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">增加了一项警告</a>，当 <code class=\"language-text\">prototype.render</code> 存在但 <code class=\"language-text\">prototype.isReactComponent</code> 不存在时会发出警告。</p>\n<hr>\n<p>你或许会觉得这个故事有一点「标题党」。 <strong>实际的解决方案其实真的很简单，但我花了大量的篇幅在转折上来解释为什么 React 最终选择了这套方案，以及还有哪些候选方案。</strong></p>\n<p>以我的经验来看，设计一个库的 API 也经常会遇到这种情况。为了一个 API 能够简单易用，你经常需要考虑语义化（可能的话，为多种语言考虑，包括未来的发展方向）、运行时性能、有或没有编译时步骤的工程效能、生态的状态以及打包方案、早期的警告，以及很多其它问题。最终的结果未必总是最优雅的，但必须要是可用的。</p>\n<p><strong>如果最终的 API 成功的话，<em>它的用户</em> 永远不必思考这一过程</strong>。他们只需要专心创建应用就好了。</p>\n<p>但如果你同时也很好奇…知道它是怎么工作的也是极好的。</p>","timeToRead":17,"frontmatter":{"title":"React 如何区分 Class 和 Function？","date":"December 02, 2018","spoiler":"我们谈论关于类（classes）、new、instanceof、原型链（prototype chains）、和 API 设计。","cta":null},"fields":{"slug":"/zh-hans/how-does-react-tell-a-class-from-a-function/","langKey":"zh-hans"}}},"pageContext":{"slug":"/zh-hans/how-does-react-tell-a-class-from-a-function/","translations":["es","fr","hu","ja","nl","pt-br","sk","zh-hans","zh-hant"],"translatedLinks":[]}}}
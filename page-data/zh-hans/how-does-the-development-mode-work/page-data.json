{"componentChunkName":"component---src-templates-blog-post-js","path":"/zh-hans/how-does-the-development-mode-work/","result":{"data":{"site":{"siteMetadata":{"title":"Overreacted","author":"Dan Abramov"}},"markdownRemark":{"id":"b5b0bbfe-ac15-5a73-a3e2-a371110db0f6","html":"<p>如果你的代码库即便是稍许有些复杂，<strong>你可能已经采取了某种办法，针对开发和生产环境分别进行打包，从而于不同环境运行不同的代码</strong>。</p>\n<p>针对开发和生产模式分别打包并运行不同的代码，这样的做法很有用。在开发模式下，React 包含了很多以帮助你发现潜在 bug 的警告 （warnings）。然而，用于检查这些错误的那部分代码往往会增加程序包的体积、拖慢应用运行速度。</p>\n<p>在开发模式下这个“缓慢”尚可接受。实际上，在开发阶段使程序运行慢一些还或许有一点好处，那就是，它部分地中和了开发机（往往很快）与多数用户机（较慢）的性能差异。</p>\n<p>而在生产模式，我们则不愿意付出这个性能代价。因此，我们在生产模式下忽略掉这些检查。这是怎么实现的呢？让我们来看看。</p>\n<hr>\n<p>如何使开发模式下运行的代码异乎生产环境，确切的方式取决于你的脚本构建管道（build pipeline）（以及你是否设有这样的构建管道）。在 Facebook 它看起来像这样：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>__DEV__<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">doSomethingDev</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">doSomethingProd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里，<code class=\"language-text\">__DEV__</code> 不是一个真实的变量。它是一个常量， 在各个模块（modules）穿连到一起后被替换。结果就是如下面这样：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// In development:</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">doSomethingDev</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 👈</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">doSomethingProd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// In production:</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">doSomethingDev</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">doSomethingProd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 👈</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>在生产模式下，你应该也使用压缩工具（例如：<a href=\"https://github.com/terser-js/terser\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">terser</a>）对代码进行处理。多数的 JavaScript 压缩工具部分地实现了<a href=\"https://en.wikipedia.org/wiki/Dead_code_elimination\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">死码消除（dead code elimination）</a>，比如，去掉 <code class=\"language-text\">if (false)</code> 条件分支。因此在生产模式下，你应该只能看到：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// In production (after minification):</span>\n<span class=\"token function\">doSomethingProd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><em>（注意，以主流压缩工具来看，死码消除（dead code elimination）的效果很不尽人意，这是另一个话题）</em></p>\n<p>然而，如果你使用当下流行的 webpack 打包工具，可能就未使用 <code class=\"language-text\">__DEV__</code> 这个魔术常量（magic constant），这时你可以遵循另一些套路。例如，通常可表达相同意思的方式像是这样：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">NODE_ENV</span> <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">doSomethingDev</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">doSomethingProd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>这正是 React 和 Vue 前端库被打包的时候所采用的表达方式。</strong>（它分别提供 <em>development</em> 和 <em>production</em> 两个单文件构建版本，分别为 <code class=\"language-text\">.js</code> 和 <code class=\"language-text\">.min.js</code>）</p>\n<p>这个惯常的做法源自 Node.js。在 Node.js 中，有一个全局变量 <code class=\"language-text\">process</code> ，它在属性 <code class=\"language-text\">process.env</code> 对象中暴露了系统的环境变量。然而，当你注意在前端代码中观察这种用法，会发现并没有真正引入 <code class=\"language-text\">process</code> 这个变量。🤯</p>\n<p>实际上，在构建的时候，<code class=\"language-text\">process.env.NODE_ENV</code> 这整个表达式会被一个文本替换，就像神奇的 <code class=\"language-text\">__DEV__</code> 变量一样：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// In development:</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'development'</span> <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// true</span>\n  <span class=\"token function\">doSomethingDev</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 👈</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">doSomethingProd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// In production:</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'production'</span> <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// false</span>\n  <span class=\"token function\">doSomethingDev</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">doSomethingProd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 👈</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>由于这整个表达式是一个常量（<code class=\"language-text\">&#39;production&#39; !== &#39;production&#39;</code> 一定是 <code class=\"language-text\">false</code>），代码压缩工具也会移除条件的否定分支。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// In production (after minification):</span>\n<span class=\"token function\">doSomethingProd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>有意思的做法啊！</p>\n<hr>\n<p>注意，对于复杂的表达式，这种的方式<strong>将不会</strong>奏效：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> mode <span class=\"token operator\">=</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mode <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 🔴 not guaranteed to be eliminated</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>JavaScript 因为是动态语言，静态分析工具不会那么智能。当它看到是变量 <code class=\"language-text\">mode</code> ，而不是一个静态的表达式，比如 <code class=\"language-text\">false</code> 的或者 <code class=\"language-text\">&#39;production&#39; !== &#39;production&#39;</code>，它通常无视之。</p>\n<p>类似，JavaScript 中的死码消除对于使用 <code class=\"language-text\">import</code> 而产生的跨模块边界的情形，不会很好地起作用：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 🔴 not guaranteed to be eliminated</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span>someFunc<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'some-module'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">someFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>因此，你需要编写一些具体的代码，以使条件是<em>绝对</em>静态的表达，并且确保条件下的<em>全部</em>代码是你想消除的。</p>\n<hr>\n<p>为此，你的打包工具需要对 <code class=\"language-text\">process.env.NODE_ENV</code> 进行替换，并且需要明确你要在哪种模式下将其构建到项目中。</p>\n<p>几年之前，人们往往忘记配置环境。你可能经常看到一些处于开发模式下的项目被部署到生产环境上。</p>\n<p>这非常糟糕，因为，它会让网站加载和运行得更慢。</p>\n<p>在过去的两年，这种状况得到极大改善。例如，webpack 添加了一个方便的 <code class=\"language-text\">mode</code> 选项，以替代之前对 <code class=\"language-text\">process.env.NODE_ENV</code> 的手动配置。 React DevTools 现在也会在开发模式下将图标显示为红色，以使更加显眼、甚至用于做相关报告。</p>\n<p><img src=\"https://overreacted.io/static/ca1c0db064f73cc5c8e21ad605eaba26/d9514/devmode.png\" alt=\"Development mode warning in React DevTools\"></p>\n<p>直接使用像 Create React App、Next/Nuxt、Vue CLI、Gatsby 等等工具来初始化项目的话，开发与生产构建分别交由两个命令执行（例如：<code class=\"language-text\">npm start</code> 和 <code class=\"language-text\">npm run build</code>），这使得用户对此两种模式更加不易混淆。尤其，只能生产构建才能部署，因此开发者不会再犯错误。</p>\n<p>总有声音认为 <em>production</em> 模式应该是默认模式，而 <em>development</em> 模式则应为可配置项。个人来说，我不认为这个观点有任何说服力。从 <em>development</em> 模式下的 <code class=\"language-text\">warnings</code> 中获益的，往往是那些使用xx库的新手。<em>他们不知道需要将环境切换到开发模式</em>，这将导致那些 <code class=\"language-text\">warnings</code> 能检测到的大量潜在的 bug 被遗漏。</p>\n<p>是的，性能问题很糟糕。但是将问题重重的使用体验抛给终端用户同样糟糕。例如，<a href=\"https://reactjs.org/docs/lists-and-keys.html#keys\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React key warning</a> 帮助我们避免掉一些 bug，比如：将消息发送给错误的人或者购买到错误的产品。关闭这个 warning 对你和你的用户都存在极大的风险。倘若它默认为关闭的状态，那么当你开启它的时候，已经积攒了大量的 warnings 以待清理！因此大多数人会将其切换为开启状态。这也就是为什么此种检测当从最初即被开启，而非日后为之！</p>\n<p>最后，即使开发模式下的 <code class=\"language-text\">warnings</code> 为可选配置，且开发者知道在开发时需要早早地开启它们，我们还是会回到最初的那个问题。有些人将会把开发模式下的版本部署到生产环境。</p>\n<p>我们又回到了 square one.</p>\n<p>我个人比较信赖那些可根据所处阶段是调试或部署，来显示和使用正确模式的工具。几十年来，除 web 浏览器之外的其它环境（移动、PC或者服务器）都有各自的方式加载和区分开发（development）和生产（production）的构建。</p>\n<p>或许，是时候为 JavaScript 运行环境提供一个首要配置项，来<strong>区分 development 和 production 模式</strong>，而不是各个库采用和依赖一些临时规范。</p>\n<hr>\n<p>对于思想的论述就到此！</p>\n<p>让我们来看看这段代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">NODE_ENV</span> <span class=\"token operator\">!==</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">doSomethingDev</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">doSomethingProd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>你可能会疑惑，如果在前端代码中不存在 <code class=\"language-text\">process</code> 这个对象，为什么像 React 和 Vue 这样的库在 npm 构建的时候需要依赖它呢？</p>\n<p><em>（再次澄清一下：你在浏览器中使用 <code class=\"language-text\">&lt;script&gt;</code> 加载的 React 和 Vue 的构建包并不依赖这个。但是，你必须自己来选择是使用 development 模式下的构建包 <code class=\"language-text\">.js</code> 还是 production 模式下的构建包 <code class=\"language-text\">.min.js</code>。下边的内容旨在探讨使用打包工具（webpack、rollup），基于 ES6 的 import 模块加载规范，加载 React 或 Vue 库时的情况。）</em></p>\n<p>就像编程中的众多问题，<strong>这个</strong>规范（convention）的形成有历史原因。我们都在使用这个，只是因为现在很多工具在遵循它。如果换作其它的方式，则其代价不小且无所益处。</p>\n<p>那么这背后的历史如何呢？</p>\n<p>在 <code class=\"language-text\">import</code> 和 <code class=\"language-text\">export</code> 语法得以标准化之前的数年，已经存在了很多完整的方式来表达模块之间的关系。Node.js  极大推广了 <code class=\"language-text\">require()</code> 和 <code class=\"language-text\">module.exports</code>，这就是 <a href=\"https://en.wikipedia.org/wiki/CommonJS\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">CommonJS</a> 规范。</p>\n<p>最初，往 npm 仓库发布的代码仅提供给 Node.js  来使用。<a href=\"https://expressjs.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Express</a>（至今仍是？）曾是最为流行的基于 NodeJs 的服务端框架，它使用了 <a href=\"https://expressjs.com/en/advanced/best-practice-performance.html#set-node_env-to-production\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">NODE_ENV</code></a> 环境变量来开启 <em>production</em> 模式。其它一些 npm 包也采取了同样的规范。</p>\n<p>早期的 JavaScript 打包工具，像 browserify ，想将 npm 仓库中的代码应用到前端项目中。（是的，<a href=\"https://blog.npmjs.org/post/101775448305/npm-and-front-end-packaging\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">那之前</a>，没有人将 npm 包用于前端开发！你能想象吗？）因此，他们把 NodeJs 生态下的这个规范扩展到了前端。</p>\n<p>原先的 “envify” 代码变换（transform）<a href=\"https://github.com/hughsk/envify/commit/ae8aa26b759cd2115eccbed96f70e7bbdceded97\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">发布于2013年</a>。React 在那个时候做了开源，且 npm 搭配 browserify 看起来是最优秀的前端（基于 CommonJS 加载规范）打包解决方案。</p>\n<p>React 从一开始就提供了 npm 构建（另加独立文件构建，<code class=\"language-text\">&lt;script&gt;</code> 标签访问）。随着 React 日益流行，借 CommonJs 规范进行 JavaScript 模块化的实践和使用 npm 发布前端代码亦得以风行。</p>\n<p>React 在 <em>production</em> 模式下，需要移除仅用于 <em>development</em> 阶段时的那部分代码。Browserify 已经提供解决此类问题的方案，因此 React 也采用了使用 <code class=\"language-text\">process.env.NODE_ENV</code> 作为环境变量的打包（npm）规范。往后，很多其它的工具和库，包括 webpack 和 VUE，都是如此。</p>\n<p>截止 2019 年，browserify 已经失去了一些关注度。然而，构建阶段替换 <code class=\"language-text\">process.env.NODE_ENV</code> 以 <code class=\"language-text\">&#39;development&#39;</code> 或 <code class=\"language-text\">&#39;production&#39;</code>，作为一个规范流行了起来。 </p>\n<p><em>（有一个有趣的问题，最终对于作为民主式的、而非仅仅专权式的 ES 模块规范的采纳，如何改变当时的常规局面的。在 Twitter 上赐教？）</em></p>\n<hr>\n<p>有件事可能依然在困扰你。为什么 React 在 GitHub 上的源代码中，你可看到 <code class=\"language-text\">__DEV__</code> 用于魔术变量。但是在 npm 仓库中 React 使用的是 <code class=\"language-text\">process.env.NODE_ENV</code>。这如何可能？</p>\n<p>以往，我们曾在源码中使用 <code class=\"language-text\">__DEV__</code> 来适应 Facebook 的源码（内部的规范）。很长一段时间，React 直接被拷贝到 Facebook 的代码库中，因此，它需要维持一致的规则。对于 npm 代码库，我们在构建发布之前，会将 <code class=\"language-text\">__DEV__</code> 检查替换为 <code class=\"language-text\">process.env.NODE_ENV !== &#39;production&#39;</code> 文本表达。</p>\n<p>这偶尔会是个问题。这种依赖 Node.js 包规范的代码形式在 npm 上能正常工作，但破坏了 Facebook 的规则，或者反过来说也是。</p>\n<p>React 16 以来，我们改变了这种方式。我们为每一种环境构建文件包（包括支持 <code class=\"language-text\">&lt;script&gt;</code> 标签引入、npm 和 Facebook 的内部代码规范）。因此，甚至 npm 仓库上的 CommonJs 代码也会提前为 <em>development</em> 和 <em>production</em> 模式分别编译独立文件。</p>\n<p>这也就是说，当 React 源代码里说 <code class=\"language-text\">if (__DEV__)</code>，我们实际上生成了两个文件。其中一个已经被预编译为 <code class=\"language-text\">__DEV__ = true</code>，另外一个，则被预编译为 <code class=\"language-text\">__DEV__ = false</code>。在入口点判断需要输出哪个文件包。</p>\n<p><a href=\"https://unpkg.com/browse/react@16.8.6/index.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">例如：</a></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">NODE_ENV</span> <span class=\"token operator\">===</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./cjs/react.production.min.js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./cjs/react.development.js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>也就只能在这里，你的打包工具将 ‘development’ 或 ‘production’ 以字符串形式插入到代码中做环境判断的地方，继而，代码压缩工具抛开 development-only 的那些依赖（<code class=\"language-text\">require</code>）。</p>\n<p><code class=\"language-text\">react.production.min.js</code> 和 <code class=\"language-text\">react.development.js</code> 二者都不会再有基于 <code class=\"language-text\">process.env.NODE_ENV</code> 的环境检查了。这非常棒，因为在 Node.js 环境中运行的时候，访问 process.env 会导致系统变慢。提前为两种模式编译好文件包，也能让我们更加一致地来优化文件大小，而不用考虑使用何种打包和压缩工具。</p>\n<p>这就是它的工作原理！</p>\n<hr>\n<p>我希望，能有一个更加首选的方式来代替对于规范的依赖，也就是我们现在遵循的这个规范。如果模式（modes）在所有的 JavaScript 环境中都是首等概念，那将会非常不错，尤其，如果浏览器能够在非 <em>development</em> 模式下为我们识别出那些运行于 <em>development</em> 模式的代码，那就更好了。</p>\n<p>另一方面，一个项目中提到的规范竟然能传播到整个生态，这十足神奇！在 2010 年，<code class=\"language-text\">EXPRESS_ENV</code> <a href=\"https://github.com/expressjs/express/commit/03b56d8140dc5c2b574d410bfeb63517a0430451\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">改成了 <code class=\"language-text\">NODE_DEV</code></a>，继而于 2013 年扩展到前端领域。也许，这个解决方案并不完美，但是，对于每个项目来说，使用它的成本一定比叫每个人搞一套自己的要低！ 这是一节关于 “自上而下推行” 和 “自下而上采纳”的课程，可谓价值十足。对于这种生态活力的把握，使得我们察觉到将来终会被广泛采纳的那些标准是什么、不是什么，这在标准化道路上可助我们避免走一些弯路。</p>\n<p>区分 development 和 production 模式是一种非常重要的技术。我建议在你的开发库、应用的时候使用这样的技术，以进行那些于生产环境不值而在开发环境却非常值得（通常非常重要、必要）的环境检测。</p>\n<p>至于一些强大的特性，你可能某种程度上错用了它们。这将是下一篇的话题！</p>","timeToRead":10,"frontmatter":{"title":"开发模式 \"Development Mode\" 是如何工作的？","date":"August 10, 2019","spoiler":"传统意义上的死码消除","cta":null},"fields":{"slug":"/zh-hans/how-does-the-development-mode-work/","langKey":"zh-hans"}}},"pageContext":{"slug":"/zh-hans/how-does-the-development-mode-work/","translations":["zh-hans","ko","pt-br","es"],"translatedLinks":[]}}}
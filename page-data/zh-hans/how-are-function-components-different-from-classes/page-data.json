{"componentChunkName":"component---src-templates-blog-post-js","path":"/zh-hans/how-are-function-components-different-from-classes/","result":{"data":{"site":{"siteMetadata":{"title":"Overreacted","author":"Dan Abramov"}},"markdownRemark":{"id":"97eb3b26-013c-523e-abfc-3215f67a10f0","html":"<p>与React类组件相比，React函数式组件究竟有何不同？</p>\n<p>在过去一段时间里，典型的回答是类组件提供了更多的特性（比如state）。当有了<a href=\"https://reactjs.org/docs/hooks-intro.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Hooks</a>后，答案就不再是这样了。</p>\n<p>或许你曾听过它们中的某一个在性能上的表现优于另一个。那是哪一个？很多此类的判断标准都存在这样那样的<a href=\"https://medium.com/@dan_abramov/this-benchmark-is-indeed-flawed-c3d6b5b6f97f?source=your_stories_page---------------------------\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">缺陷（flawed）</a>，所以我会谨慎看待从它们中<a href=\"https://github.com/ryardley/hooks-perf-issues/pull/2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">得出的结论</a>。性能主要取决于代码的作用，而不是选择函数式还是类组件。在我们的观察中，尽管优化策略各有略微<a href=\"https://reactjs.org/docs/hooks-faq.html#are-hooks-slow-because-of-creating-functions-in-render\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">不同</a>，但性能差异可以忽略不计。</p>\n<p>在任何一种情况下，除非你有其他原因并且不介意成为早期使用者，否则我们<a href=\"https://reactjs.org/docs/hooks-faq.html#should-i-use-hooks-classes-or-a-mix-of-both\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">不推荐</a>重构你现有的组件。Hooks还很年轻（如同2014年的React），并且有些“最佳实践”还没有找到它们的切入方式。</p>\n<p>那么现在是个什么情况？React的函数式组件和类组件之间是否有任何根本上的区别？当然有 —— 在心智模型上。<strong>在这篇文章中，我将阐述它们之间的最大区别。</strong> 自2015年我们<a href=\"https://reactjs.org/blog/2015/09/10/react-v0.14-rc1.html#stateless-function-components\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">推出</a>函数式组件以来，它一直存在，但是经常被忽略：</p>\n<blockquote>\n<p><strong>函数式组件捕获了渲染所用的值。（Function components capture the rendered values.）</strong></p>\n</blockquote>\n<p>让我们来看看这意味着什么。</p>\n<hr>\n<p><strong>注意：这篇文章不是对函数式组件或者类组件的价值判断。我只是在阐述在React中这两种编程模型之间的区别。关于更广泛地采用函数式组件的问题，请查看<a href=\"https://reactjs.org/docs/hooks-faq.html#adoption-strategy\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Hooks FAQ</a>。</strong></p>\n<hr>\n<p>思考这个组件:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">ProfilePage</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">showMessage</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Followed '</span> <span class=\"token operator\">+</span> props<span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">handleClick</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>showMessage<span class=\"token punctuation\">,</span> <span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>handleClick<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Follow</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>它渲染了一个利用<code class=\"language-text\">setTimeout</code>来模拟网络请求，然后显示一个确认警告的按钮。例如，如果<code class=\"language-text\">props.user</code>是<code class=\"language-text\">Dan</code>，它会在三秒后显示<code class=\"language-text\">Followed Dan</code>。非常简单。</p>\n<p><em>（请注意，在上面的示例中我是否用了箭头函数或者函数声明并不重要。<code class=\"language-text\">function handleClick()</code>也将完全以同样方式有效。）</em></p>\n<p>如果是类组件我们怎么写？一个简单的重构可能就象这样：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ProfilePage</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">showMessage</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Followed '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function-variable function\">handleClick</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>showMessage<span class=\"token punctuation\">,</span> <span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleClick<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Follow</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>通常我们认为，这两个代码片段是等效的。人们经常在这两种模式中自由的重构代码，但是很少注意到它们的含义：</p>\n<p><img src=\"/1d3c7a341ee3fcadc79df00e7d872e4b/wtf.gif\" alt=\"Spot the difference between two versions\"></p>\n<p><strong>然而，这两个代码片段还是有略微的不同。</strong> 仔细的看看它们。现在看出他们的不同了吗？就我个人而言，我花了好一会儿才看明白这一点。</p>\n<p><strong>接下来的文章是“剧透”，如果你想自己搞明白，你可以查看这个<a href=\"https://codesandbox.io/s/pjqnl16lm7\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">live demo</a>。</strong> 本文的生育部分解释了这里面的差异以及阐述了为什么这很重要。</p>\n<hr>\n<p>在我们继续之前，我想强调一点，我所描述的差异与 React Hooks 完全无关。上面的例子中甚至没有使用 Hooks！</p>\n<p>它全部是关于 React 中函数式组件与类组件的区别的。如果你打算在你的 React 应用中更频繁地使用函数式组件，你可能需要理解它。</p>\n<hr>\n<p><strong>我们将通过 React 应用程序中的一个常见错误来说明其中的不同。</strong></p>\n<p>打开这个 <strong><a href=\"https://codesandbox.io/s/pjqnl16lm7\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">sandbox 例子</a></strong>， 你将看到一个当前账号选择框以及两个上面 <code class=\"language-text\">ProfilePage</code> 的实现 —— 每个都渲染了一个 Follow 按钮。</p>\n<p>尝试按照以下顺序来分别使用这两个按钮：</p>\n<ol>\n<li><strong>点击</strong> 其中某一个 Follow 按钮。</li>\n<li>在3秒内 <strong>切换</strong> 选中的账号。</li>\n<li><strong>查看</strong> 弹出的文本。</li>\n</ol>\n<p>你将看到一个奇特的区别:</p>\n<ul>\n<li>当使用 <strong>函数式组件</strong> 实现的 <code class=\"language-text\">ProfilePage</code>, 当前账号是 Dan 时点击 Follow 按钮，然后立马切换当前账号到 Sophie，弹出的文本将依旧是 <code class=\"language-text\">&#39;Followed Dan&#39;</code>。</li>\n<li>当使用 <strong>类组件</strong> 实现的 <code class=\"language-text\">ProfilePage</code>, 弹出的文本将是 <code class=\"language-text\">&#39;Followed Sophie&#39;</code>：</li>\n</ul>\n<p><img src=\"/386a449110202d5140d67336a0ade5a0/bug.gif\" alt=\"Demonstration of the steps\"></p>\n<hr>\n<p>在这个例子中，第一个行为是正确的。<strong>如果我关注一个人，然后导航到了另一个人的账号，我的组件不应该混淆我关注了谁。</strong> 在这里，类组件的实现很明显是错误的。</p>\n<p><em>(非常推荐你 <a href=\"https://mobile.twitter.com/sophiebits\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">关注 Sophie</a>。)</em></p>\n<hr>\n<p>所以为什么我们的例子中类组件会有这样的表现？</p>\n<p>让我们来仔细看看我们类组件中的 <code class=\"language-text\">showMessage</code> 方法：</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ProfilePage</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">showMessage</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Followed '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这个类方法从 <code class=\"language-text\">this.props.user</code> 中读取数据。在 React 中 Props 是不可变(immutable)的，所以他们永远不会改变。<strong>然而，<code class=\"language-text\">this</code>是，而且永远是，可变(mutable)的。</strong></p>\n<p>事实上，这就是类组件 <code class=\"language-text\">this</code> 存在的意义。React本身会随着时间的推移而改变，以便你可以在渲染方法以及生命周期方法中得到最新的实例。</p>\n<p>所以如果在请求已经发出的情况下我们的组件进行了重新渲染，<code class=\"language-text\">this.props</code>将会改变。<code class=\"language-text\">showMessage</code>方法从一个“过于新”的<code class=\"language-text\">props</code>中得到了<code class=\"language-text\">user</code>。</p>\n<p>这暴露了一个关于用户界面性质的一个有趣观察。如果我们说UI在概念上是当前应用状态的一个函数，<strong>那么事件处理程序则是渲染结果的一部分 —— 就像视觉输出一样</strong>。我们的事件处理程序“属于”一个拥有特定 props 和 state 的特定渲染。</p>\n<p>然而，调用一个回调函数读取 <code class=\"language-text\">this.props</code> 的 timeout 会打断这种关联。我们的 <code class=\"language-text\">showMessage</code> 回调并没有与任何一个特定的渲染“绑定”在一起，所以它“失去”了正确的 props。从 this 中读取数据的这种行为，切断了这种联系。</p>\n<hr>\n<p><strong>让我们假设函数式组件不存在。</strong>我们将如何解决这个问题？</p>\n<p>我们想要以某种方式“修复”拥有正确 props 的渲染与读取这些 props 的<code class=\"language-text\">showMessage</code>回调之间的联系。在某个地方<code class=\"language-text\">props</code>被弄丢了。</p>\n<p>一种方法是在调用事件之前读取<code class=\"language-text\">this.props</code>，然后将他们显式地传递到timeout回调函数中去：</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ProfilePage</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token function-variable function\">showMessage</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">user</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span></span>    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Followed '</span> <span class=\"token operator\">+</span> user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function-variable function\">handleClick</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span>user<span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">;</span></span>    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">showMessage</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleClick<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Follow</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这种方法 <a href=\"https://codesandbox.io/s/3q737pw8lq\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">会起作用</a>。然而，这种方法使得代码明显变得更加冗长，并且随着时间推移容易出错。如果我们需要的不止是一个props怎么办？如果我们还需要访问state怎么办？<strong>如果 <code class=\"language-text\">showMessage</code> 调用了另一个方法，然后那个方法中读取了 <code class=\"language-text\">this.props.something</code> 或者 <code class=\"language-text\">this.state.something</code>，我们又将遇到同样的问题。</strong>然后我们不得不将<code class=\"language-text\">this.props</code>和<code class=\"language-text\">this.state</code>以函数参数的形式在被<code class=\"language-text\">showMessage</code>调用的每个方法中一路传递下去。</p>\n<p>这样的做法破坏了类提供的工程学。同时这也很难让人去记住传递的变量或者强制执行，这也是为什么人们总是在解决bugs。</p>\n<p>同样的，在<code class=\"language-text\">handleClick</code>中内联地写<code class=\"language-text\">alert</code>代码也无法解决问题。我们希望以允许将其拆分为多个方法的方式来构造组织代码，但同时也能读取与某次组件调用形成的渲染结果对应的props和state。<strong>这个问题并不是React所独有的 —— 你可以在任何一个将数据放入类似 <code class=\"language-text\">this</code> 这样的可变对象中的UI库中重现它。</strong></p>\n<p>或许，我们可以在构造函数中<em>绑定</em>方法？</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ProfilePage</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>showMessage <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">showMessage</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleClick <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">handleClick</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">showMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Followed '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">handleClick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>showMessage<span class=\"token punctuation\">,</span> <span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleClick<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Follow</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>不，这没有解决任何问题。记住，我们面对的问题是我们从<code class=\"language-text\">this.props</code>中读取数据太迟了——读取时已经不是我们所需要使用的上下文了！<strong>然而，如果我们能利用JavaScript闭包的话问题将迎刃而解。</strong></p>\n<p>通常来说我们会避免使用闭包，因为它会让我们<a href=\"https://wsvincent.com/javascript-closure-settimeout-for-loop/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">难以</a>想象一个可能会随着时间推移而变化的变量。但是在React中，props和state是不可变得！（或者说，在我们的强烈推荐中是不可变得。）这就消除了闭包的一个主要缺陷。</p>\n<p>这就意味着如果你在一次特定的渲染中捕获那一次渲染所用的props或者state，你会发现他们总是会保持一致，就如同你的预期那样：</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ProfilePage</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token comment\">// Capture the props!</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">const</span> props <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">;</span></span>\n    <span class=\"token comment\">// Note: we are *inside render*.</span>\n    <span class=\"token comment\">// These aren't class methods.</span>\n    <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">showMessage</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">      <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Followed '</span> <span class=\"token operator\">+</span> props<span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">handleClick</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>showMessage<span class=\"token punctuation\">,</span> <span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>handleClick<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Follow</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>你在渲染的时候就已经“捕获”了props：</strong></p>\n<p><img src=\"/fa483dd5699aac1350c57591770a49be/pokemon.gif\" alt=\"Capturing Pokemon\"></p>\n<p>这样，在它内部的任何代码（包括<code class=\"language-text\">showMessage</code>）都保证可以得到这一次特定渲染所使用的props。React再也不会“动我们的奶酪”。</p>\n<p><strong>然后我们可以在里面添加任意多的辅助函数，它们都会使用被捕获的props和state。</strong>闭包万岁！</p>\n<hr>\n<p>上面的<a href=\"https://codesandbox.io/s/oqxy9m7om5\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">例子</a>是正确的，但是看起来很奇怪。如果你在<code class=\"language-text\">render</code>方法中定义各种函数，而不是使用class的方法，那么使用类的意义在哪里？</p>\n<p>事实上，我们可以通过删除类的“包裹”来简化代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">ProfilePage</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">showMessage</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Followed '</span> <span class=\"token operator\">+</span> props<span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">handleClick</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>showMessage<span class=\"token punctuation\">,</span> <span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>handleClick<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Follow</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>就像上面这样，<code class=\"language-text\">props</code>仍旧被捕获了 —— React将它们作为参数传递。<strong>不同于<code class=\"language-text\">this</code>，<code class=\"language-text\">props</code>对象本身永远不会被React改变。</strong></p>\n<p>如果你在函数定义中解构<code class=\"language-text\">props</code>，那将更加明显：</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"gatsby-highlight-code-line\"><span class=\"token keyword\">function</span> <span class=\"token function\">ProfilePage</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> user <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span></span>  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">showMessage</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Followed '</span> <span class=\"token operator\">+</span> user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">handleClick</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>showMessage<span class=\"token punctuation\">,</span> <span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>handleClick<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Follow</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>当父组件使用不同的props来渲染<code class=\"language-text\">ProfilePage</code>时，React会再次调用<code class=\"language-text\">ProfilePage</code>函数。但是我们点击的事件处理函数，“属于”具有自己的<code class=\"language-text\">user</code>值的上一次渲染，并且<code class=\"language-text\">showMessage</code>回调函数也能读取到这个值。它们都保持完好无损。</p>\n<p>这就是为什么，在上面那个<a href=\"https://codesandbox.io/s/pjqnl16lm7\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">demo</a>的函数式版本中，点击关注Sophie的账号，然后改变选择为Sunil仍旧会弹出<code class=\"language-text\">&#39;Followed Sophie&#39;</code>：</p>\n<p><img src=\"/84396c4b3982827bead96912a947904e/fix.gif\" alt=\"Demo of correct behavior\"></p>\n<p>这个行为展现是正确的 <em>(同时你也可能会想要 <a href=\"https://mobile.twitter.com/threepointone\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">关注Sunil</a>!)</em></p>\n<hr>\n<p>现在我们明白了React中函数式组件和类组件之间的巨大差别：</p>\n<blockquote>\n<p><strong>函数式组件捕获了渲染所使用的值。</strong></p>\n</blockquote>\n<p><strong>使用Hooks，同样的原则也适用于state。</strong> 看这个例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">MessageThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>message<span class=\"token punctuation\">,</span> setMessage<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">showMessage</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'You said: '</span> <span class=\"token operator\">+</span> message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">handleSendClick</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>showMessage<span class=\"token punctuation\">,</span> <span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">handleMessageChange</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setMessage</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">value</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>message<span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">onChange</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>handleMessageChange<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>handleSendClick<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Send</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>（这是<a href=\"https://codesandbox.io/s/93m5mz9w24\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">演示demo</a>。）</p>\n<p>尽管这不是一个非常好的消息应用的UI，但它说明了同样的观点：如果我发送一条特定的消息，组件不应该对实际发送的是哪条消息感到困惑。这个函数组件的<code class=\"language-text\">message</code>变量捕获了“属于”返回了被浏览器调用的单击处理函数的那一次渲染。所以当我点击“发送”时<code class=\"language-text\">message</code>被设置为那一刻在input中输入的内容。</p>\n<hr>\n<p>因此我们知道，在默认情况下React中的函数会捕获props和state。<strong>但是如果我们想要读取并不属于这一次特定渲染的，最新的props和state呢？</strong>如果我们想要<a href=\"https://dev.to/scastiel/react-hooks-get-the-current-state-back-to-the-future-3op2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">“从未来读取他们”</a>呢？</p>\n<p>在类中，你通过读取<code class=\"language-text\">this.props</code>或者<code class=\"language-text\">this.state</code>来实现，因为<code class=\"language-text\">this</code>本身时可变的。React改变了它。在函数式组件中，你也可以拥有一个在所有的组件渲染帧中共享的可变变量。它被成为“ref”：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">MyComponent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> ref <span class=\"token operator\">=</span> <span class=\"token function\">useRef</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// You can read or write `ref.current`.</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>但是，你必须自己管理它。</p>\n<p>一个ref与一个实例字段<a href=\"https://reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">扮演同样的角色</a>。这是进入可变的命令式的世界的后门。你可能熟悉’DOM refs’，但是ref在概念上更为广泛通用。它只是一个你可以放东西进去的盒子。</p>\n<p>甚至在视觉上，<code class=\"language-text\">this.something</code>就像是<code class=\"language-text\">something.current</code>的一个镜像。他们代表了同样的概念。</p>\n<p>默认情况下，React不会在函数式组件中为最新的props和state创造refs。在很多情况下，你并不需要它们，并且分配它们将是一种浪费。但是，如果你愿意，你可以这样手动地来追踪这些值：</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">MessageThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>message<span class=\"token punctuation\">,</span> setMessage<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token keyword\">const</span> latestMessage <span class=\"token operator\">=</span> <span class=\"token function\">useRef</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">showMessage</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'You said: '</span> <span class=\"token operator\">+</span> latestMessage<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">handleSendClick</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>showMessage<span class=\"token punctuation\">,</span> <span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">handleMessageChange</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setMessage</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"gatsby-highlight-code-line\">    latestMessage<span class=\"token punctuation\">.</span>current <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span></span>  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>如果我们在<code class=\"language-text\">showMessage</code>中读取<code class=\"language-text\">message</code>，我们将得到在我们按下发送按钮那一刻的信息。但是当我们读取<code class=\"language-text\">latestMessage.current</code>，我们将得到最新的值 —— 即使我们在按下发送按钮后继续输入。</p>\n<p>你可以自行查看<a href=\"https://codesandbox.io/s/93m5mz9w24\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">这</a> <a href=\"https://codesandbox.io/s/ox200vw8k9\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">俩</a>demo来比较它们之间的不同。ref是一种“选择退出”渲染一致性的方法，在某些情况下会十分方便。</p>\n<p>通常情况下，你应该避免在渲染<em>期间</em>读取或者设置refs，因为它们是可变得。我们希望保持渲染的可预测性。<strong>然而，如果我们想要特定props或者state的最新值，那么手动更新ref会有些烦人。</strong>我们可以通过使用一个effect来自动化实现它：</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">MessageThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>message<span class=\"token punctuation\">,</span> setMessage<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token comment\">// 保持追踪最新的值。</span></span><span class=\"gatsby-highlight-code-line\">  <span class=\"token keyword\">const</span> latestMessage <span class=\"token operator\">=</span> <span class=\"token function\">useRef</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span></span><span class=\"gatsby-highlight-code-line\">    latestMessage<span class=\"token punctuation\">.</span>current <span class=\"token operator\">=</span> message<span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">showMessage</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'You said: '</span> <span class=\"token operator\">+</span> latestMessage<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>(这是<a href=\"https://codesandbox.io/s/yqmnz7xy8x\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">demo</a>。)</p>\n<p>我们在一个effect<em>内部</em>执行赋值操作以便让ref的值只会在DOM被更新后才会改变。这确保了我们的变量突变不会破坏依赖于可中断渲染的<a href=\"https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">时间切片和 Suspense</a>等特性。</p>\n<p>通常来说使用这样的ref并不是非常地必要。<strong>捕获props和state通常是更好的默认值。</strong>然而，在处理类似于intervals和订阅这样的<a href=\"/making-setinterval-declarative-with-react-hooks/\">命令式API</a>时，ref会十分便利。记住，你可以像这样跟踪<em>任何</em>值 —— 一个prop，一个state变量，整个props对象，或者甚至一个函数。</p>\n<p>这种模式对于优化来说也很方便 —— 例如当<code class=\"language-text\">useCallback</code>本身经常改变时。然而，<a href=\"https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">使用一个reducer</a>通常是一个<a href=\"https://github.com/ryardley/hooks-perf-issues/pull/3\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">更好的解决方式</a>。（未来博客文章的主题！）</p>\n<hr>\n<p>在这篇文章中，我们已经看过了类组件中常见的破碎模式，以及闭包如何帮助我们修复它。然而，你可能注意到，当你尝试通过指定一个依赖数组来优化Hooks时，你可能会遇到带有过时闭包的问题。这是否意味着闭包是一个问题？我不这么认为。</p>\n<p>正如我们上面看到的，闭包实际上帮我们<em>解决</em>了很难注意到的细微问题。同样，它们也使得在<a href=\"https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">并发模式</a>下能更轻松地编写能够正确运行的代码。这是可行的，因为组件内部的逻辑在渲染它时捕获并包含了正确的props和state。</p>\n<p>目前为止我看到的所有情况中，<strong>所谓的“陈旧的闭包”问题的出现多是由于错误的假设了“函数不会改变”或者“props永远是一样的”</strong>。事实并非如此，而我希望这篇文章有助于澄清这一点。</p>\n<p>函数捕获了他们的props和state —— 因此它们的标识也同样重要。这不是一个bug，而是一个函数式组件的特性。例如，对于<code class=\"language-text\">useEffect</code>或者<code class=\"language-text\">useCallback</code>来说，函数不应该被排除在“依赖数组”之外。（正确的解决方案通常是使用上面说过的<code class=\"language-text\">useReducer</code>或者<code class=\"language-text\">useRef</code> —— 我们将很快会在文档中说明如何在它们两者中进行选择。）</p>\n<p>当我们用函数来编写大部分的React代码时，我们需要调整关于<a href=\"https://github.com/ryardley/hooks-perf-issues/pull/3\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">优化代码</a>和<a href=\"https://github.com/facebook/react/issues/14920\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">什么变量会随着时间改变</a>的认知与直觉。</p>\n<p>正如<a href=\"https://mobile.twitter.com/EphemeralCircle/status/1099095063223812096\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Fredrik所说</a>：</p>\n<blockquote>\n<p>到目前为止，我发现的有关于hooks的最好的心里规则是“写代码时要认为任何值都可以随时更改”。</p>\n</blockquote>\n<p>函数也不例外。这需要一段时间才能成为React学习资料中的常识。它需要一些从类的思维方式中进行一些调整。但我希望这篇文章能够帮助你以新的眼光来看待它。</p>\n<p>React函数总是捕获他们的值 —— 现在我们也知道这是为什么了。</p>\n<p><img src=\"/fc3bddf6d4ca14bc77917ac0cfad3608/pikachu.gif\" alt=\"Smiling Pikachu\"></p>\n<p>它们是完全不同的宝可梦哦。</p>","timeToRead":14,"frontmatter":{"title":"函数式组件与类组件有何不同？","date":"March 03, 2019","spoiler":"他们是完全不同的宝可梦哦。","cta":null},"fields":{"slug":"/zh-hans/how-are-function-components-different-from-classes/","langKey":"zh-hans"}}},"pageContext":{"slug":"/zh-hans/how-are-function-components-different-from-classes/","translations":["fr","es","ja","ko","pl","zh-hans","pt-br"],"translatedLinks":["/making-setinterval-declarative-with-react-hooks/"]}}}
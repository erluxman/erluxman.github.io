{"componentChunkName":"component---src-templates-blog-post-js","path":"/zh-hans/why-do-we-write-super-props/","result":{"data":{"site":{"siteMetadata":{"title":"Overreacted","author":"Dan Abramov"}},"markdownRemark":{"id":"2ecfaa25-e58f-552b-be05-9fcb7951b532","html":"<p>据说 <a href=\"https://reactjs.org/docs/hooks-intro.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Hooks</a> 势头正盛，不过我还是想略带调侃地从 <em>class</em> 的有趣之处开始这篇博客。可还行？</p>\n<p><strong>这些梗对于使用 React 输出产品并<em>不</em>重要，但如果你想深入的了解它们的运作原理，它们会非常的有用。</strong></p>\n<hr>\n<p>首先，在这一生中，<code class=\"language-text\">super(props)</code> 出现在我代码里的次数比我知道的还要多：</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>当然了，我们可以通过 <a href=\"https://github.com/tc39/proposal-class-fields\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">class fields proposal</a> 来省略这个声明：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>早在 2015 年 React 0.13 已经<a href=\"https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#es7-property-initializers\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">计划支持</a> 。在当时，声明 <code class=\"language-text\">constructor</code> 和调用 <code class=\"language-text\">super(props)</code> 一直被视作暂时的解决方案，直到有合适的类字段声明形式。</p>\n<p>但在此之前，我们先回到 ES2015 风格的代码：</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>为什么我们要调用 <code class=\"language-text\">super</code>，我们可以不这么做吗？那么在我们调用它时不传入 <code class=\"language-text\">props</code>，又会发生什么呢？会有其他的缺省参数吗？</strong>接来下我们就解开这一系列谜题。</p>\n<hr>\n<p>在 JavaScript 中，<code class=\"language-text\">super</code> 指的是父类（即超类）的构造函数。（在我们的例子中，它指向了 <code class=\"language-text\">React.Component</code> 的实现。）</p>\n<p>值得注意的是，在调用父类的构造函数之前，你是不能在 constructor 中使用 <code class=\"language-text\">this</code> 关键字的。JavaScript 不允许这个行为。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Checkbox</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 🔴  还不能使用 `this`</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ✅  现在可以了</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>JavaScript 有足够合理的动机来强制你在接触 <code class=\"language-text\">this</code> 之前执行父类构造函数。考虑考虑一些类层次结构的东西：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">PolitePerson</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">greetColleagues</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 🔴  这是禁止的，往后见原因</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">greetColleagues</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Good morning folks!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>试想一下，在调用 <code class=\"language-text\">super</code> 之前使用 <code class=\"language-text\">this</code> 不被禁止的情况下，一个月后，我们可能在 <code class=\"language-text\">greetColleagues</code> 打印的消息中使用了 person 的 name 属性：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">  <span class=\"token function\">greetColleagues</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Good morning folks!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'My name is '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">+</span> <span class=\"token string\">', nice to meet you!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>但是我们并未想起 <code class=\"language-text\">this.greetColleagues</code> 在 <code class=\"language-text\">super()</code> 给 <code class=\"language-text\">this.name</code> 赋值前就已经执行。<code class=\"language-text\">this.name</code> 此时甚至尚未定义。可以看到，这样的代码难以往下推敲。</p>\n<p>为了避免落入这个陷阱，<strong>JavaScript 强制你在使用 <code class=\"language-text\">this</code> 之前先行调用 <code class=\"language-text\">super</code>。</strong>让父类来完成这件事情！：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ✅ 能使用 `this` 了</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> isOn<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里留下了另一个问题：为什么要传入 <code class=\"language-text\">props</code> ？</p>\n<hr>\n<p>你或许会想到，为了让 React.Component 构造函数能够初始化 <code class=\"language-text\">this.props</code>，将 <code class=\"language-text\">props</code> 传入 <code class=\"language-text\">super</code> 是必须的：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// React 內部</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这几乎就是真相了 — 确然，它是 <a href=\"https://github.com/facebook/react/blob/1d25aa5787d4e19704c049c3cfa985d3b5190e0d/packages/react/src/ReactBaseClasses.js#L22\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">这样做</a> 的。</p>\n<p>但有些扑朔迷离的是，即便你调用 <code class=\"language-text\">super()</code> 的时候没有传入 <code class=\"language-text\">props</code>，你依然能够在 <code class=\"language-text\">render</code> 函数或其他方法中访问到 <code class=\"language-text\">this.props</code>。（如果你质疑这个机制，尝试一下即可）</p>\n<p>那么这是怎么做到的呢？事实证明，React 在调用构造函数后也立即将 <code class=\"language-text\">props</code> 赋值到了实例上：**</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">  <span class=\"token comment\">// React 内部</span>\n  <span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">YourComponent</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  instance<span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span></code></pre></div>\n<p>因此即便你忘记了将 <code class=\"language-text\">props</code> 传给 <code class=\"language-text\">super()</code>，React 也仍然会在之后将它定义到实例上。这么做是有原因的。</p>\n<p>当 React 增加了对类的支持时，不仅仅是为了服务于 ES6。其目标是尽可能广泛地支持类抽象。当时我们 <a href=\"https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#other-languages\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">不清楚</a>  ClojureScript，CoffeeScript，ES6，Fable，Scala.js，TypeScript 等解決方案是如何成功的实践组件定义的。因而 React 刻意地没有显式要求调用 <code class=\"language-text\">super()</code> —— 即便 ES6 自身就包含这个机制。</p>\n<p>这意味着你能够用 <code class=\"language-text\">super()</code> 代替 <code class=\"language-text\">super(props)</code> 吗？</p>\n<p><strong>最好不要，毕竟这样写在逻辑上并不明确</strong>确然，React 会在构造函数执行完毕<em>之后</em>给 <code class=\"language-text\">this.props</code> 赋值。但如此为之会使得 <code class=\"language-text\">this.props</code> 在 <code class=\"language-text\">super</code> 调用<em>一直到构造函数结束期间</em>值为 undefined。</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// React 內部</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 你的程式碼內部</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Button</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 😬 我们忘了传入 props</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">// ✅ {}</span>\n<span class=\"gatsby-highlight-code-line\">    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 😬 未定义</span></span>  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>如果在构造函数中调用了其他的内部方法，那么一旦出错这会使得调试过程阻力更大。<strong>这就是我建议开发者一定执行 <code class=\"language-text\">super(props)</code> 的原因，即使理论上这并非必要：</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Button</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ 传入 props</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">// ✅ {}</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ {}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>确保了 <code class=\"language-text\">this.props</code> 在构造函数执行完毕之前已被赋值。</p>\n<hr>\n<p>最后，还有一点是 React 爱好者长期以来的好奇之处。</p>\n<p>你会发现当你在类中使用 Context API （无论是旧版的 <code class=\"language-text\">contextTypes</code> 或是在 React 16.6 更新的新版 <code class=\"language-text\">contextTypes</code>）的时候，<code class=\"language-text\">context</code> 是作为第二个参数传入构造函数的。</p>\n<p>那么为什么我们不能转而写成 <code class=\"language-text\">super(props, context)</code> 呢？我们当然可以，但 context 的使用频率较低，因而并没有掘这个坑。</p>\n<p><strong>class fields proposal 出台后，这些坑大部分都会自然地消失</strong>在没有显示的定义构造函数的情况下，以上的属性都会被自动地初始化。这使得像 <code class=\"language-text\">state = {}</code> 这类表达式能够在需要的情况下引用 <code class=\"language-text\">this.props</code> 和 <code class=\"language-text\">this.context</code> 的内容。</p>\n<p>然而，有了 Hooks 以后，我们几乎就不需要 <code class=\"language-text\">super</code> 和 <code class=\"language-text\">this</code> 了。但那就是另一个下午的茶点了。</p>","timeToRead":5,"frontmatter":{"title":"为什么我们要写 super(props) ？","date":"November 30, 2018","spoiler":"结尾处有彩蛋。","cta":null},"fields":{"slug":"/zh-hans/why-do-we-write-super-props/","langKey":"zh-hans"}}},"pageContext":{"slug":"/zh-hans/why-do-we-write-super-props/","translations":["cs","de","fr","fa","es","hu","it","ja","my","nb","sr","pl","sk","pt-br","nl","th","uk","vi","tr","zh-hant","zh-hans"],"translatedLinks":[]}}}
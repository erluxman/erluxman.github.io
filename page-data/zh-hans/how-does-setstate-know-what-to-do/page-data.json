{"componentChunkName":"component---src-templates-blog-post-js","path":"/zh-hans/how-does-setstate-know-what-to-do/","result":{"data":{"site":{"siteMetadata":{"title":"Overreacted","author":"Dan Abramov"}},"markdownRemark":{"id":"f4a961df-065d-5040-a1e7-af9a48c697fb","html":"<p>当你在组件中调用<code class=\"language-text\">setState</code>的时候，你认为发生了些什么？</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> ReactDOM <span class=\"token keyword\">from</span> <span class=\"token string\">'react-dom'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Button</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> clicked<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleClick <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">handleClick</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">handleClick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> clicked<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>clicked<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Thanks</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleClick<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"></span>\n<span class=\"token plain-text\">        Click me!</span>\n<span class=\"token plain-text\">      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Button</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">,</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'container'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>当然是：React根据下一个状态<code class=\"language-text\">{clicked：true}</code>重新渲染组件，同时更新DOM以匹配返回的<code class=\"language-text\">&lt;h1&gt;Thanks&lt;/ h1&gt;</code>元素啊。</p>\n<p>看起来很直白。但是等等，是 <em>React</em>做了这些吗？还是<em>React DOM</em>？</p>\n<p>更新DOM听起来像是React DOM的职责所在。但是我们调用的是<code class=\"language-text\">this.setState()</code>，而没有调用\b任何来自React DOM的东西。 而且我们组件的父类<code class=\"language-text\">React.Component</code>也是在React本身定义的。</p>\n<p>所以存在于<code class=\"language-text\">React.Component</code>\b内部的<code class=\"language-text\">setState()</code>是如何更新DOM的呢？</p>\n<p><strong>免责声明: 就像本博客里<a href=\"/why-do-react-elements-have-typeof-property/\">绝大多数</a> <a href=\"/how-does-react-tell-a-class-from-a-function/\">其他的</a> <a href=\"/why-do-we-write-super-props/\">帖子</a>一样， 其实你不<em>需要</em>知道其中的任何知识，就可以有效地使用React。\b本文面向的是那些想要了解React背后原理的人。而这完全是可选的！\b</strong></p>\n<hr>\n<p>我们或许会认为：<code class=\"language-text\">React.Component</code>类包含了DOM\b更新的逻辑。</p>\n<p>但是如果是这样的话，<code class=\"language-text\">this.setState()</code>又如何能在其他环境下使用呢？举个例子，React Native app中的组件也是\b继承自<code class=\"language-text\">React.Component</code>。他们依然可以像我们在上面做的那样调用<code class=\"language-text\">this.setState()</code>，而且React Native\b渲染的是安卓和iOS原生的\b界面而不是DOM。</p>\n<p>你或许对React Test Renderer 或是 Shallow Renderer很熟悉。这些测试策略能让你\b正常渲染组件，\b也可以在组件内部调用<code class=\"language-text\">this.setState()</code>。但是这两个渲染器并不与DOM相关。</p>\n<p>如果你曾使用过一些渲染器像<a href=\"https://github.com/facebook/react/tree/master/packages/react-art\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React ART</a>，你也许也知道在一个页面中我们是可以使用多个渲染器的。（举个例子，ART 组件在React DOM树的内部起作用。）这使得全局标志或变量无法维持。</p>\n<p>因此，<strong><code class=\"language-text\">React.Component</code>以某种未知的方式将处理\b状态（state）更新的任务委托给了特定平台的代码。</strong>在我们理解这些是如何发生的之前，让我们深挖一下包（packages）是如何分离的以及为什么这样分离。</p>\n<hr>\n<p>有一个很常见的误解就是React“引擎”是存在于<code class=\"language-text\">react</code>包里面的。 然而事实并非如此。</p>\n<p>实际上从<a href=\"https://reactjs.org/blog/2015/07/03/react-v0.14-beta-1.html#two-packages\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React 0.14</a>我们将代码拆分成多个包以来，<code class=\"language-text\">react</code>包故意\b只暴露一些定义组件的API。绝大多数React的\b<em>实现</em>都存在于“渲染器（renderers）”中。</p>\n<p><code class=\"language-text\">react-dom</code>、<code class=\"language-text\">react-dom/server</code>、 <code class=\"language-text\">react-native</code>、 <code class=\"language-text\">react-test-renderer</code>、 <code class=\"language-text\">react-art</code>都是常见的渲染器（当然你也可以<a href=\"https://github.com/facebook/react/blob/master/packages/react-reconciler/README.md#practical-examples\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">创建属于你的渲染器</a>）。</p>\n<p>\b这就是为什么不管你的目标平台是什么，<code class=\"language-text\">react</code>包都是可用的。从<code class=\"language-text\">react</code>包中导出的一切，比如<code class=\"language-text\">React.Component</code>、<code class=\"language-text\">React.createElement</code>、 <code class=\"language-text\">React.Children</code> 和（最终的）<a href=\"https://reactjs.org/docs/hooks-intro.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Hooks</a>，都是独立于目标平台的。无论你是运行React DOM，还是 React DOM Server,或是 React Native，你的组件都可以使用同样的方式导入和使用。</p>\n<p>相比之下，渲染器包\b暴露的都是特定平台的API\b，比如说：<code class=\"language-text\">ReactDOM.render()</code>，可以让你将React层次结构（hierarchy）挂载进一个DOM节点。每一种渲染器都提供了类似的API。理想状况下，绝大多数<em>组件</em>都不应该从渲染器中导入任何东西。只有这样，组件才会更加灵活。</p>\n<p><strong>和大多数人现在想的一样，React “引擎”就是存在于各个渲染器的内部。</strong>很多渲染器包含一份\b同样代码的复制 —— 我们称为<a href=\"https://github.com/facebook/react/tree/master/packages/react-reconciler\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">“协调器”(“reconciler”)</a>。<a href=\"https://reactjs.org/blog/2017/12/15/improving-the-repository-infrastructure.html#migrating-to-google-closure-compiler\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">构建步骤(build step)</a>将协调器代码和渲染器代码\b平滑地整合成一个高度优化的捆绑包（bundle）以获得更高的性能。（代码复制通常来说不利于控制捆绑包的大小，但是\b绝大多数React用户同一时间只会选用一个渲染器，比如说<code class=\"language-text\">react-dom</code>。）</p>\n<p>这里要注意的是： <code class=\"language-text\">react</code>包仅仅是让你<em>使用</em>\b React 的特性，但是它完全不知道这些特性是<em>如何</em>实现的。而渲染器包(<code class=\"language-text\">react-dom</code>、<code class=\"language-text\">react-native</code>等)提供了React特性\b的实现以及平台特定的逻辑。这其中的有些代码是共享的(“协调\b器”)，但是这就涉及到各个渲染器的实现细节了。</p>\n<hr>\n<p>现在我们知道为什么当我们想使用新特性时，<code class=\"language-text\">react</code> 和 <code class=\"language-text\">react-dom</code><em>都</em>需要被更新。举个例子，当React 16.3添加了Context API，<code class=\"language-text\">React.createContext()</code>API会被React包暴露出来。</p>\n<p>但是<code class=\"language-text\">React.createContext()</code> 其实并没有<em>实现</em> context。因为在React DOM 和 React DOM Server 中同样一个 API 应当有不同的实现。所以<code class=\"language-text\">createContext()</code>只返回了一些普通对象：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 简化版代码</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">createContext</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">defaultValue</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> context <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    _currentValue<span class=\"token operator\">:</span> defaultValue<span class=\"token punctuation\">,</span>\n    Provider<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n    Consumer<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  context<span class=\"token punctuation\">.</span>Provider <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    $$<span class=\"token keyword\">typeof</span><span class=\"token operator\">:</span> Symbol<span class=\"token punctuation\">.</span><span class=\"token function\">for</span><span class=\"token punctuation\">(</span><span class=\"token string\">'react.provider'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    _context<span class=\"token operator\">:</span> context\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  context<span class=\"token punctuation\">.</span>Consumer <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    $$<span class=\"token keyword\">typeof</span><span class=\"token operator\">:</span> Symbol<span class=\"token punctuation\">.</span><span class=\"token function\">for</span><span class=\"token punctuation\">(</span><span class=\"token string\">'react.context'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    _context<span class=\"token operator\">:</span> context<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> context<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>当你在代码中使用 <code class=\"language-text\">&lt;MyContext.Provider&gt;</code> 或 <code class=\"language-text\">&lt;MyContext.Consumer&gt;</code>的时候， 是<em>渲染器</em>\b决定如何处理这些接口。React DOM也许用某种方式追踪context的值，但是React DOM Server用的可能是另一种不同的方式。</p>\n<p><strong>所以，如果你将<code class=\"language-text\">react</code>升级到了16.3+，但是不更新<code class=\"language-text\">react-dom</code>，那么你就使用了一个尚不知道\b<code class=\"language-text\">Provider</code> 和 <code class=\"language-text\">Consumer</code>类型的渲染器。</strong>这就是为什么一个老版本的<code class=\"language-text\">react-dom</code>会<a href=\"https://stackoverflow.com/a/49677020/458193\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">\b\b报错说这些类型是无效的</a>。</p>\n<p>\b同样的警告也会出现在React Native中。然而不同于React DOM的是， 一个React新版本的发布并不立即“强制”发布新的 React Native 版本。他们具有独立的发布日程。 每隔几周，更新后的渲染器代码就会<a href=\"https://github.com/facebook/react-native/commits/master/Libraries/Renderer/oss\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">单独同步到</a>React Native仓库。这就是相比 React DOM，React Native 特性可用时间不同的原因。</p>\n<hr>\n<p>好吧，所以现在我们知道了<code class=\"language-text\">react</code>包并不包含任何有趣的东西，\b除此之外，具体的实现也\b是存在于<code class=\"language-text\">react-dom</code>，<code class=\"language-text\">react-native</code>之类的渲染器中。但是这并没有回答我们的问题。<code class=\"language-text\">React.Component</code>中的<code class=\"language-text\">setState()</code>如何与正确的渲染器“对话”？\b</p>\n<p><strong>答案是：每个渲染器都在已创建的类上设置了一个特殊的字段。</strong>这个字段叫做<code class=\"language-text\">updater</code>。这并不是<em>你</em>要设置的的东西——而是，React DOM、React DOM Server 或 React Native在创建完你的\b类的实例之后会立即设置的东西：</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// React DOM 内部</span>\n<span class=\"token keyword\">const</span> inst <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">YourComponent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ninst<span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n<span class=\"gatsby-highlight-code-line\">inst<span class=\"token punctuation\">.</span>updater <span class=\"token operator\">=</span> ReactDOMUpdater<span class=\"token punctuation\">;</span></span>\n<span class=\"token comment\">// React DOM Server 内部</span>\n<span class=\"token keyword\">const</span> inst <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">YourComponent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ninst<span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n<span class=\"gatsby-highlight-code-line\">inst<span class=\"token punctuation\">.</span>updater <span class=\"token operator\">=</span> ReactDOMServerUpdater<span class=\"token punctuation\">;</span></span>\n<span class=\"token comment\">// React Native 内部</span>\n<span class=\"token keyword\">const</span> inst <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">YourComponent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ninst<span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n<span class=\"gatsby-highlight-code-line\">inst<span class=\"token punctuation\">.</span>updater <span class=\"token operator\">=</span> ReactNativeUpdater<span class=\"token punctuation\">;</span></span></code></pre></div>\n<p>查看<a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react/src/ReactBaseClasses.js#L58-L67\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"> <code class=\"language-text\">React.Component</code>中<code class=\"language-text\">setState</code>的实现</a>，\n<code class=\"language-text\">setState</code>所做的一切就是委托渲染器创建这个组件的实例：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 适当简化的代码</span>\n<span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">partialState<span class=\"token punctuation\">,</span> callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 使用`updater`字段回应渲染器！</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>updater<span class=\"token punctuation\">.</span><span class=\"token function\">enqueueSetState</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> partialState<span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>React DOM Server <a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-dom/src/server/ReactPartialRenderer.js#L442-L448\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">也许想</a> 忽略一个状态更新\b并且警告你，而React DOM 与 React Native却想要让他们协调器（reconciler）的副本<a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-reconciler/src/ReactFiberClassComponent.js#L190-L207\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">处理它</a>。</p>\n<p>这就是this.setState()<code class=\"language-text\">尽管定义在React包中，却能够\b更新DOM的原因。它\b读取由React DOM设置的</code>this.updater`，让React DOM安排并处理更新。</p>\n<hr>\n<p>\b现在关于类的部分我们已经知道了，那关于Hooks的呢？</p>\n<p>当人们第一次看见<a href=\"https://reactjs.org/docs/hooks-intro.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Hooks proposal API</a>，\b他们\b可能经常会想： <code class=\"language-text\">useState是</code>怎么 “知道要做什么”的？然后假设它比那些\b\b包含<code class=\"language-text\">this.setState()</code>的<code class=\"language-text\">React.Component</code>类更“神奇”。</p>\n<p>但是正如我们今天所看到的，基类中<code class=\"language-text\">setState()</code>的执行一直以来都是一种错觉。它除了将调用转发给当前的渲染器外，什么也没做\b。<code class=\"language-text\">useState</code> Hook<a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react/src/ReactHooks.js#L55-L56\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">也是做了同样的事情</a>。</p>\n<p><strong>Hooks使用了一个“dispatcher”对象，代替了<code class=\"language-text\">updater</code>字段。</strong>当你调用<code class=\"language-text\">React.useState()</code>\b、<code class=\"language-text\">React.useEffect()</code>、 或者其他内置的Hook时，这些调用被转发给了当前的dispatcher。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// React内部(适当简化)</span>\n<span class=\"token keyword\">const</span> React <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 真实属性隐藏的比较深，看你能不能找到它！</span>\n  __currentDispatcher<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n\n  <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">initialState</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> React<span class=\"token punctuation\">.</span>__currentDispatcher<span class=\"token punctuation\">.</span><span class=\"token function\">useState</span><span class=\"token punctuation\">(</span>initialState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">initialState</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> React<span class=\"token punctuation\">.</span>__currentDispatcher<span class=\"token punctuation\">.</span><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span>initialState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>各个渲染器会在渲染你的组件之前设置dispatcher：</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// React DOM 内部</span>\n<span class=\"token keyword\">const</span> prevDispatcher <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span>__currentDispatcher<span class=\"token punctuation\">;</span>\n<span class=\"gatsby-highlight-code-line\">React<span class=\"token punctuation\">.</span>__currentDispatcher <span class=\"token operator\">=</span> ReactDOMDispatcher<span class=\"token punctuation\">;</span></span><span class=\"token keyword\">let</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n  result <span class=\"token operator\">=</span> <span class=\"token function\">YourComponent</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token comment\">// 恢复原状</span></span><span class=\"gatsby-highlight-code-line\">  React<span class=\"token punctuation\">.</span>__currentDispatcher <span class=\"token operator\">=</span> prevDispatcher<span class=\"token punctuation\">;</span></span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>举个例子， React DOM Server的实现是在\b<a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-dom/src/server/ReactPartialRendererHooks.js#L340-L354\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">这里</a>，还有就是React DOM 和 React Native共享的协调器的实现在<a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-reconciler/src/ReactFiberHooks.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">这里</a>。</p>\n<p>这就是为什么像<code class=\"language-text\">react-dom</code>这样的渲染器需要\b访问那个你调用Hooks的<code class=\"language-text\">react</code>包。否则你的组件将不会\b“看见”dispatcher！如果在一个组件树中存在<a href=\"https://github.com/facebook/react/issues/13991\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React的多个副本</a>，\b也许并不会这样。但是，这总是导致了一些模糊的错误，因此Hooks会强迫你在出现问题之前解决包的重复问题。</p>\n<p>在高级工具用例中，你可以\b在技术上覆盖dispatcher，尽管我们不鼓励这种操作。（对于<code class=\"language-text\">__currentDispatcher</code>这个名字我撒谎了，但是你可以在React仓库中找到真实的名字。）\b比如说， React DevTools将会使用<a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-debug-tools/src/ReactDebugHooks.js#L203-L214\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">\b一个专门定制的dispatcher</a>通过捕获JavaScript堆栈跟踪来观察Hooks树。<em>请勿模仿。</em></p>\n<p>这也意味着Hooks\b本质上并没有与React绑定在一起。如果未来有更多的库想要重用同样的原生的Hooks, 理论上来说dispatcher可以\b移动到一个分离的包中，然后暴露成一个一等（first-class）的API，然后给它起一个不那么“吓人\b”的名字。但是在实践中，我们会尽量\b避免过早抽象，直到需要它为止。</p>\n<p><code class=\"language-text\">updater</code>字段和<code class=\"language-text\">__currentDispatcher</code>对象都是称为<em>依赖注入</em>的通用编程原则的形式。在这两种情况下，渲染器将诸如<code class=\"language-text\">setState</code>之类的功能的实现“注入”到通用的React包中，以使组件更具声明性。</p>\n<p> 使用React时，你无需考虑这其中的原理。我们希望React用户花更多时间考虑他们的应用程序代码，而不是像依赖注入这样的抽象概念。但是如果你想知道<code class=\"language-text\">this.setState()</code>或<code class=\"language-text\">useState()</code>是如何知道该做什么的，我希望这篇文章会有所帮助。</p>\n<hr>","timeToRead":10,"frontmatter":{"title":"setState如何知道该做什么？","date":"December 09, 2018","spoiler":"依赖注入是非常不错的技术，如果你不必考虑的话。","cta":null},"fields":{"slug":"/zh-hans/how-does-setstate-know-what-to-do/","langKey":"zh-hans"}}},"pageContext":{"slug":"/zh-hans/how-does-setstate-know-what-to-do/","translations":["es","fr","ja","ko","pt-br","tr","zh-hans"],"translatedLinks":["/why-do-react-elements-have-typeof-property/","/how-does-react-tell-a-class-from-a-function/","/why-do-we-write-super-props/"]}}}